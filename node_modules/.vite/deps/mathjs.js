import {
  ArgumentsError,
  DimensionError,
  IndexError,
  _defineProperty,
  _extends,
  absNumber,
  acoshNumber,
  acotNumber,
  acothNumber,
  acscNumber,
  acschNumber,
  addNumber,
  andNumber,
  arraySize,
  asecNumber,
  asechNumber,
  asinhNumber,
  atanhNumber,
  bitAndNumber,
  bitNotNumber,
  bitOrNumber,
  bitXorNumber,
  cbrtNumber,
  clone,
  combinationsNumber,
  config,
  copysign,
  cosh,
  cotNumber,
  cothNumber,
  create,
  createAccessorNode,
  createApply,
  createApplyTransform,
  createArrayNode,
  createAssignmentNode,
  createBellNumbers,
  createBigNumberPi,
  createBlockNode,
  createBoolean,
  createCatalan,
  createCeil,
  createChain,
  createChainClass,
  createClone,
  createCombinationsWithRep,
  createCompare,
  createCompareNatural,
  createCompareText,
  createCompile,
  createComposition,
  createConditionalNode,
  createConstantNode,
  createCumSum,
  createCumSumTransform,
  createDeepEqual,
  createDerivative,
  createE,
  createEqual,
  createEqualScalar,
  createEqualText,
  createErf,
  createEvaluate,
  createFactorial,
  createFalse,
  createFilter,
  createFilterTransform,
  createFix,
  createFloor,
  createForEach,
  createForEachTransform,
  createFormat,
  createFunctionAssignmentNode,
  createFunctionNode,
  createHasNumericValue,
  createHelp,
  createHelpClass,
  createHypot,
  createI,
  createIndexNode,
  createInfinity,
  createIsNumeric,
  createIsPrime,
  createLN10,
  createLN2,
  createLOG10E,
  createLOG2E,
  createLarger,
  createLargerEq,
  createMad,
  createMap,
  createMapTransform,
  createMatAlgo03xDSf,
  createMatAlgo05xSfSf,
  createMatAlgo07xSSf,
  createMatAlgo11xS0s,
  createMatAlgo12xSfs,
  createMatAlgo14xDs,
  createMatrixAlgorithmSuite,
  createMax,
  createMaxTransform,
  createMean,
  createMeanTransform,
  createMedian,
  createMin,
  createMinTransform,
  createMode,
  createMultinomial,
  createNaN,
  createNode,
  createNull,
  createNumber,
  createNumeric,
  createObjectNode,
  createOperatorNode,
  createParenthesisNode,
  createParse,
  createParser,
  createParserClass,
  createPartitionSelect,
  createPermutations,
  createPhi,
  createPi,
  createPickRandom,
  createPrint,
  createProd,
  createQuantileSeq,
  createRandom,
  createRandomInt,
  createRange,
  createRangeClass,
  createRangeNode,
  createRangeTransform,
  createRationalize,
  createRelationalNode,
  createReplacer,
  createResolve,
  createResultSet,
  createReviver,
  createSQRT1_2,
  createSQRT2,
  createSimplify,
  createSimplifyConstant,
  createSimplifyCore,
  createSize,
  createSmaller,
  createSmallerEq,
  createStd,
  createStdTransform,
  createStirlingS2,
  createString,
  createSum,
  createSumTransform,
  createSymbolNode,
  createTau,
  createTrue,
  createTypeOf,
  createTyped,
  createUnequal,
  createUppercaseE,
  createUppercasePi,
  createVariance,
  createVarianceTransform,
  createVersion,
  cscNumber,
  cschNumber,
  cubeNumber,
  decimal_default,
  deepMap,
  deepStrictEqual,
  embeddedDocs,
  endsWith,
  errorTransform,
  expNumber,
  expm1Number,
  extend,
  factory,
  flatten,
  format,
  format2,
  gammaG,
  gammaNumber,
  gammaP,
  gcdNumber,
  generalize,
  getArrayDataType,
  getSafeProperty,
  hasOwnProperty,
  identify,
  isAccessorNode,
  isArray,
  isArrayNode,
  isAssignmentNode,
  isBigNumber,
  isBlockNode,
  isBoolean,
  isChain,
  isCollection,
  isComplex,
  isConditionalNode,
  isConstantNode,
  isDate,
  isDenseMatrix,
  isFraction,
  isFunction,
  isFunctionAssignmentNode,
  isFunctionNode,
  isHelp,
  isIndex,
  isIndexNode,
  isInteger,
  isMatrix,
  isNaNNumber,
  isNegativeNumber,
  isNode,
  isNull,
  isNumber,
  isObject,
  isObjectNode,
  isOperatorNode,
  isParenthesisNode,
  isPositiveNumber,
  isRange,
  isRangeNode,
  isRegExp,
  isRelationalNode,
  isResultSet,
  isSparseMatrix,
  isString,
  isSymbolNode,
  isUndefined,
  isUnit,
  isZeroNumber,
  lastDimToZeroBase,
  lcmNumber,
  leftShiftNumber,
  lgammaNumber,
  lnSqrt2PI,
  log10Number,
  log1p,
  log2Number,
  logNumber,
  maxArgumentCount,
  memoize,
  modNumber,
  multiplyNumber,
  notNumber,
  nthRootNumber,
  orNumber,
  powNumber,
  processSizesWildcard,
  reshape,
  resize,
  rightArithShiftNumber,
  rightLogShiftNumber,
  roundNumber,
  scatter,
  secNumber,
  sechNumber,
  setSafeProperty,
  signNumber,
  sinhNumber,
  squareNumber,
  squeeze,
  tanh,
  typeOf,
  unaryMinusNumber,
  unaryPlusNumber,
  unsqueeze,
  validate,
  validateIndex,
  xgcdNumber,
  xorNumber
} from "./chunk-R542DLEU.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-4EOJPDL2.js";

// node_modules/complex.js/complex.js
var require_complex = __commonJS({
  "node_modules/complex.js/complex.js"(exports, module) {
    (function(root) {
      "use strict";
      var cosh3 = Math.cosh || function(x) {
        return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
      };
      var sinh2 = Math.sinh || function(x) {
        return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
      };
      var cosm1 = function(x) {
        var b = Math.PI / 4;
        if (-b > x || x > b) {
          return Math.cos(x) - 1;
        }
        var xx = x * x;
        return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
      };
      var hypot2 = function(x, y) {
        var a = Math.abs(x);
        var b = Math.abs(y);
        if (a < 3e3 && b < 3e3) {
          return Math.sqrt(a * a + b * b);
        }
        if (a < b) {
          a = b;
          b = x / y;
        } else {
          b = y / x;
        }
        return a * Math.sqrt(1 + b * b);
      };
      var parser_exit = function() {
        throw SyntaxError("Invalid Param");
      };
      function logHypot(a, b) {
        var _a = Math.abs(a);
        var _b = Math.abs(b);
        if (a === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3e3 && _b < 3e3) {
          return Math.log(a * a + b * b) * 0.5;
        }
        a = a / 2;
        b = b / 2;
        return 0.5 * Math.log(a * a + b * b) + Math.LN2;
      }
      var parse2 = function(a, b) {
        var z = { "re": 0, "im": 0 };
        if (a === void 0 || a === null) {
          z["re"] = z["im"] = 0;
        } else if (b !== void 0) {
          z["re"] = a;
          z["im"] = b;
        } else
          switch (typeof a) {
            case "object":
              if ("im" in a && "re" in a) {
                z["re"] = a["re"];
                z["im"] = a["im"];
              } else if ("abs" in a && "arg" in a) {
                if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["abs"] * Math.cos(a["arg"]);
                z["im"] = a["abs"] * Math.sin(a["arg"]);
              } else if ("r" in a && "phi" in a) {
                if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["r"] * Math.cos(a["phi"]);
                z["im"] = a["r"] * Math.sin(a["phi"]);
              } else if (a.length === 2) {
                z["re"] = a[0];
                z["im"] = a[1];
              } else {
                parser_exit();
              }
              break;
            case "string":
              z["im"] = /* void */
              z["re"] = 0;
              var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;
              if (tokens === null) {
                parser_exit();
              }
              for (var i2 = 0; i2 < tokens.length; i2++) {
                var c = tokens[i2];
                if (c === " " || c === "	" || c === "\n") {
                } else if (c === "+") {
                  plus++;
                } else if (c === "-") {
                  minus++;
                } else if (c === "i" || c === "I") {
                  if (plus + minus === 0) {
                    parser_exit();
                  }
                  if (tokens[i2 + 1] !== " " && !isNaN(tokens[i2 + 1])) {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i2 + 1]);
                    i2++;
                  } else {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit();
                  }
                  if (tokens[i2 + 1] === "i" || tokens[i2 + 1] === "I") {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                    i2++;
                  } else {
                    z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                  }
                  plus = minus = 0;
                }
              }
              if (plus + minus > 0) {
                parser_exit();
              }
              break;
            case "number":
              z["im"] = 0;
              z["re"] = a;
              break;
            default:
              parser_exit();
          }
        if (isNaN(z["re"]) || isNaN(z["im"])) {
        }
        return z;
      };
      function Complex3(a, b) {
        if (!(this instanceof Complex3)) {
          return new Complex3(a, b);
        }
        var z = parse2(a, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      Complex3.prototype = {
        "re": 0,
        "im": 0,
        /**
         * Calculates the sign of a complex number, which is a normalized complex
         *
         * @returns {Complex}
         */
        "sign": function() {
          var abs2 = this["abs"]();
          return new Complex3(
            this["re"] / abs2,
            this["im"] / abs2
          );
        },
        /**
         * Adds two complex numbers
         *
         * @returns {Complex}
         */
        "add": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] + z["re"],
            this["im"] + z["im"]
          );
        },
        /**
         * Subtracts two complex numbers
         *
         * @returns {Complex}
         */
        "sub": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] - z["re"],
            this["im"] - z["im"]
          );
        },
        /**
         * Multiplies two complex numbers
         *
         * @returns {Complex}
         */
        "mul": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          if (z["im"] === 0 && this["im"] === 0) {
            return new Complex3(this["re"] * z["re"], 0);
          }
          return new Complex3(
            this["re"] * z["re"] - this["im"] * z["im"],
            this["re"] * z["im"] + this["im"] * z["re"]
          );
        },
        /**
         * Divides two complex numbers
         *
         * @returns {Complex}
         */
        "div": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isZero"]() || z["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          a = this["re"];
          b = this["im"];
          var c = z["re"];
          var d = z["im"];
          var t, x;
          if (0 === d) {
            return new Complex3(a / c, b / c);
          }
          if (Math.abs(c) < Math.abs(d)) {
            x = c / d;
            t = c * x + d;
            return new Complex3(
              (a * x + b) / t,
              (b * x - a) / t
            );
          } else {
            x = d / c;
            t = d * x + c;
            return new Complex3(
              (a + b * x) / t,
              (b - a * x) / t
            );
          }
        },
        /**
         * Calculate the power of two complex numbers
         *
         * @returns {Complex}
         */
        "pow": function(a, b) {
          var z = new Complex3(a, b);
          a = this["re"];
          b = this["im"];
          if (z["isZero"]()) {
            return Complex3["ONE"];
          }
          if (z["im"] === 0) {
            if (b === 0 && a > 0) {
              return new Complex3(Math.pow(a, z["re"]), 0);
            } else if (a === 0) {
              switch ((z["re"] % 4 + 4) % 4) {
                case 0:
                  return new Complex3(Math.pow(b, z["re"]), 0);
                case 1:
                  return new Complex3(0, Math.pow(b, z["re"]));
                case 2:
                  return new Complex3(-Math.pow(b, z["re"]), 0);
                case 3:
                  return new Complex3(0, -Math.pow(b, z["re"]));
              }
            }
          }
          if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
            return Complex3["ZERO"];
          }
          var arg2 = Math.atan2(b, a);
          var loh = logHypot(a, b);
          a = Math.exp(z["re"] * loh - z["im"] * arg2);
          b = z["im"] * loh + z["re"] * arg2;
          return new Complex3(
            a * Math.cos(b),
            a * Math.sin(b)
          );
        },
        /**
         * Calculate the complex square root
         *
         * @returns {Complex}
         */
        "sqrt": function() {
          var a = this["re"];
          var b = this["im"];
          var r = this["abs"]();
          var re2, im2;
          if (a >= 0) {
            if (b === 0) {
              return new Complex3(Math.sqrt(a), 0);
            }
            re2 = 0.5 * Math.sqrt(2 * (r + a));
          } else {
            re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
          }
          if (a <= 0) {
            im2 = 0.5 * Math.sqrt(2 * (r - a));
          } else {
            im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
          }
          return new Complex3(re2, b < 0 ? -im2 : im2);
        },
        /**
         * Calculate the complex exponent
         *
         * @returns {Complex}
         */
        "exp": function() {
          var tmp = Math.exp(this["re"]);
          if (this["im"] === 0) {
          }
          return new Complex3(
            tmp * Math.cos(this["im"]),
            tmp * Math.sin(this["im"])
          );
        },
        /**
         * Calculate the complex exponent and subtracts one.
         *
         * This may be more accurate than `Complex(x).exp().sub(1)` if
         * `x` is small.
         *
         * @returns {Complex}
         */
        "expm1": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.expm1(a) * Math.cos(b) + cosm1(b),
            Math.exp(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the natural log
         *
         * @returns {Complex}
         */
        "log": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0 && a > 0) {
          }
          return new Complex3(
            logHypot(a, b),
            Math.atan2(b, a)
          );
        },
        /**
         * Calculate the magnitude of the complex number
         *
         * @returns {number}
         */
        "abs": function() {
          return hypot2(this["re"], this["im"]);
        },
        /**
         * Calculate the angle of the complex number
         *
         * @returns {number}
         */
        "arg": function() {
          return Math.atan2(this["im"], this["re"]);
        },
        /**
         * Calculate the sine of the complex number
         *
         * @returns {Complex}
         */
        "sin": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.sin(a) * cosh3(b),
            Math.cos(a) * sinh2(b)
          );
        },
        /**
         * Calculate the cosine
         *
         * @returns {Complex}
         */
        "cos": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.cos(a) * cosh3(b),
            -Math.sin(a) * sinh2(b)
          );
        },
        /**
         * Calculate the tangent
         *
         * @returns {Complex}
         */
        "tan": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) + cosh3(b);
          return new Complex3(
            Math.sin(a) / d,
            sinh2(b) / d
          );
        },
        /**
         * Calculate the cotangent
         *
         * @returns {Complex}
         */
        "cot": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) - cosh3(b);
          return new Complex3(
            -Math.sin(a) / d,
            sinh2(b) / d
          );
        },
        /**
         * Calculate the secant
         *
         * @returns {Complex}
         */
        "sec": function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh3(2 * b) + 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.cos(a) * cosh3(b) / d,
            Math.sin(a) * sinh2(b) / d
          );
        },
        /**
         * Calculate the cosecans
         *
         * @returns {Complex}
         */
        "csc": function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh3(2 * b) - 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.sin(a) * cosh3(b) / d,
            -Math.cos(a) * sinh2(b) / d
          );
        },
        /**
         * Calculate the complex arcus sinus
         *
         * @returns {Complex}
         */
        "asin": function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          var t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(t2["im"], -t2["re"]);
        },
        /**
         * Calculate the complex arcus cosinus
         *
         * @returns {Complex}
         */
        "acos": function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          var t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(Math.PI / 2 - t2["im"], t2["re"]);
        },
        /**
         * Calculate the complex arcus tangent
         *
         * @returns {Complex}
         */
        "atan": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0) {
            if (b === 1) {
              return new Complex3(0, Infinity);
            }
            if (b === -1) {
              return new Complex3(0, -Infinity);
            }
          }
          var d = a * a + (1 - b) * (1 - b);
          var t1 = new Complex3(
            (1 - b * b - a * a) / d,
            -2 * a / d
          ).log();
          return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
        },
        /**
         * Calculate the complex arcus cotangent
         *
         * @returns {Complex}
         */
        "acot": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(Math.atan2(1, a), 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atan() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atan();
        },
        /**
         * Calculate the complex arcus secant
         *
         * @returns {Complex}
         */
        "asec": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acos() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acos();
        },
        /**
         * Calculate the complex arcus cosecans
         *
         * @returns {Complex}
         */
        "acsc": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(Math.PI / 2, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asin() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asin();
        },
        /**
         * Calculate the complex sinh
         *
         * @returns {Complex}
         */
        "sinh": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            sinh2(a) * Math.cos(b),
            cosh3(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex cosh
         *
         * @returns {Complex}
         */
        "cosh": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            cosh3(a) * Math.cos(b),
            sinh2(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex tanh
         *
         * @returns {Complex}
         */
        "tanh": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh3(a) + Math.cos(b);
          return new Complex3(
            sinh2(a) / d,
            Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "coth": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh3(a) - Math.cos(b);
          return new Complex3(
            sinh2(a) / d,
            -Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "csch": function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) - cosh3(2 * a);
          return new Complex3(
            -2 * sinh2(a) * Math.cos(b) / d,
            2 * cosh3(a) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex sech
         *
         * @returns {Complex}
         */
        "sech": function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) + cosh3(2 * a);
          return new Complex3(
            2 * cosh3(a) * Math.cos(b) / d,
            -2 * sinh2(a) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        "asinh": function() {
          var tmp = this["im"];
          this["im"] = -this["re"];
          this["re"] = tmp;
          var res = this["asin"]();
          this["re"] = -this["im"];
          this["im"] = tmp;
          tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
          return res;
        },
        /**
         * Calculate the complex acosh
         *
         * @returns {Complex}
         */
        "acosh": function() {
          var res = this["acos"]();
          if (res["im"] <= 0) {
            var tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
          } else {
            var tmp = res["im"];
            res["im"] = -res["re"];
            res["re"] = tmp;
          }
          return res;
        },
        /**
         * Calculate the complex atanh
         *
         * @returns {Complex}
         */
        "atanh": function() {
          var a = this["re"];
          var b = this["im"];
          var noIM = a > 1 && b === 0;
          var oneMinus = 1 - a;
          var onePlus = 1 + a;
          var d = oneMinus * oneMinus + b * b;
          var x = d !== 0 ? new Complex3(
            (onePlus * oneMinus - b * b) / d,
            (b * oneMinus + onePlus * b) / d
          ) : new Complex3(
            a !== -1 ? a / 0 : 0,
            b !== 0 ? b / 0 : 0
          );
          var temp = x["re"];
          x["re"] = logHypot(x["re"], x["im"]) / 2;
          x["im"] = Math.atan2(x["im"], temp) / 2;
          if (noIM) {
            x["im"] = -x["im"];
          }
          return x;
        },
        /**
         * Calculate the complex acoth
         *
         * @returns {Complex}
         */
        "acoth": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Math.PI / 2);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atanh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atanh();
        },
        /**
         * Calculate the complex acsch
         *
         * @returns {Complex}
         */
        "acsch": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(
              a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
              0
            );
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asinh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asinh();
        },
        /**
         * Calculate the complex asech
         *
         * @returns {Complex}
         */
        "asech": function() {
          var a = this["re"];
          var b = this["im"];
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acosh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acosh();
        },
        /**
         * Calculate the complex inverse 1/z
         *
         * @returns {Complex}
         */
        "inverse": function() {
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          var a = this["re"];
          var b = this["im"];
          var d = a * a + b * b;
          return new Complex3(a / d, -b / d);
        },
        /**
         * Returns the complex conjugate
         *
         * @returns {Complex}
         */
        "conjugate": function() {
          return new Complex3(this["re"], -this["im"]);
        },
        /**
         * Gets the negated complex number
         *
         * @returns {Complex}
         */
        "neg": function() {
          return new Complex3(-this["re"], -this["im"]);
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.ceil(this["re"] * places) / places,
            Math.ceil(this["im"] * places) / places
          );
        },
        /**
         * Floors the actual complex number
         *
         * @returns {Complex}
         */
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.floor(this["re"] * places) / places,
            Math.floor(this["im"] * places) / places
          );
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "round": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.round(this["re"] * places) / places,
            Math.round(this["im"] * places) / places
          );
        },
        /**
         * Compares two complex numbers
         *
         * **Note:** new Complex(Infinity).equals(Infinity) === false
         *
         * @returns {boolean}
         */
        "equals": function(a, b) {
          var z = new Complex3(a, b);
          return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
        },
        /**
         * Clones the actual object
         *
         * @returns {Complex}
         */
        "clone": function() {
          return new Complex3(this["re"], this["im"]);
        },
        /**
         * Gets a string of the actual complex number
         *
         * @returns {string}
         */
        "toString": function() {
          var a = this["re"];
          var b = this["im"];
          var ret = "";
          if (this["isNaN"]()) {
            return "NaN";
          }
          if (this["isInfinite"]()) {
            return "Infinity";
          }
          if (Math.abs(a) < Complex3["EPSILON"]) {
            a = 0;
          }
          if (Math.abs(b) < Complex3["EPSILON"]) {
            b = 0;
          }
          if (b === 0) {
            return ret + a;
          }
          if (a !== 0) {
            ret += a;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (1 !== b) {
            ret += b;
          }
          return ret + "i";
        },
        /**
         * Returns the actual number as a vector
         *
         * @returns {Array}
         */
        "toVector": function() {
          return [this["re"], this["im"]];
        },
        /**
         * Returns the actual real value of the current object
         *
         * @returns {number|null}
         */
        "valueOf": function() {
          if (this["im"] === 0) {
            return this["re"];
          }
          return null;
        },
        /**
         * Determines whether a complex number is not on the Riemann sphere.
         *
         * @returns {boolean}
         */
        "isNaN": function() {
          return isNaN(this["re"]) || isNaN(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the zero pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isZero": function() {
          return this["im"] === 0 && this["re"] === 0;
        },
        /**
         * Determines whether a complex number is not at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isFinite": function() {
          return isFinite(this["re"]) && isFinite(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isInfinite": function() {
          return !(this["isNaN"]() || this["isFinite"]());
        }
      };
      Complex3["ZERO"] = new Complex3(0, 0);
      Complex3["ONE"] = new Complex3(1, 0);
      Complex3["I"] = new Complex3(0, 1);
      Complex3["PI"] = new Complex3(Math.PI, 0);
      Complex3["E"] = new Complex3(Math.E, 0);
      Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
      Complex3["NAN"] = new Complex3(NaN, NaN);
      Complex3["EPSILON"] = 1e-15;
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Complex3;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(Complex3, "__esModule", { "value": true });
        Complex3["default"] = Complex3;
        Complex3["Complex"] = Complex3;
        module["exports"] = Complex3;
      } else {
        root["Complex"] = Complex3;
      }
    })(exports);
  }
});

// node_modules/fraction.js/fraction.js
var require_fraction = __commonJS({
  "node_modules/fraction.js/fraction.js"(exports, module) {
    (function(root) {
      "use strict";
      var MAX_CYCLE_LEN = 2e3;
      var P = {
        "s": 1,
        "n": 0,
        "d": 1
      };
      function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
          throw Fraction3["InvalidParameter"];
        }
        return n * s;
      }
      function newFraction(n, d) {
        if (d === 0) {
          throw Fraction3["DivisionByZero"];
        }
        var f = Object.create(Fraction3.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a = gcd2(n, d);
        f["n"] = n / a;
        f["d"] = d / a;
        return f;
      }
      function factorize(num) {
        var factors = {};
        var n = num;
        var i2 = 2;
        var s = 4;
        while (s <= n) {
          while (n % i2 === 0) {
            n /= i2;
            factors[i2] = (factors[i2] || 0) + 1;
          }
          s += 1 + 2 * i2++;
        }
        if (n !== num) {
          if (n > 1)
            factors[n] = (factors[n] || 0) + 1;
        } else {
          factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
      }
      var parse2 = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 1e7;
        var M;
        if (p1 === void 0 || p1 === null) {
        } else if (p2 !== void 0) {
          n = p1;
          d = p2;
          s = n * d;
          if (n % 1 !== 0 || d % 1 !== 0) {
            throw Fraction3["NonIntegerParameter"];
          }
        } else
          switch (typeof p1) {
            case "object": {
              if ("d" in p1 && "n" in p1) {
                n = p1["n"];
                d = p1["d"];
                if ("s" in p1)
                  n *= p1["s"];
              } else if (0 in p1) {
                n = p1[0];
                if (1 in p1)
                  d = p1[1];
              } else {
                throw Fraction3["InvalidParameter"];
              }
              s = n * d;
              break;
            }
            case "number": {
              if (p1 < 0) {
                s = p1;
                p1 = -p1;
              }
              if (p1 % 1 === 0) {
                n = p1;
              } else if (p1 > 0) {
                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }
                while (B <= N && D <= N) {
                  M = (A + C) / (B + D);
                  if (p1 === M) {
                    if (B + D <= N) {
                      n = A + C;
                      d = B + D;
                    } else if (D > B) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                    break;
                  } else {
                    if (p1 > M) {
                      A += C;
                      B += D;
                    } else {
                      C += A;
                      D += B;
                    }
                    if (B > N) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                  }
                }
                n *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d = n = NaN;
              }
              break;
            }
            case "string": {
              B = p1.match(/\d+|./g);
              if (B === null)
                throw Fraction3["InvalidParameter"];
              if (B[A] === "-") {
                s = -1;
                A++;
              } else if (B[A] === "+") {
                A++;
              }
              if (B.length === A + 1) {
                w = assign(B[A++], s);
              } else if (B[A + 1] === "." || B[A] === ".") {
                if (B[A] !== ".") {
                  v = assign(B[A++], s);
                }
                A++;
                if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                  w = assign(B[A], s);
                  y = Math.pow(10, B[A].length);
                  A++;
                }
                if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                  x = assign(B[A + 1], s);
                  z = Math.pow(10, B[A + 1].length) - 1;
                  A += 3;
                }
              } else if (B[A + 1] === "/" || B[A + 1] === ":") {
                w = assign(B[A], s);
                y = assign(B[A + 2], 1);
                A += 3;
              } else if (B[A + 3] === "/" && B[A + 1] === " ") {
                v = assign(B[A], s);
                w = assign(B[A + 2], s);
                y = assign(B[A + 4], 1);
                A += 5;
              }
              if (B.length <= A) {
                d = y * z;
                s = /* void */
                n = x + d * v + z * w;
                break;
              }
            }
            default:
              throw Fraction3["InvalidParameter"];
          }
        if (d === 0) {
          throw Fraction3["DivisionByZero"];
        }
        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
      };
      function modpow(b, e2, m) {
        var r = 1;
        for (; e2 > 0; b = b * b % m, e2 >>= 1) {
          if (e2 & 1) {
            r = r * b % m;
          }
        }
        return r;
      }
      function cycleLen(n, d) {
        for (; d % 2 === 0; d /= 2) {
        }
        for (; d % 5 === 0; d /= 5) {
        }
        if (d === 1)
          return 0;
        var rem = 10 % d;
        var t = 1;
        for (; rem !== 1; t++) {
          rem = rem * 10 % d;
          if (t > MAX_CYCLE_LEN)
            return 0;
        }
        return t;
      }
      function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for (var t = 0; t < 300; t++) {
          if (rem1 === rem2)
            return t;
          rem1 = rem1 * 10 % d;
          rem2 = rem2 * 10 % d;
        }
        return 0;
      }
      function gcd2(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        while (1) {
          a %= b;
          if (!a)
            return b;
          b %= a;
          if (!b)
            return a;
        }
      }
      ;
      function Fraction3(a, b) {
        parse2(a, b);
        if (this instanceof Fraction3) {
          a = gcd2(P["d"], P["n"]);
          this["s"] = P["s"];
          this["n"] = P["n"] / a;
          this["d"] = P["d"] / a;
        } else {
          return newFraction(P["s"] * P["n"], P["d"]);
        }
      }
      Fraction3["DivisionByZero"] = new Error("Division by Zero");
      Fraction3["InvalidParameter"] = new Error("Invalid argument");
      Fraction3["NonIntegerParameter"] = new Error("Parameters must be integer");
      Fraction3.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
         * Calculates the absolute value
         *
         * Ex: new Fraction(-4).abs() => 4
         **/
        "abs": function() {
          return newFraction(this["n"], this["d"]);
        },
        /**
         * Inverts the sign of the current fraction
         *
         * Ex: new Fraction(-4).neg() => 4
         **/
        "neg": function() {
          return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
         * Adds two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
         **/
        "add": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
            this["d"] * P["d"]
          );
        },
        /**
         * Subtracts two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
         **/
        "sub": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
            this["d"] * P["d"]
          );
        },
        /**
         * Multiplies two rational numbers
         *
         * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
         **/
        "mul": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * P["s"] * this["n"] * P["n"],
            this["d"] * P["d"]
          );
        },
        /**
         * Divides two rational numbers
         *
         * Ex: new Fraction("-17.(345)").inverse().div(3)
         **/
        "div": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * P["s"] * this["n"] * P["d"],
            this["d"] * P["n"]
          );
        },
        /**
         * Clones the actual object
         *
         * Ex: new Fraction("-17.(345)").clone()
         **/
        "clone": function() {
          return newFraction(this["s"] * this["n"], this["d"]);
        },
        /**
         * Calculates the modulo of two rational numbers - a more precise fmod
         *
         * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
         **/
        "mod": function(a, b) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          if (a === void 0) {
            return newFraction(this["s"] * this["n"] % this["d"], 1);
          }
          parse2(a, b);
          if (0 === P["n"] && 0 === this["d"]) {
            throw Fraction3["DivisionByZero"];
          }
          return newFraction(
            this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
            P["d"] * this["d"]
          );
        },
        /**
         * Calculates the fractional gcd of two rational numbers
         *
         * Ex: new Fraction(5,8).gcd(3,7) => 1/56
         */
        "gcd": function(a, b) {
          parse2(a, b);
          return newFraction(gcd2(P["n"], this["n"]) * gcd2(P["d"], this["d"]), P["d"] * this["d"]);
        },
        /**
         * Calculates the fractional lcm of two rational numbers
         *
         * Ex: new Fraction(5,8).lcm(3,7) => 15
         */
        "lcm": function(a, b) {
          parse2(a, b);
          if (P["n"] === 0 && this["n"] === 0) {
            return newFraction(0, 1);
          }
          return newFraction(P["n"] * this["n"], gcd2(P["n"], this["n"]) * gcd2(P["d"], this["d"]));
        },
        /**
         * Calculates the ceil of a rational number
         *
         * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
         **/
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Calculates the floor of a rational number
         *
         * Ex: new Fraction('4.(3)').floor() => (4 / 1)
         **/
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Rounds a rational numbers
         *
         * Ex: new Fraction('4.(3)').round() => (4 / 1)
         **/
        "round": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Gets the inverse of the fraction, means numerator and denominator are exchanged
         *
         * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
         **/
        "inverse": function() {
          return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
         * Calculates the fraction to some rational exponent, if possible
         *
         * Ex: new Fraction(-1,2).pow(-3) => -8
         */
        "pow": function(a, b) {
          parse2(a, b);
          if (P["d"] === 1) {
            if (P["s"] < 0) {
              return newFraction(Math.pow(this["s"] * this["d"], P["n"]), Math.pow(this["n"], P["n"]));
            } else {
              return newFraction(Math.pow(this["s"] * this["n"], P["n"]), Math.pow(this["d"], P["n"]));
            }
          }
          if (this["s"] < 0)
            return null;
          var N = factorize(this["n"]);
          var D = factorize(this["d"]);
          var n = 1;
          var d = 1;
          for (var k in N) {
            if (k === "1")
              continue;
            if (k === "0") {
              n = 0;
              break;
            }
            N[k] *= P["n"];
            if (N[k] % P["d"] === 0) {
              N[k] /= P["d"];
            } else
              return null;
            n *= Math.pow(k, N[k]);
          }
          for (var k in D) {
            if (k === "1")
              continue;
            D[k] *= P["n"];
            if (D[k] % P["d"] === 0) {
              D[k] /= P["d"];
            } else
              return null;
            d *= Math.pow(k, D[k]);
          }
          if (P["s"] < 0) {
            return newFraction(d, n);
          }
          return newFraction(n, d);
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "equals": function(a, b) {
          parse2(a, b);
          return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "compare": function(a, b) {
          parse2(a, b);
          var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
          return (0 < t) - (t < 0);
        },
        "simplify": function(eps) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return this;
          }
          eps = eps || 1e-3;
          var thisABS = this["abs"]();
          var cont = thisABS["toContinued"]();
          for (var i2 = 1; i2 < cont.length; i2++) {
            var s = newFraction(cont[i2 - 1], 1);
            for (var k = i2 - 2; k >= 0; k--) {
              s = s["inverse"]()["add"](cont[k]);
            }
            if (s["sub"](thisABS)["abs"]().valueOf() < eps) {
              return s["mul"](this["s"]);
            }
          }
          return this;
        },
        /**
         * Check if two rational numbers are divisible
         *
         * Ex: new Fraction(19.6).divisible(1.5);
         */
        "divisible": function(a, b) {
          parse2(a, b);
          return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
         * Returns a decimal representation of the fraction
         *
         * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
         **/
        "valueOf": function() {
          return this["s"] * this["n"] / this["d"];
        },
        /**
         * Returns a string-fraction representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
         **/
        "toFraction": function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              str += " ";
              n %= d;
            }
            str += n;
            str += "/";
            str += d;
          }
          return str;
        },
        /**
         * Returns a latex representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
         **/
        "toLatex": function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              n %= d;
            }
            str += "\\frac{";
            str += n;
            str += "}{";
            str += d;
            str += "}";
          }
          return str;
        },
        /**
         * Returns an array of continued fraction elements
         *
         * Ex: new Fraction("7/8").toContinued() => [0,1,7]
         */
        "toContinued": function() {
          var t;
          var a = this["n"];
          var b = this["d"];
          var res = [];
          if (isNaN(a) || isNaN(b)) {
            return res;
          }
          do {
            res.push(Math.floor(a / b));
            t = a % b;
            a = b;
            b = t;
          } while (a !== 1);
          return res;
        },
        /**
         * Creates a string representation of a fraction with all digits
         *
         * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
         **/
        "toString": function(dec) {
          var N = this["n"];
          var D = this["d"];
          if (isNaN(N) || isNaN(D)) {
            return "NaN";
          }
          dec = dec || 15;
          var cycLen = cycleLen(N, D);
          var cycOff = cycleStart(N, D, cycLen);
          var str = this["s"] < 0 ? "-" : "";
          str += N / D | 0;
          N %= D;
          N *= 10;
          if (N)
            str += ".";
          if (cycLen) {
            for (var i2 = cycOff; i2--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += "(";
            for (var i2 = cycLen; i2--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += ")";
          } else {
            for (var i2 = dec; N && i2--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
          }
          return str;
        }
      };
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Fraction3;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(Fraction3, "__esModule", { "value": true });
        Fraction3["default"] = Fraction3;
        Fraction3["Fraction"] = Fraction3;
        module["exports"] = Fraction3;
      } else {
        root["Fraction"] = Fraction3;
      }
    })(exports);
  }
});

// node_modules/mathjs/lib/esm/factoriesAny.js
var factoriesAny_exports = {};
__export(factoriesAny_exports, {
  createAbs: () => createAbs,
  createAccessorNode: () => createAccessorNode,
  createAcos: () => createAcos,
  createAcosh: () => createAcosh,
  createAcot: () => createAcot,
  createAcoth: () => createAcoth,
  createAcsc: () => createAcsc,
  createAcsch: () => createAcsch,
  createAdd: () => createAdd,
  createAddScalar: () => createAddScalar,
  createAnd: () => createAnd,
  createApply: () => createApply,
  createApplyTransform: () => createApplyTransform,
  createArg: () => createArg,
  createArrayNode: () => createArrayNode,
  createAsec: () => createAsec,
  createAsech: () => createAsech,
  createAsin: () => createAsin,
  createAsinh: () => createAsinh,
  createAssignmentNode: () => createAssignmentNode,
  createAtan: () => createAtan,
  createAtan2: () => createAtan2,
  createAtanh: () => createAtanh,
  createAtomicMass: () => createAtomicMass,
  createAvogadro: () => createAvogadro,
  createBellNumbers: () => createBellNumbers,
  createBigNumberClass: () => createBigNumberClass,
  createBignumber: () => createBignumber,
  createBin: () => createBin,
  createBitAnd: () => createBitAnd,
  createBitNot: () => createBitNot,
  createBitOr: () => createBitOr,
  createBitXor: () => createBitXor,
  createBlockNode: () => createBlockNode,
  createBohrMagneton: () => createBohrMagneton,
  createBohrRadius: () => createBohrRadius,
  createBoltzmann: () => createBoltzmann,
  createBoolean: () => createBoolean,
  createCatalan: () => createCatalan,
  createCbrt: () => createCbrt,
  createCeil: () => createCeil,
  createChain: () => createChain,
  createChainClass: () => createChainClass,
  createClassicalElectronRadius: () => createClassicalElectronRadius,
  createClone: () => createClone,
  createColumn: () => createColumn,
  createColumnTransform: () => createColumnTransform,
  createCombinations: () => createCombinations,
  createCombinationsWithRep: () => createCombinationsWithRep,
  createCompare: () => createCompare,
  createCompareNatural: () => createCompareNatural,
  createCompareText: () => createCompareText,
  createCompile: () => createCompile,
  createComplex: () => createComplex,
  createComplexClass: () => createComplexClass,
  createComposition: () => createComposition,
  createConcat: () => createConcat,
  createConcatTransform: () => createConcatTransform,
  createConditionalNode: () => createConditionalNode,
  createConductanceQuantum: () => createConductanceQuantum,
  createConj: () => createConj,
  createConstantNode: () => createConstantNode,
  createCos: () => createCos,
  createCosh: () => createCosh,
  createCot: () => createCot,
  createCoth: () => createCoth,
  createCoulomb: () => createCoulomb,
  createCount: () => createCount,
  createCreateUnit: () => createCreateUnit,
  createCross: () => createCross,
  createCsc: () => createCsc,
  createCsch: () => createCsch,
  createCtranspose: () => createCtranspose,
  createCube: () => createCube,
  createCumSum: () => createCumSum,
  createCumSumTransform: () => createCumSumTransform,
  createDeepEqual: () => createDeepEqual,
  createDenseMatrixClass: () => createDenseMatrixClass,
  createDerivative: () => createDerivative,
  createDet: () => createDet,
  createDeuteronMass: () => createDeuteronMass,
  createDiag: () => createDiag,
  createDiff: () => createDiff,
  createDiffTransform: () => createDiffTransform,
  createDistance: () => createDistance,
  createDivide: () => createDivide,
  createDivideScalar: () => createDivideScalar,
  createDot: () => createDot,
  createDotDivide: () => createDotDivide,
  createDotMultiply: () => createDotMultiply,
  createDotPow: () => createDotPow,
  createE: () => createE,
  createEfimovFactor: () => createEfimovFactor,
  createEigs: () => createEigs,
  createElectricConstant: () => createElectricConstant,
  createElectronMass: () => createElectronMass,
  createElementaryCharge: () => createElementaryCharge,
  createEqual: () => createEqual,
  createEqualScalar: () => createEqualScalar,
  createEqualText: () => createEqualText,
  createErf: () => createErf,
  createEvaluate: () => createEvaluate,
  createExp: () => createExp,
  createExpm: () => createExpm,
  createExpm1: () => createExpm1,
  createFactorial: () => createFactorial,
  createFalse: () => createFalse,
  createFaraday: () => createFaraday,
  createFermiCoupling: () => createFermiCoupling,
  createFft: () => createFft,
  createFibonacciHeapClass: () => createFibonacciHeapClass,
  createFilter: () => createFilter,
  createFilterTransform: () => createFilterTransform,
  createFineStructure: () => createFineStructure,
  createFirstRadiation: () => createFirstRadiation,
  createFix: () => createFix,
  createFlatten: () => createFlatten,
  createFloor: () => createFloor,
  createForEach: () => createForEach,
  createForEachTransform: () => createForEachTransform,
  createFormat: () => createFormat,
  createFraction: () => createFraction,
  createFractionClass: () => createFractionClass,
  createFunctionAssignmentNode: () => createFunctionAssignmentNode,
  createFunctionNode: () => createFunctionNode,
  createGamma: () => createGamma,
  createGasConstant: () => createGasConstant,
  createGcd: () => createGcd,
  createGetMatrixDataType: () => createGetMatrixDataType,
  createGravitationConstant: () => createGravitationConstant,
  createGravity: () => createGravity,
  createHartreeEnergy: () => createHartreeEnergy,
  createHasNumericValue: () => createHasNumericValue,
  createHelp: () => createHelp,
  createHelpClass: () => createHelpClass,
  createHex: () => createHex,
  createHypot: () => createHypot,
  createI: () => createI,
  createIdentity: () => createIdentity,
  createIfft: () => createIfft,
  createIm: () => createIm,
  createImmutableDenseMatrixClass: () => createImmutableDenseMatrixClass,
  createIndex: () => createIndex,
  createIndexClass: () => createIndexClass,
  createIndexNode: () => createIndexNode,
  createIndexTransform: () => createIndexTransform,
  createInfinity: () => createInfinity,
  createIntersect: () => createIntersect,
  createInv: () => createInv,
  createInverseConductanceQuantum: () => createInverseConductanceQuantum,
  createInvmod: () => createInvmod,
  createIsInteger: () => createIsInteger,
  createIsNaN: () => createIsNaN,
  createIsNegative: () => createIsNegative,
  createIsNumeric: () => createIsNumeric,
  createIsPositive: () => createIsPositive,
  createIsPrime: () => createIsPrime,
  createIsZero: () => createIsZero,
  createKldivergence: () => createKldivergence,
  createKlitzing: () => createKlitzing,
  createKron: () => createKron,
  createLN10: () => createLN10,
  createLN2: () => createLN2,
  createLOG10E: () => createLOG10E,
  createLOG2E: () => createLOG2E,
  createLarger: () => createLarger,
  createLargerEq: () => createLargerEq,
  createLcm: () => createLcm,
  createLeafCount: () => createLeafCount,
  createLeftShift: () => createLeftShift,
  createLgamma: () => createLgamma,
  createLog: () => createLog,
  createLog10: () => createLog10,
  createLog1p: () => createLog1p,
  createLog2: () => createLog2,
  createLoschmidt: () => createLoschmidt,
  createLsolve: () => createLsolve,
  createLsolveAll: () => createLsolveAll,
  createLup: () => createLup,
  createLusolve: () => createLusolve,
  createLyap: () => createLyap,
  createMad: () => createMad,
  createMagneticConstant: () => createMagneticConstant,
  createMagneticFluxQuantum: () => createMagneticFluxQuantum,
  createMap: () => createMap,
  createMapTransform: () => createMapTransform,
  createMatrix: () => createMatrix,
  createMatrixClass: () => createMatrixClass,
  createMatrixFromColumns: () => createMatrixFromColumns,
  createMatrixFromFunction: () => createMatrixFromFunction,
  createMatrixFromRows: () => createMatrixFromRows,
  createMax: () => createMax,
  createMaxTransform: () => createMaxTransform,
  createMean: () => createMean,
  createMeanTransform: () => createMeanTransform,
  createMedian: () => createMedian,
  createMin: () => createMin,
  createMinTransform: () => createMinTransform,
  createMod: () => createMod,
  createMode: () => createMode,
  createMolarMass: () => createMolarMass,
  createMolarMassC12: () => createMolarMassC12,
  createMolarPlanckConstant: () => createMolarPlanckConstant,
  createMolarVolume: () => createMolarVolume,
  createMultinomial: () => createMultinomial,
  createMultiply: () => createMultiply,
  createMultiplyScalar: () => createMultiplyScalar,
  createNaN: () => createNaN,
  createNeutronMass: () => createNeutronMass,
  createNode: () => createNode,
  createNorm: () => createNorm,
  createNot: () => createNot,
  createNthRoot: () => createNthRoot,
  createNthRoots: () => createNthRoots,
  createNuclearMagneton: () => createNuclearMagneton,
  createNull: () => createNull,
  createNumber: () => createNumber,
  createNumeric: () => createNumeric,
  createObjectNode: () => createObjectNode,
  createOct: () => createOct,
  createOnes: () => createOnes,
  createOperatorNode: () => createOperatorNode,
  createOr: () => createOr,
  createParenthesisNode: () => createParenthesisNode,
  createParse: () => createParse,
  createParser: () => createParser,
  createParserClass: () => createParserClass,
  createPartitionSelect: () => createPartitionSelect,
  createPermutations: () => createPermutations,
  createPhi: () => createPhi,
  createPi: () => createPi,
  createPickRandom: () => createPickRandom,
  createPinv: () => createPinv,
  createPlanckCharge: () => createPlanckCharge,
  createPlanckConstant: () => createPlanckConstant,
  createPlanckLength: () => createPlanckLength,
  createPlanckMass: () => createPlanckMass,
  createPlanckTemperature: () => createPlanckTemperature,
  createPlanckTime: () => createPlanckTime,
  createPolynomialRoot: () => createPolynomialRoot,
  createPow: () => createPow,
  createPrint: () => createPrint,
  createProd: () => createProd,
  createProtonMass: () => createProtonMass,
  createQr: () => createQr,
  createQuantileSeq: () => createQuantileSeq,
  createQuantumOfCirculation: () => createQuantumOfCirculation,
  createRandom: () => createRandom,
  createRandomInt: () => createRandomInt,
  createRange: () => createRange,
  createRangeClass: () => createRangeClass,
  createRangeNode: () => createRangeNode,
  createRangeTransform: () => createRangeTransform,
  createRationalize: () => createRationalize,
  createRe: () => createRe,
  createReducedPlanckConstant: () => createReducedPlanckConstant,
  createRelationalNode: () => createRelationalNode,
  createReplacer: () => createReplacer,
  createReshape: () => createReshape,
  createResize: () => createResize,
  createResolve: () => createResolve,
  createResultSet: () => createResultSet,
  createReviver: () => createReviver,
  createRightArithShift: () => createRightArithShift,
  createRightLogShift: () => createRightLogShift,
  createRotate: () => createRotate,
  createRotationMatrix: () => createRotationMatrix,
  createRound: () => createRound,
  createRow: () => createRow,
  createRowTransform: () => createRowTransform,
  createRydberg: () => createRydberg,
  createSQRT1_2: () => createSQRT1_2,
  createSQRT2: () => createSQRT2,
  createSackurTetrode: () => createSackurTetrode,
  createSchur: () => createSchur,
  createSec: () => createSec,
  createSech: () => createSech,
  createSecondRadiation: () => createSecondRadiation,
  createSetCartesian: () => createSetCartesian,
  createSetDifference: () => createSetDifference,
  createSetDistinct: () => createSetDistinct,
  createSetIntersect: () => createSetIntersect,
  createSetIsSubset: () => createSetIsSubset,
  createSetMultiplicity: () => createSetMultiplicity,
  createSetPowerset: () => createSetPowerset,
  createSetSize: () => createSetSize,
  createSetSymDifference: () => createSetSymDifference,
  createSetUnion: () => createSetUnion,
  createSign: () => createSign,
  createSimplify: () => createSimplify,
  createSimplifyConstant: () => createSimplifyConstant,
  createSimplifyCore: () => createSimplifyCore,
  createSin: () => createSin,
  createSinh: () => createSinh,
  createSize: () => createSize,
  createSlu: () => createSlu,
  createSmaller: () => createSmaller,
  createSmallerEq: () => createSmallerEq,
  createSort: () => createSort,
  createSpaClass: () => createSpaClass,
  createSparse: () => createSparse,
  createSparseMatrixClass: () => createSparseMatrixClass,
  createSpeedOfLight: () => createSpeedOfLight,
  createSplitUnit: () => createSplitUnit,
  createSqrt: () => createSqrt,
  createSqrtm: () => createSqrtm,
  createSquare: () => createSquare,
  createSqueeze: () => createSqueeze,
  createStd: () => createStd,
  createStdTransform: () => createStdTransform,
  createStefanBoltzmann: () => createStefanBoltzmann,
  createStirlingS2: () => createStirlingS2,
  createString: () => createString,
  createSubset: () => createSubset,
  createSubsetTransform: () => createSubsetTransform,
  createSubtract: () => createSubtract,
  createSum: () => createSum,
  createSumTransform: () => createSumTransform,
  createSylvester: () => createSylvester,
  createSymbolNode: () => createSymbolNode,
  createSymbolicEqual: () => createSymbolicEqual,
  createTan: () => createTan,
  createTanh: () => createTanh,
  createTau: () => createTau,
  createThomsonCrossSection: () => createThomsonCrossSection,
  createTo: () => createTo,
  createTrace: () => createTrace,
  createTranspose: () => createTranspose,
  createTrue: () => createTrue,
  createTypeOf: () => createTypeOf,
  createTyped: () => createTyped,
  createUnaryMinus: () => createUnaryMinus,
  createUnaryPlus: () => createUnaryPlus,
  createUnequal: () => createUnequal,
  createUnitClass: () => createUnitClass,
  createUnitFunction: () => createUnitFunction,
  createUppercaseE: () => createUppercaseE,
  createUppercasePi: () => createUppercasePi,
  createUsolve: () => createUsolve,
  createUsolveAll: () => createUsolveAll,
  createVacuumImpedance: () => createVacuumImpedance,
  createVariance: () => createVariance,
  createVarianceTransform: () => createVarianceTransform,
  createVersion: () => createVersion,
  createWeakMixingAngle: () => createWeakMixingAngle,
  createWienDisplacement: () => createWienDisplacement,
  createXgcd: () => createXgcd,
  createXor: () => createXor,
  createZeros: () => createZeros
});

// node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var name = "BigNumber";
var dependencies = ["?on", "config"];
var createBigNumberClass = factory(name, dependencies, (_ref) => {
  var {
    on,
    config: config2
  } = _ref;
  var BigNumber2 = decimal_default.clone({
    precision: config2.precision,
    modulo: decimal_default.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/complex/Complex.js
var import_complex = __toESM(require_complex(), 1);
var name2 = "Complex";
var dependencies2 = [];
var createComplexClass = factory(name2, dependencies2, () => {
  Object.defineProperty(import_complex.default, "name", {
    value: "Complex"
  });
  import_complex.default.prototype.constructor = import_complex.default;
  import_complex.default.prototype.type = "Complex";
  import_complex.default.prototype.isComplex = true;
  import_complex.default.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  import_complex.default.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  import_complex.default.prototype.format = function(options) {
    var str = "";
    var im2 = this.im;
    var re2 = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re2 / im2) < epsilon) {
        re2 = 0;
      }
      if (Math.abs(im2 / re2) < epsilon) {
        im2 = 0;
      }
    }
    if (im2 === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im2 === 1) {
        str = "i";
      } else if (im2 === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im2 < 0) {
        if (im2 === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im2 === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  import_complex.default.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg2 = arguments[0];
        if (typeof arg2 === "object") {
          return (0, import_complex.default)(arg2);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi2 = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
            phi2 = phi2.toNumber("rad");
          }
          if (isNumber(phi2)) {
            return new import_complex.default({
              r,
              phi: phi2
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
  import_complex.default.fromJSON = function(json) {
    return new import_complex.default(json);
  };
  import_complex.default.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return import_complex.default;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var import_fraction = __toESM(require_fraction(), 1);
var name3 = "Fraction";
var dependencies3 = [];
var createFractionClass = factory(name3, dependencies3, () => {
  Object.defineProperty(import_fraction.default, "name", {
    value: "Fraction"
  });
  import_fraction.default.prototype.constructor = import_fraction.default;
  import_fraction.default.prototype.type = "Fraction";
  import_fraction.default.prototype.isFraction = true;
  import_fraction.default.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  import_fraction.default.fromJSON = function(json) {
    return new import_fraction.default(json);
  };
  return import_fraction.default;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name4 = "Matrix";
var dependencies4 = [];
var createMatrixClass = factory(name4, dependencies4, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index2) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index2, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size2, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size2, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name5 = "DenseMatrix";
var dependencies5 = ["Matrix"];
var createDenseMatrixClass = factory(name5, dependencies5, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone(data._data);
        this._size = clone(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  Object.defineProperty(DenseMatrix2, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix2.prototype.constructor = DenseMatrix2;
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index2);
      case 2:
      case 3:
        return _set(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    for (var x = 0; x < index2.length; x++) {
      validateIndex(index2[x], this._size[x]);
    }
    var data = this._data;
    for (var i2 = 0, ii = index2.length; i2 < ii; i2++) {
      var indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length < this._size.length) {
      throw new DimensionError(index2.length, this._size.length, "<");
    }
    var i2, ii, indexI;
    var size2 = index2.map(function(i3) {
      return i3 + 1;
    });
    _fit(this, size2, defaultValue);
    var data = this._data;
    for (i2 = 0, ii = index2.length - 1; i2 < ii; i2++) {
      indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index2[index2.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix2, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index2.isScalar();
    if (isScalar) {
      return matrix2.get(index2.min());
    } else {
      var size2 = index2.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var min2 = index2.min();
      var max2 = index2.max();
      for (var i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
        validateIndex(min2[i2], matrix2._size[i2]);
        validateIndex(max2[i2], matrix2._size[i2]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
    }
  }
  function _getSubmatrix(data, index2, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        return data[i2];
      }).valueOf();
    } else {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        var child = data[i2];
        return _getSubmatrix(child, index2, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length < matrix2._size.length) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size2 = index2.max().map(function(i3) {
        return i3 + 1;
      });
      _fit(matrix2, size2, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
    }
    return matrix2;
  }
  function _setSubmatrix(data, index2, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy ? this.clone() : this;
    return _resize(m, sizeArray, defaultValue);
  };
  function _resize(matrix2, size2, defaultValue) {
    if (size2.length === 0) {
      var v = matrix2._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix2._size = size2.slice(0);
    matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
    return matrix2;
  }
  DenseMatrix2.prototype.reshape = function(size2, copy) {
    var m = copy ? this.clone() : this;
    m._data = reshape(m._data, size2);
    var currentLength = m._size.reduce((length, size3) => length * size3);
    m._size = processSizesWildcard(size2, currentLength);
    return m;
  };
  function _fit(matrix2, size2, defaultValue) {
    var newSize = matrix2._size.slice(0);
    var changed = false;
    while (newSize.length < size2.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i2 = 0, ii = size2.length; i2 < ii; i2++) {
      if (size2[i2] > newSize[i2]) {
        newSize[i2] = size2[i2];
        changed = true;
      }
    }
    if (changed) {
      _resize(matrix2, newSize, defaultValue);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype.map = function(callback) {
    var me = this;
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index2) {
      if (isArray(value)) {
        return value.map(function(child, i2) {
          return recurse2(child, index2.concat(i2));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index2);
        } else {
          return callback(value, index2, me);
        }
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index2) {
      if (isArray(value)) {
        value.forEach(function(child, i2) {
          recurse2(child, index2.concat(i2));
        });
      } else {
        callback(value, index2, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse2(value, index2) {
      if (isArray(value)) {
        for (var i2 = 0; i2 < value.length; i2++) {
          yield* recurse2(value[i2], index2.concat(i2));
        }
      } else {
        yield {
          value,
          index: index2
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row2 of data) {
      result.push(new DenseMatrix2([row2], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i3) {
      var col = data.map((row2) => [row2[i3]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i2 = 0; i2 < s[1]; i2++) {
      _loop(i2);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options) {
    return format2(this._data, options);
  };
  DenseMatrix2.prototype.toString = function() {
    return format2(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i2 = 0; i2 < n; i2++) {
      data[i2] = this._data[i2 + kSub][i2 + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size2.length > 0) {
      data = resize(data, size2, defaultValue);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger(i2) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i2, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i2, j, data) {
    var vi = data[i2];
    data[i2] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    for (var i2 = 0, ii = data.length; i2 < ii; i2++) {
      var elem = data[i2];
      if (isArray(elem)) {
        data[i2] = preprocess(elem);
      } else if (elem && elem.isMatrix === true) {
        data[i2] = preprocess(elem.valueOf());
      }
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name6 = "isInteger";
var dependencies6 = ["typed"];
var createIsInteger = factory(name6, dependencies6, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name6, {
    number: isInteger,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function BigNumber2(x) {
      return x.isInt();
    },
    Fraction: function Fraction3(x) {
      return x.d === 1 && isFinite(x.n);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name7 = "isNegative";
var dependencies7 = ["typed"];
var createIsNegative = factory(name7, dependencies7, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name7, {
    number: isNegativeNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction3(x) {
      return x.s < 0;
    },
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name8 = "isPositive";
var dependencies8 = ["typed"];
var createIsPositive = factory(name8, dependencies8, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name8, {
    number: isPositiveNumber,
    BigNumber: function BigNumber2(x) {
      return !x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction3(x) {
      return x.s > 0 && x.n > 0;
    },
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isZero.js
var name9 = "isZero";
var dependencies9 = ["typed"];
var createIsZero = factory(name9, dependencies9, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name9, {
    number: isZeroNumber,
    BigNumber: function BigNumber2(x) {
      return x.isZero();
    },
    Complex: function Complex3(x) {
      return x.re === 0 && x.im === 0;
    },
    Fraction: function Fraction3(x) {
      return x.d === 1 && x.n === 0;
    },
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name10 = "isNaN";
var dependencies10 = ["typed"];
var createIsNaN = factory(name10, dependencies10, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name10, {
    number: isNaNNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNaN();
    },
    Fraction: function Fraction3(x) {
      return false;
    },
    Complex: function Complex3(x) {
      return x.isNaN();
    },
    Unit: function Unit2(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, Number.isNaN);
    }
  });
});

// node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name11 = "SparseMatrix";
var dependencies11 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = factory(name11, dependencies11, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix2(data, datatype) {
    if (!(this instanceof SparseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix2, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix2._values = source._values ? clone(source._values) : void 0;
      matrix2._index = clone(source._index);
      matrix2._ptr = clone(source._ptr);
      matrix2._size = clone(source._size);
      matrix2._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix2, data, datatype) {
    matrix2._values = [];
    matrix2._index = [];
    matrix2._ptr = [];
    matrix2._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed2.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix2._ptr.push(matrix2._index.length);
        for (var i2 = 0; i2 < rows; i2++) {
          var row2 = data[i2];
          if (isArray(row2)) {
            if (j === 0 && columns < row2.length) {
              columns = row2.length;
            }
            if (j < row2.length) {
              var v = row2[j];
              if (!eq(v, zero)) {
                matrix2._values.push(v);
                matrix2._index.push(i2);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row2, zero)) {
              matrix2._values.push(row2);
              matrix2._index.push(i2);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix2._ptr.push(matrix2._index.length);
    matrix2._size = [rows, columns];
  }
  SparseMatrix2.prototype = new Matrix2();
  SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  Object.defineProperty(SparseMatrix2, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix2.prototype.constructor = SparseMatrix2;
  SparseMatrix2.prototype.type = "SparseMatrix";
  SparseMatrix2.prototype.isSparseMatrix = true;
  SparseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix2.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix2.prototype.create = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index2);
      case 2:
      case 3:
        return _setsubset(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix2, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix2.get(idx.min());
    }
    var size2 = idx.size();
    if (size2.length !== matrix2._size.length) {
      throw new DimensionError(size2.length, matrix2._size.length);
    }
    var i2, ii, k, kk;
    var min2 = idx.min();
    var max2 = idx.max();
    for (i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
      validateIndex(min2[i2], matrix2._size[i2]);
      validateIndex(max2[i2], matrix2._size[i2]);
    }
    var mvalues = matrix2._values;
    var mindex = matrix2._index;
    var mptr = matrix2._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i3, r) {
      pv[i3] = r[0];
      w[i3] = true;
    });
    var values = mvalues ? [] : void 0;
    var index2 = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index2.length);
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        i2 = mindex[k];
        if (w[i2] === true) {
          index2.push(pv[i2]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index2.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: size2,
      datatype: matrix2._datatype
    });
  }
  function _setsubset(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range2 = index2.dimension(0);
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index2.dimension(0);
        var secondDimensionRange = index2.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix2;
  }
  SparseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(this._datatype)) {
      eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
      zero = typed2.convert(0, this._datatype);
    }
    if (i2 > rows - 1 || j > columns - 1) {
      _resize(this, Math.max(i2 + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i2, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      if (!eq(v, zero)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero)) {
        _insert(k, i2, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i2, top, bottom, index2) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top; r < bottom; r++) {
      if (index2[r] === i2) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index2, ptr) {
    values.splice(k, 1);
    index2.splice(k, 1);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i2, j, v, values, index2, ptr) {
    values.splice(k, 0, v);
    index2.splice(k, 0, i2);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format2(sizeArray) + ")");
      }
    });
    var m = copy ? this.clone() : this;
    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize(matrix2, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed2.convert(0, matrix2._datatype);
      value = typed2.convert(value, matrix2._datatype);
    }
    var ins = !eq(value, zero);
    var r = matrix2._size[0];
    var c = matrix2._size[1];
    var i2, j, k;
    if (columns > c) {
      for (j = c; j < columns; j++) {
        matrix2._ptr[j] = matrix2._values.length;
        if (ins) {
          for (i2 = 0; i2 < r; i2++) {
            matrix2._values.push(value);
            matrix2._index.push(i2);
          }
        }
      }
      matrix2._ptr[columns] = matrix2._values.length;
    } else if (columns < c) {
      matrix2._ptr.splice(columns + 1, c - columns);
      matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
      matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] + n;
          k = matrix2._ptr[j + 1] + n;
          var p = 0;
          for (i2 = r; i2 < rows; i2++, p++) {
            matrix2._values.splice(k + p, 0, value);
            matrix2._index.splice(k + p, 0, i2);
            n++;
          }
        }
        matrix2._ptr[c] = matrix2._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c; j++) {
        matrix2._ptr[j] = matrix2._ptr[j] - d;
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1] - d;
        for (k = k0; k < k1; k++) {
          i2 = matrix2._index[k];
          if (i2 > rows - 1) {
            matrix2._values.splice(k, 1);
            matrix2._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix2._ptr[j] = matrix2._values.length;
    }
    matrix2._size[0] = rows;
    matrix2._size[1] = columns;
    return matrix2;
  }
  SparseMatrix2.prototype.reshape = function(sizes, copy) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format2(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i2 = 0; i2 < m._ptr.length; i2++) {
      for (var j = 0; j < m._ptr[i2 + 1] - m._ptr[i2]; j++) {
        colIndex.push(i2);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0; h < values.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v = values[h];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix2.prototype.clone = function() {
    var m = new SparseMatrix2({
      values: this._values ? clone(this._values) : void 0,
      index: clone(this._index),
      ptr: clone(this._ptr),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix2.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var args = maxArgumentCount(callback);
    var invoke = function invoke2(v, i2, j) {
      if (args === 1)
        return callback(v);
      if (args === 2)
        return callback(v, [i2, j]);
      return callback(v, [i2, j], me);
    };
    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index2 = [];
    var ptr = [];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed2.convert(0, matrix2._datatype);
    }
    var invoke = function invoke2(v, x, y) {
      v = callback(v, x, y);
      if (!eq(v, zero)) {
        values.push(v);
        index2.push(x);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix2._ptr[j];
      var k1 = matrix2._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = matrix2._index[k];
          if (i2 >= minRow && i2 <= maxRow) {
            invoke(matrix2._values[k], i2 - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix2._index[_k];
          _values[_i4] = matrix2._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = this._index[k];
          callback(this._values[k], [i2, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix2.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        yield {
          value: this._values[k],
          index: [i2, j]
        };
      }
    }
  };
  SparseMatrix2.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix2.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index2, ptr, size2, copy) {
    var rows = size2[0];
    var columns = size2[1];
    var a = [];
    var i2, j;
    for (i2 = 0; i2 < rows; i2++) {
      a[i2] = [];
      for (j = 0; j < columns; j++) {
        a[i2][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        i2 = index2[k];
        a[i2][j] = values ? copy ? clone(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix2.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format2(rows, options) + " x " + format2(columns, options) + "] density: " + format2(density, options) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        str += "\n    (" + format2(i2, options) + ", " + format2(j, options) + ") ==> " + (this._values ? format2(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix2.prototype.toString = function() {
    return format2(this.toArray());
  };
  SparseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index2 = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0; x < k1; x++) {
        var i2 = this._index[x];
        if (i2 === j - kSuper + kSub) {
          values.push(this._values[x]);
          index2[values.length - 1] = i2 - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix2.fromJSON = function(json) {
    return new SparseMatrix2(json);
  };
  SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed2.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i3) {
        return value[i3];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i3) {
        return value.get([i3]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values = [];
    var index2 = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values.length);
      var i2 = j - kSuper;
      if (i2 >= 0 && i2 < n) {
        var v = _value(i2);
        if (!eq(v, zero)) {
          index2.push(i2 + kSub);
          values.push(v);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger(i2) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix2._swapRows(i2, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix2._forEachRow = function(j, values, index2, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0; k < k1; k++) {
      callback(index2[k], values[k]);
    }
  };
  SparseMatrix2._swapRows = function(x, y, columns, values, index2, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index2);
      var ky = _getValueIndex(y, k0, k1, index2);
      if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y) {
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y)) {
        var vx = values ? values[kx] : void 0;
        index2.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx);
        }
        index2.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index2[ky] === y && (kx >= k1 || index2[kx] !== x)) {
        var vy = values ? values[ky] : void 0;
        index2.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy);
        }
        index2.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name12 = "bignumber";
var dependencies12 = ["typed", "BigNumber"];
var createBignumber = factory(name12, dependencies12, (_ref) => {
  var {
    typed: typed2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number2(x) {
      return new BigNumber2(x + "");
    },
    string: function string2(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size2 = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size2));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x);
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Fraction: function Fraction3(x) {
      return new BigNumber2(x.n).div(x.d).times(x.s);
    },
    null: function _null2(x) {
      return new BigNumber2(0);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name13 = "complex";
var dependencies13 = ["typed", "Complex"];
var createComplex = factory(name13, dependencies13, (_ref) => {
  var {
    typed: typed2,
    Complex: Complex3
  } = _ref;
  return typed2("complex", {
    "": function _() {
      return Complex3.ZERO;
    },
    number: function number2(x) {
      return new Complex3(x, 0);
    },
    "number, number": function numberNumber(re2, im2) {
      return new Complex3(re2, im2);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
      return new Complex3(re2.toNumber(), im2.toNumber());
    },
    Fraction: function Fraction3(x) {
      return new Complex3(x.valueOf(), 0);
    },
    Complex: function Complex4(x) {
      return x.clone();
    },
    string: function string2(x) {
      return Complex3(x);
    },
    null: function _null2(x) {
      return Complex3(0);
    },
    Object: function Object2(x) {
      if ("re" in x && "im" in x) {
        return new Complex3(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex3(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name14 = "fraction";
var dependencies14 = ["typed", "Fraction"];
var createFraction = factory(name14, dependencies14, (_ref) => {
  var {
    typed: typed2,
    Fraction: Fraction3
  } = _ref;
  return typed2("fraction", {
    number: function number2(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction3(x);
    },
    string: function string2(x) {
      return new Fraction3(x);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction3(numerator, denominator);
    },
    null: function _null2(x) {
      return new Fraction3(0);
    },
    BigNumber: function BigNumber2(x) {
      return new Fraction3(x.toString());
    },
    Fraction: function Fraction4(x) {
      return x;
    },
    Object: function Object2(x) {
      return new Fraction3(x);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name15 = "matrix";
var dependencies15 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = factory(name15, dependencies15, (_ref) => {
  var {
    typed: typed2,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name15, {
    "": function _() {
      return _create([]);
    },
    string: function string2(format4) {
      return _create([], format4);
    },
    "string, string": function stringString(format4, datatype) {
      return _create([], format4, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format4, datatype) {
    if (format4 === "dense" || format4 === "default" || format4 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format4 === "sparse") {
      return new SparseMatrix2(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name16 = "matrixFromFunction";
var dependencies16 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = factory(name16, dependencies16, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isZero: isZero2
  } = _ref;
  return typed2(name16, {
    "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format4, datatype) {
      return _create(size2, fn, format4, datatype);
    },
    "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format4) {
      return _create(size2, fn, format4);
    },
    "Matrix, function": function MatrixFunction(size2, fn) {
      return _create(size2, fn, "dense");
    },
    "Array, function": function ArrayFunction(size2, fn) {
      return _create(size2, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format4, fn) {
      return _create(size2, fn, format4);
    },
    "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format4, datatype, fn) {
      return _create(size2, fn, format4, datatype);
    }
  });
  function _create(size2, fn, format4, datatype) {
    var m;
    if (datatype !== void 0) {
      m = matrix2(format4, datatype);
    } else {
      m = matrix2(format4);
    }
    m.resize(size2);
    m.forEach(function(_, index2) {
      var val = fn(index2);
      if (isZero2(val))
        return;
      m.set(index2, val);
    });
    return m;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name17 = "matrixFromRows";
var dependencies17 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = factory(name17, dependencies17, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten3,
    size: size2
  } = _ref;
  return typed2(name17, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row2 of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row2);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " ≠ " + (rowLength | 0));
      }
      result.push(flatten3(row2));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name18 = "matrixFromColumns";
var dependencies18 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = factory(name18, dependencies18, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten3,
    size: size2
  } = _ref;
  return typed2(name18, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i2 = 0; i2 < N; i2++) {
      result[i2] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " ≠ " + (colLength | 0));
      }
      var f = flatten3(col);
      for (var _i = 0; _i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name19 = "splitUnit";
var dependencies19 = ["typed"];
var createSplitUnit = factory(name19, dependencies19, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name19, {
    "Unit, Array": function UnitArray(unit2, parts) {
      return unit2.splitUnit(parts);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name20 = "unaryMinus";
var dependencies20 = ["typed"];
var createUnaryMinus = factory(name20, dependencies20, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name20, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    Unit: typed2.referToSelf((self) => (x) => {
      var res = x.clone();
      res.value = typed2.find(self, res.valueType())(x.value);
      return res;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true))
    // TODO: add support for string
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name21 = "unaryPlus";
var dependencies21 = ["typed", "config", "BigNumber"];
var createUnaryPlus = factory(name21, dependencies21, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name21, {
    number: unaryPlusNumber,
    Complex: function Complex3(x) {
      return x;
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Fraction: function Fraction3(x) {
      return x;
    },
    Unit: function Unit2(x) {
      return x.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true)),
    "boolean | string": function booleanString(x) {
      return config2.number === "BigNumber" ? new BigNumber2(+x) : +x;
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name22 = "abs";
var dependencies22 = ["typed"];
var createAbs = factory(name22, dependencies22, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name22, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true))
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name23 = "addScalar";
var dependencies23 = ["typed"];
var createAddScalar = factory(name23, dependencies23, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name23, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.plus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name24 = "cbrt";
var dependencies24 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = factory(name24, dependencies24, (_ref) => {
  var {
    config: config2,
    typed: typed2,
    isNegative: isNegative2,
    unaryMinus: unaryMinus2,
    matrix: matrix2,
    Complex: Complex3,
    BigNumber: BigNumber2,
    Fraction: Fraction3
  } = _ref;
  return typed2(name24, {
    number: cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber3(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs2 = x.abs();
    var principal = new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3).exp());
    if (allRoots) {
      var all2 = [principal, new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
      return config2.matrix === "Array" ? all2 : matrix2(all2);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative2(x.value);
      if (negate) {
        x.value = unaryMinus2(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber2(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction3(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus2(_result.value);
      }
      return _result;
    }
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name25 = "cube";
var dependencies25 = ["typed"];
var createCube = factory(name25, dependencies25, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name25, {
    number: cubeNumber,
    Complex: function Complex3(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x).times(x);
    },
    Fraction: function Fraction3(x) {
      return x.pow(3);
    },
    Unit: function Unit2(x) {
      return x.pow(3);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name26 = "exp";
var dependencies26 = ["typed"];
var createExp = factory(name26, dependencies26, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name26, {
    number: expNumber,
    Complex: function Complex3(x) {
      return x.exp();
    },
    BigNumber: function BigNumber2(x) {
      return x.exp();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name27 = "expm1";
var dependencies27 = ["typed", "Complex"];
var createExpm1 = factory(name27, dependencies27, (_ref) => {
  var {
    typed: typed2,
    Complex: _Complex
  } = _ref;
  return typed2(name27, {
    number: expm1Number,
    Complex: function Complex3(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber2(x) {
      return x.exp().minus(1);
    }
  });
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
var name28 = "matAlgo01xDSid";
var dependencies28 = ["typed"];
var createMatAlgo01xDSid = factory(name28, dependencies28, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
    var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var x = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (i2 = 0; i2 < rows; i2++) {
        if (w[i2] === mark) {
          cdata[i2][j] = x[i2];
        } else {
          cdata[i2][j] = adata[i2][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
var name29 = "matAlgo04xSidSid";
var dependencies29 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = factory(name29, dependencies29, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : void 0;
    var xb = avalues && bvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] === mark) {
          if (xa) {
            var v = cf(xa[i2], bvalues[k]);
            if (!eq(v, zero)) {
              xa[i2] = v;
            } else {
              wa[i2] = null;
            }
          }
        } else {
          cindex.push(i2);
          wb[i2] = mark;
          if (xb) {
            xb[i2] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          if (wa[i2] === mark) {
            cvalues[k] = xa[i2];
            k++;
          } else if (wb[i2] === mark) {
            cvalues[k] = xb[i2];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
var name30 = "matAlgo10xSids";
var dependencies30 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = factory(name30, dependencies30, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var name31 = "gcd";
var dependencies31 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
var createGcd = factory(name31, dependencies31, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
  var gcdManySignature = {};
  gcdManySignature["".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes)] = typed2.referToSelf((self) => (a, b, args) => {
    var res = self(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self(res, args[i2]);
    }
    return res;
  });
  return typed2(name31, {
    "number, number": gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), gcdManySignature);
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero = new BigNumber2(0);
    while (!b.isZero()) {
      var r = a.mod(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
var name32 = "matAlgo02xDS0";
var dependencies32 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = factory(name32, dependencies32, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        if (!eq(cij, zero)) {
          cindex.push(i2);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
var name33 = "matAlgo06xS0S0";
var dependencies33 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = factory(name33, dependencies33, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var u = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i2 = cindex[k];
          if (u[i2] === mark) {
            var v = x[i2];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name34 = "lcm";
var dependencies34 = ["typed", "matrix", "equalScalar"];
var createLcm = factory(name34, dependencies34, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed2.referToSelf((self) => (a, b, args) => {
    var res = self(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self(res, args[i2]);
    }
    return res;
  });
  return typed2(name34, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod2 = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod2.div(a).abs();
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name35 = "log10";
var dependencies35 = ["typed", "config", "Complex"];
var createLog10 = factory(name35, dependencies35, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: _Complex
  } = _ref;
  return typed2(name35, {
    number: function number2(x) {
      if (x >= 0 || config2.predictable) {
        return log10Number(x);
      } else {
        return new _Complex(x, 0).log().div(Math.LN10);
      }
    },
    Complex: function Complex3(x) {
      return new _Complex(x).log().div(Math.LN10);
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.log();
      } else {
        return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name36 = "log2";
var dependencies36 = ["typed", "config", "Complex"];
var createLog2 = factory(name36, dependencies36, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name36, {
    number: function number2(x) {
      if (x >= 0 || config2.predictable) {
        return log2Number(x);
      } else {
        return _log2Complex(new Complex3(x, 0));
      }
    },
    Complex: _log2Complex,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.log(2);
      } else {
        return _log2Complex(new Complex3(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name37 = "mod";
var dependencies37 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createMod = factory(name37, dependencies37, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name37, {
    "number, number": modNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isNeg()) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return y.isZero() ? x : x.mod(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      if (y.compare(0) < 0) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name38 = "multiplyScalar";
var dependencies38 = ["typed"];
var createMultiplyScalar = factory(name38, dependencies38, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.times(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name39 = "multiply";
var dependencies39 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = factory(name39, dependencies39, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    equalScalar: equalScalar2,
    dot: dot2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot2(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i2 = 1; i2 < alength; i2++) {
        sum2 = af(sum2, mf(adata[i2], bdata[i2][j]));
      }
      c[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: dt
    });
  }
  var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      var sum2 = mf(row2[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum2 = af(sum2, mf(row2[j], bdata[j]));
      }
      c[i2] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      c[i2] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(row2[0], bdata[0][j]);
        for (var x = 1; x < acolumns; x++) {
          sum2 = af(sum2, mf(row2[x], bdata[x][j]));
        }
        c[i2][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i2 = 0; i2 < arows; i2++) {
          var mark = i2 + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i2][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i2][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero)) {
            cindex.push(i2);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = values ? [] : void 0;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed2(name39, multiplyScalar2, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": typed2.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix2(x), matrix2(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed2.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix2(y))),
    "Array, Matrix": typed2.referToSelf((self) => (x, y) => {
      return self(matrix2(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, multiplyScalar2, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, multiplyScalar2, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return matAlgo11xS0s(y, x, multiplyScalar2, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return matAlgo14xDs(y, x, multiplyScalar2, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
    },
    "any, any": multiplyScalar2,
    "any, any, ...any": typed2.referToSelf((self) => (x, y, rest) => {
      var result = self(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self(result, rest[i2]);
      }
      return result;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name40 = "nthRoot";
var dependencies40 = ["typed", "matrix", "equalScalar", "BigNumber"];
var createNthRoot = factory(name40, dependencies40, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: _BigNumber
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed2(name40, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix2(x), 2).valueOf()),
    DenseMatrix: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed2.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S0(x, y, self);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid(x, y, self, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed2.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix2(x), y)),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s(y, x, self, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero = new _BigNumber(0);
    var one = new Big(1);
    var inv2 = root.isNegative();
    if (inv2) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv2 ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv2 ? zero : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
  }
});
var createNthRootNumber = factory(name40, ["typed"], (_ref2) => {
  var {
    typed: typed2
  } = _ref2;
  return typed2(name40, {
    number: nthRootNumber,
    "number, number": nthRootNumber
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name41 = "sign";
var dependencies41 = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = factory(name41, dependencies41, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber,
    complex: complex2,
    Fraction: _Fraction
  } = _ref;
  return typed2(name41, {
    number: signNumber,
    Complex: function Complex3(x) {
      return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x.cmp(0));
    },
    Fraction: function Fraction3(x) {
      return new _Fraction(x.s, 1);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true)),
    Unit: typed2.referToSelf((self) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed2.find(self, x.valueType())(x.value);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name42 = "sqrt";
var dependencies42 = ["config", "typed", "Complex"];
var createSqrt = factory(name42, dependencies42, (_ref) => {
  var {
    config: config2,
    typed: typed2,
    Complex: Complex3
  } = _ref;
  return typed2("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex4(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit2(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config2.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex3(x, 0).sqrt();
    }
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name43 = "square";
var dependencies43 = ["typed"];
var createSquare = factory(name43, dependencies43, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name43, {
    number: squareNumber,
    Complex: function Complex3(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x);
    },
    Fraction: function Fraction3(x) {
      return x.mul(x);
    },
    Unit: function Unit2(x) {
      return x.pow(2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
var name44 = "subtract";
var dependencies44 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
var createSubtract = factory(name44, dependencies44, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name44, {
    "number, number": (x, y) => x - y,
    "Complex, Complex": (x, y) => x.sub(y),
    "BigNumber, BigNumber": (x, y) => x.minus(y),
    "Fraction, Fraction": (x, y) => x.sub(y),
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
      if (x.value === null) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y)) {
        throw new Error("Units do not match");
      }
      var res = x.clone();
      res.value = typed2.find(self, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name45 = "xgcd";
var dependencies45 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = factory(name45, dependencies45, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name45, {
    "number, number": function numberNumber(a, b) {
      var res = xgcdNumber(a, b);
      return config2.matrix === "Array" ? res : matrix2(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
    // TODO: implement support for Fraction
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero = new BigNumber2(0);
    var one = new BigNumber2(1);
    var x = zero;
    var lastx = one;
    var y = one;
    var lasty = zero;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config2.matrix === "Array" ? res : matrix2(res);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name46 = "invmod";
var dependencies46 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = factory(name46, dependencies46, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    BigNumber: BigNumber2,
    xgcd: xgcd2,
    equal: equal2,
    smaller: smaller2,
    mod: mod2,
    add: add2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name46, {
    "number, number": invmod2,
    "BigNumber, BigNumber": invmod2
  });
  function invmod2(a, b) {
    if (!isInteger3(a) || !isInteger3(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a = mod2(a, b);
    if (equal2(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd2(a, b);
    res = res.valueOf();
    var [gcd2, inv2] = res;
    if (!equal2(gcd2, BigNumber2(1)))
      return NaN;
    inv2 = mod2(inv2, b);
    if (smaller2(inv2, BigNumber2(0)))
      inv2 = add2(inv2, b);
    return inv2;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
var name47 = "matAlgo09xS0Sf";
var dependencies47 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = factory(name47, dependencies47, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i2 = bindex[k];
          w[i2] = mark;
          x[i2] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        if (x) {
          var vb = w[i2] === mark ? x[i2] : zero;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero)) {
            cindex.push(i2);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i2);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name48 = "dotMultiply";
var dependencies48 = ["typed", "matrix", "equalScalar", "multiplyScalar"];
var createDotMultiply = factory(name48, dependencies48, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name48, matrixAlgorithmSuite({
    elop: multiplyScalar2,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber2(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber2(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber2(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber2 = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i2 = 0; i2 < xBits.length; ++i2) {
      xBits[i2] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i2 = 1; i2 < a.length; ++i2) {
    var s = a[i2] + "";
    for (var z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber2(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber2(2).pow(y)).floor();
}

// node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name49 = "bitAnd";
var dependencies49 = ["typed", "matrix", "equalScalar"];
var createBitAnd = factory(name49, dependencies49, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name49, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name50 = "bitNot";
var dependencies50 = ["typed"];
var createBitNot = factory(name50, dependencies50, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name50, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name51 = "bitOr";
var dependencies51 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createBitOr = factory(name51, dependencies51, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name51, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name52 = "bitXor";
var dependencies52 = ["typed", "matrix", "DenseMatrix"];
var createBitXor = factory(name52, dependencies52, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name52, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/complex/arg.js
var name53 = "arg";
var dependencies53 = ["typed"];
var createArg = factory(name53, dependencies53, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name53, {
    number: function number2(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber2(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex3(x) {
      return x.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/complex/conj.js
var name54 = "conj";
var dependencies54 = ["typed"];
var createConj = factory(name54, dependencies54, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name54, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/complex/im.js
var name55 = "im";
var dependencies55 = ["typed"];
var createIm = factory(name55, dependencies55, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name55, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/complex/re.js
var name56 = "re";
var dependencies56 = ["typed"];
var createRe = factory(name56, dependencies56, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name56, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/logical/not.js
var name57 = "not";
var dependencies57 = ["typed"];
var createNot = factory(name57, dependencies57, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name57, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex3(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber2(x) {
      return x.isZero() || x.isNaN();
    },
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/logical/or.js
var name58 = "or";
var dependencies58 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createOr = factory(name58, dependencies58, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name58, {
    "number, number": orNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => self(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/logical/xor.js
var name59 = "xor";
var dependencies59 = ["typed", "matrix", "DenseMatrix"];
var createXor = factory(name59, dependencies59, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name59, {
    "number, number": xorNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => self(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/matrix/concat.js
var name60 = "concat";
var dependencies60 = ["typed", "matrix", "isInteger"];
var createConcat = factory(name60, dependencies60, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name60, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
      var i2;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i2 = 0; i2 < len; i2++) {
        var arg2 = args[i2];
        if (isMatrix(arg2)) {
          asMatrix = true;
        }
        if (isNumber(arg2) || isBigNumber(arg2)) {
          if (i2 !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg2.valueOf();
          if (!isInteger3(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i2 > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone(arg2).valueOf();
          var size2 = arraySize(m);
          matrices[i2] = m;
          prevDim = dim;
          dim = size2.length - 1;
          if (i2 > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = _concat(res, matrices.shift(), dim, 0);
      }
      return asMatrix ? matrix2(res) : res;
    },
    "...string": function string2(args) {
      return args.join("");
    }
  });
});
function _concat(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i2 = 0; i2 < a.length; i2++) {
      c[i2] = _concat(a[i2], b[i2], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
}

// node_modules/mathjs/lib/esm/function/matrix/column.js
var name61 = "column";
var dependencies61 = ["typed", "Index", "matrix", "range"];
var createColumn = factory(name61, dependencies61, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name61, {
    "Matrix, number": _column,
    "Array, number": function ArrayNumber(value, column2) {
      return _column(matrix2(clone(value)), column2).valueOf();
    }
  });
  function _column(value, column2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column2, value.size()[1]);
    var rowRange = range2(0, value.size()[0]);
    var index2 = new Index2(rowRange, column2);
    return value.subset(index2);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/count.js
var name62 = "count";
var dependencies62 = ["typed", "size", "prod"];
var createCount = factory(name62, dependencies62, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    prod: prod2
  } = _ref;
  return typed2(name62, {
    string: function string2(x) {
      return x.length;
    },
    "Matrix | Array": function MatrixArray(x) {
      return prod2(size2(x));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/cross.js
var name63 = "cross";
var dependencies63 = ["typed", "matrix", "subtract", "multiply"];
var createCross = factory(name63, dependencies63, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2
  } = _ref;
  return typed2(name63, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_cross(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze(x);
    y = squeeze(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product];
    } else {
      return product;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diag.js
var name64 = "diag";
var dependencies64 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = factory(name64, dependencies64, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name64, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function Array2(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function ArrayNumber(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function ArrayBigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function ArrayString(x, format4) {
      return _diag(x, 0, arraySize(x), format4);
    },
    "Array, number, string": function ArrayNumberString(x, k, format4) {
      return _diag(x, k, arraySize(x), format4);
    },
    "Array, BigNumber, string": function ArrayBigNumberString(x, k, format4) {
      return _diag(x, k.toNumber(), arraySize(x), format4);
    },
    Matrix: function Matrix2(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function MatrixNumber(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function MatrixBigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function MatrixString(x, format4) {
      return _diag(x, 0, x.size(), format4);
    },
    "Matrix, number, string": function MatrixNumberString(x, k, format4) {
      return _diag(x, k, x.size(), format4);
    },
    "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format4) {
      return _diag(x, k.toNumber(), x.size(), format4);
    }
  });
  function _diag(x, k, size2, format4) {
    if (!isInteger(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size2.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format4, size2[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format4, size2, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format4 && format4 !== "sparse" && format4 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format4, '"'));
    }
    var m = format4 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
    return format4 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format4, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format4 !== null) {
        if (format4 !== dm.storage()) {
          return matrix2(dm, format4);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i2 = 0; i2 < n; i2++) {
      vector[i2] = x[i2 + kSub][i2 + kSuper];
    }
    return format4 !== null ? matrix2(vector) : vector;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name65 = "flatten";
var dependencies65 = ["typed", "matrix"];
var createFlatten = factory(name65, dependencies65, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name65, {
    Array: function Array2(x) {
      return flatten(x);
    },
    Matrix: function Matrix2(x) {
      var flat = flatten(x.toArray());
      return matrix2(flat);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name66 = "getMatrixDataType";
var dependencies66 = ["typed"];
var createGetMatrixDataType = factory(name66, dependencies66, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name66, {
    Array: function Array2(x) {
      return getArrayDataType(x, typeOf);
    },
    Matrix: function Matrix2(x) {
      return x.getDataType();
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/identity.js
var name67 = "identity";
var dependencies67 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = factory(name67, dependencies67, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name67, {
    "": function _() {
      return config2.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format4) {
      return matrix2(format4);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config2.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format4) {
      return _identity(rows, rows, format4);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config2.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format4) {
      return _identity(rows, cols, format4);
    },
    Array: function Array2(size2) {
      return _identityVector(size2);
    },
    "Array, string": function ArrayString(size2, format4) {
      return _identityVector(size2, format4);
    },
    Matrix: function Matrix2(size2) {
      return _identityVector(size2.valueOf(), size2.storage());
    },
    "Matrix, string": function MatrixString(size2, format4) {
      return _identityVector(size2.valueOf(), format4);
    }
  });
  function _identityVector(size2, format4) {
    switch (size2.length) {
      case 0:
        return format4 ? matrix2(format4) : [];
      case 1:
        return _identity(size2[0], size2[0], format4);
      case 2:
        return _identity(size2[0], size2[1], format4);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format4) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber2(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size2 = [rows, cols];
    if (format4) {
      if (format4 === "sparse") {
        return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      if (format4 === "dense") {
        return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
    }
    var res = resize([], size2, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/kron.js
var name68 = "kron";
var dependencies68 = ["typed", "matrix", "multiplyScalar"];
var createKron = factory(name68, dependencies68, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  return typed2(name68, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_kron(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar2(y, x));
          });
        });
      });
    }) && t;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diff.js
var name69 = "diff";
var dependencies69 = ["typed", "matrix", "subtract", "number"];
var createDiff = factory(name69, dependencies69, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2
  } = _ref;
  return typed2(name69, {
    "Array | Matrix": function ArrayMatrix(arr) {
      if (isMatrix(arr)) {
        return matrix2(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
      if (!isInteger(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix2(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed2.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
    "Matrix, BigNumber": typed2.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size2 = arr.length;
    for (var i2 = 1; i2 < size2; i2++) {
      result.push(_ElementDiff(arr[i2 - 1], arr[i2]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract2(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size2 = arr1.length;
    for (var i2 = 0; i2 < size2; i2++) {
      result.push(_ElementDiff(arr1[i2], arr2[i2]));
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ones.js
var name70 = "ones";
var dependencies70 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = factory(name70, dependencies70, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("ones", {
    "": function _() {
      return config2.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format4 = size2.pop();
        return _ones(size2, format4);
      } else if (config2.matrix === "Array") {
        return _ones(size2);
      } else {
        return _ones(size2, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix2(size2) {
      var format4 = size2.storage();
      return _ones(size2.valueOf(), format4);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format4) {
      return _ones(size2.valueOf(), format4);
    }
  });
  function _ones(size2, format4) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
    _validate(size2);
    if (format4) {
      var m = matrix2(format4);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name71 = "reshape";
var dependencies71 = ["typed", "isInteger", "matrix"];
var createReshape = factory(name71, dependencies71, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name71, {
    "Matrix, Array": function MatrixArray(x, sizes) {
      return x.reshape(sizes, true);
    },
    "Array, Array": function ArrayArray(x, sizes) {
      sizes.forEach(function(size2) {
        if (!isInteger3(size2)) {
          throw new TypeError("Invalid size for dimension: " + size2);
        }
      });
      return reshape(x, sizes);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/resize.js
var name72 = "resize";
var dependencies72 = ["config", "matrix"];
var createResize = factory(name72, dependencies72, (_ref) => {
  var {
    config: config2,
    matrix: matrix2
  } = _ref;
  return function resize3(x, size2, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size2)) {
      size2 = size2.valueOf();
    }
    if (isBigNumber(size2[0])) {
      size2 = size2.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size2, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size2, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config2.matrix !== "Array";
    if (size2.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);
      var res = resize(x, size2, defaultValue);
      return asMatrix ? matrix2(res) : res;
    }
  };
  function _resizeString(str, size2, defaultChar) {
    if (defaultChar !== void 0) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size2.length !== 1) {
      throw new DimensionError(size2.length, 1);
    }
    var len = size2[0];
    if (typeof len !== "number" || !isInteger(len)) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format2(size2) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i2 = 0, ii = len - str.length; i2 < ii; i2++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name73 = "rotate";
var dependencies73 = ["typed", "multiply", "rotationMatrix"];
var createRotate = factory(name73, dependencies73, (_ref) => {
  var {
    typed: typed2,
    multiply: multiply2,
    rotationMatrix: rotationMatrix2
  } = _ref;
  return typed2(name73, {
    "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply2(rotationMatrix2(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      return multiply2(rotationMatrix2(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply2(rotationMatrix2(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply2(rotationMatrix2(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name74 = "rotationMatrix";
var dependencies74 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = factory(name74, dependencies74, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    multiplyScalar: multiplyScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    norm: norm2,
    BigNumber: BigNumber2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    cos: cos2,
    sin: sin2
  } = _ref;
  return typed2(name74, {
    "": function _() {
      return config2.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format4) {
      return matrix2(format4);
    },
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
      return _rotationMatrix2x2(theta, config2.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format4) {
      return _rotationMatrix2x2(theta, format4);
    },
    "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config2.matrix === "Matrix" ? "dense" : void 0);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format4) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format4);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format4) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format4);
    }
  });
  function _rotationMatrix2x2(theta, format4) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber2(-1) : -1;
    var cosTheta = cos2(theta);
    var sinTheta = sin2(theta);
    var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format4);
  }
  function _validateVector(v) {
    var size2 = v.size();
    if (size2.length < 1 || size2[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array) {
    return array.reduce((p, curr) => multiplyScalar2(p, curr));
  }
  function _convertToFormat(data, format4) {
    if (format4) {
      if (format4 === "sparse") {
        return new SparseMatrix2(data);
      }
      if (format4 === "dense") {
        return new DenseMatrix2(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format4) {
    var normV = norm2(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber2 : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos2(theta);
    var oneMinusC = addScalar2(one, unaryMinus2(c));
    var s = sin2(theta);
    var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format4);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/row.js
var name75 = "row";
var dependencies75 = ["typed", "Index", "matrix", "range"];
var createRow = factory(name75, dependencies75, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name75, {
    "Matrix, number": _row,
    "Array, number": function ArrayNumber(value, row2) {
      return _row(matrix2(clone(value)), row2).valueOf();
    }
  });
  function _row(value, row2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row2, value.size()[0]);
    var columnRange = range2(0, value.size()[1]);
    var index2 = new Index2(row2, columnRange);
    return value.subset(index2);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name76 = "squeeze";
var dependencies76 = ["typed", "matrix"];
var createSqueeze = factory(name76, dependencies76, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name76, {
    Array: function Array2(x) {
      return squeeze(clone(x));
    },
    Matrix: function Matrix2(x) {
      var res = squeeze(x.toArray());
      return Array.isArray(res) ? matrix2(res) : res;
    },
    any: function any(x) {
      return clone(x);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/subset.js
var name77 = "subset";
var dependencies77 = ["typed", "matrix"];
var createSubset = factory(name77, dependencies77, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name77, {
    // get subset
    "Array, Index": function ArrayIndex(value, index2) {
      var m = matrix2(value);
      var subset2 = m.subset(index2);
      return index2.isScalar() ? subset2 : subset2.valueOf();
    },
    "Matrix, Index": function MatrixIndex(value, index2) {
      return value.subset(index2);
    },
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    // set subset
    "Array, Index, any": function ArrayIndexAny(value, index2, replacement) {
      return matrix2(clone(value)).subset(index2, replacement, void 0).valueOf();
    },
    "Array, Index, any, any": function ArrayIndexAnyAny(value, index2, replacement, defaultValue) {
      return matrix2(clone(value)).subset(index2, replacement, defaultValue).valueOf();
    },
    "Matrix, Index, any": function MatrixIndexAny(value, index2, replacement) {
      return value.clone().subset(index2, replacement);
    },
    "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
      return value.clone().subset(index2, replacement, defaultValue);
    },
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
});
function _getSubstring(str, index2) {
  if (!isIndex(index2)) {
    throw new TypeError("Index expected");
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0], strLen);
  validateIndex(index2.max()[0], strLen);
  var range2 = index2.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index2, replacement, defaultValue) {
  if (!index2 || index2.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index2.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0]);
  validateIndex(index2.max()[0]);
  var chars = [];
  for (var i2 = 0; i2 < strLen; i2++) {
    chars[i2] = str.charAt(i2);
  }
  range2.forEach(function(v, i3) {
    chars[v] = replacement.charAt(i3[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index2) {
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index2, replacement) {
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}

// node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name78 = "transpose";
var dependencies78 = ["typed", "matrix"];
var createTranspose = factory(name78, dependencies78, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name78, {
    Array: (x) => transposeMatrix(matrix2(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone
    // scalars
  });
  function transposeMatrix(x) {
    var size2 = x.size();
    var c;
    switch (size2.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size2[0];
          var columns = size2[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format2(size2) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format2(size2) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0; j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i2 = 0; i2 < rows; i2++) {
        transposedRow[i2] = clone(data[i2][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0; x < rows; x++) {
      w[x] = 0;
    }
    var p, l, j;
    for (p = 0, l = index2.length; p < l; p++) {
      w[index2[p]]++;
    }
    var sum2 = 0;
    for (var i2 = 0; i2 < rows; i2++) {
      cptr.push(sum2);
      sum2 += w[i2];
      w[i2] = cptr[i2];
    }
    cptr.push(sum2);
    for (j = 0; j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        var q = w[index2[k]]++;
        cindex[q] = j;
        if (values) {
          cvalues[q] = clone(values[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name79 = "ctranspose";
var dependencies79 = ["typed", "transpose", "conj"];
var createCtranspose = factory(name79, dependencies79, (_ref) => {
  var {
    typed: typed2,
    transpose: transpose2,
    conj: conj2
  } = _ref;
  return typed2(name79, {
    any: function any(x) {
      return conj2(transpose2(x));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name80 = "zeros";
var dependencies80 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = factory(name80, dependencies80, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name80, {
    "": function _() {
      return config2.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format4 = size2.pop();
        return _zeros(size2, format4);
      } else if (config2.matrix === "Array") {
        return _zeros(size2);
      } else {
        return _zeros(size2, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix2(size2) {
      var format4 = size2.storage();
      return _zeros(size2.valueOf(), format4);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format4) {
      return _zeros(size2.valueOf(), format4);
    }
  });
  function _zeros(size2, format4) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
    _validate(size2);
    if (format4) {
      var m = matrix2(format4);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/fft.js
var name81 = "fft";
var dependencies81 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i"];
var createFft = factory(name81, dependencies81, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    exp: exp2,
    tau: tau2,
    i: I
  } = _ref;
  return typed2(name81, {
    Array: _ndFft,
    Matrix: function Matrix2(matrix3) {
      return matrix3.create(_ndFft(matrix3.toArray()));
    }
  });
  function _ndFft(arr) {
    var size2 = arraySize(arr);
    if (size2.length === 1)
      return _fft(arr, size2[0]);
    return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size2 = arraySize(arr);
    if (dim !== 0)
      return new Array(size2[0]).fill(0).map((_, i2) => _1dFft(arr[i2], dim - 1));
    if (size2.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size3 = arraySize(arr2);
      return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i2) => arr2[i2][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i2) => i2 % 2 === 0), len / 2), ..._fft(arr.filter((_, i2) => i2 % 2 === 1), len / 2)];
      for (var k = 0; k < len / 2; k++) {
        var p = ret[k];
        var q = multiplyScalar2(ret[k + len / 2], exp2(multiplyScalar2(multiplyScalar2(tau2, I), divideScalar2(-k, len))));
        ret[k] = addScalar2(p, q);
        ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
      }
      return ret;
    }
    throw new Error("Can only calculate FFT of power-of-two size");
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name82 = "ifft";
var dependencies82 = ["typed", "fft", "dotDivide", "conj"];
var createIfft = factory(name82, dependencies82, (_ref) => {
  var {
    typed: typed2,
    fft: fft2,
    dotDivide: dotDivide2,
    conj: conj2
  } = _ref;
  return typed2(name82, {
    "Array | Matrix": function ArrayMatrix(arr) {
      var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/bin.js
var name83 = "bin";
var dependencies83 = ["typed", "format"];
var createBin = factory(name83, dependencies83, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name83, {
    "number | BigNumber": function numberBigNumber(n) {
      return format4(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format4(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/oct.js
var name84 = "oct";
var dependencies84 = ["typed", "format"];
var createOct = factory(name84, dependencies84, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name84, {
    "number | BigNumber": function numberBigNumber(n) {
      return format4(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format4(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/hex.js
var name85 = "hex";
var dependencies85 = ["typed", "format"];
var createHex = factory(name85, dependencies85, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name85, {
    "number | BigNumber": function numberBigNumber(n) {
      return format4(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format4(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/unit/to.js
var name86 = "to";
var dependencies86 = ["typed", "matrix"];
var createTo = factory(name86, dependencies86, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name86, {
    "Unit, Unit | string": (x, unit2) => x.to(unit2)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name87 = "divideScalar";
var dependencies87 = ["typed", "numeric"];
var createDivideScalar = factory(name87, dependencies87, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric2
  } = _ref;
  return typed2(name87, {
    "number, number": function numberNumber(x, y) {
      return x / y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.div(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name88 = "pow";
var dependencies88 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = factory(name88, dependencies88, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    identity: identity2,
    multiply: multiply2,
    matrix: matrix2,
    inv: inv2,
    number: number2,
    fraction: fraction2,
    Complex: Complex3
  } = _ref;
  return typed2(name88, {
    "number, number": _pow,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config2.predictable) {
        return x.pow(y);
      } else {
        return new Complex3(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config2.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function ArrayBigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function MatrixBigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config2.predictable && !isInteger(y) && x < 0) {
      try {
        var yFrac = fraction2(y);
        var yNum = number2(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if (yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config2.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger(y) || x >= 0 || config2.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex3(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv2(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity2(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply2(px, res);
      }
      y >>= 1;
      px = multiply2(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix2(_powArray(x.valueOf(), y));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT = "Number of decimals in function round must be an integer";
var name89 = "round";
var dependencies89 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = factory(name89, dependencies89, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2(name89, {
    number: roundNumber,
    "number, number": roundNumber,
    "number, BigNumber": function numberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new BigNumber2(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex3(x) {
      return x.round();
    },
    "Complex, number": function ComplexNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber3(x) {
      return x.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.toDecimalPlaces(n.toNumber());
    },
    Fraction: function Fraction3(x) {
      return x.round();
    },
    "Fraction, number": function FractionNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    // deep map collection, skip zeros since round(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true)),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      return matAlgo14xDs(x, y, self, false);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      return matAlgo14xDs(matrix2(x), y, self, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo12xSfs(y, x, self, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf((self) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self, true).valueOf();
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name90 = "log";
var dependencies90 = ["config", "typed", "divideScalar", "Complex"];
var createLog = factory(name90, dependencies90, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    divideScalar: divideScalar2,
    Complex: Complex3
  } = _ref;
  return typed2(name90, {
    number: function number2(x) {
      if (x >= 0 || config2.predictable) {
        return logNumber(x);
      } else {
        return new Complex3(x, 0).log();
      }
    },
    Complex: function Complex4(x) {
      return x.log();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.ln();
      } else {
        return new Complex3(x.toNumber(), 0).log();
      }
    },
    "any, any": typed2.referToSelf((self) => (x, base) => {
      return divideScalar2(self(x), self(base));
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name91 = "log1p";
var dependencies91 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = factory(name91, dependencies91, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    divideScalar: divideScalar2,
    log: log3,
    Complex: Complex3
  } = _ref;
  return typed2(name91, {
    number: function number2(x) {
      if (x >= -1 || config2.predictable) {
        return log1p(x);
      } else {
        return _log1pComplex(new Complex3(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber2(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config2.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex3(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self)),
    "any, any": typed2.referToSelf((self) => (x, base) => {
      return divideScalar2(self(x), log3(base));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name92 = "nthRoots";
var dependencies92 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = factory(name92, dependencies92, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    divideScalar: divideScalar2,
    Complex: Complex3
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex3(val, 0);
  }, function imagPos(val) {
    return new Complex3(0, val);
  }, function realNeg(val) {
    return new Complex3(-val, 0);
  }, function imagNeg(val) {
    return new Complex3(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0)
      throw new Error("Root must be greater than zero");
    if (root === 0)
      throw new Error("Root must be non-zero");
    if (root % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0)
      return [new Complex3(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg2 = a.arg();
    var abs2 = a.abs();
    var roots = [];
    var r = Math.pow(abs2, 1 / root);
    for (var k = 0; k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex3({
        r,
        phi: (arg2 + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed2(name92, {
    Complex: function Complex4(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name93 = "dotPow";
var dependencies93 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix"];
var createDotPow = factory(name93, dependencies93, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    matrix: matrix2,
    pow: pow2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var powScalarSignatures = {};
  for (var signature in pow2.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow2.signatures[signature];
      }
    }
  }
  var powScalar = typed2(powScalarSignatures);
  return typed2(name93, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name94 = "dotDivide";
var dependencies94 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix"];
var createDotDivide = factory(name94, dependencies94, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name94, matrixAlgorithmSuite({
    elop: divideScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format2(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format2(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i2 = 0; i2 < rows; i2++) {
          data[i2] = [bdata[i2]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index2 = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            var _i3 = index2[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name95 = "lsolve";
var dependencies95 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createLsolve = factory(name95, dependencies95, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name95, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j + 1; i2 < rows; i2++) {
          bdata[i2] = [subtract2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex; k < lastIndex; k++) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 > j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, l = jIndices.length; _k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtract2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name96 = "usolve";
var dependencies96 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createUsolve = factory(name96, dependencies96, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name96, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j - 1; i2 >= 0; i2--) {
          bdata[i2] = [subtract2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1; k >= firstIndex; k--) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 < j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtract2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name97 = "lsolveAll";
var dependencies97 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createLsolveAll = factory(name97, dependencies97, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name97, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 + 1; j < columns; j++) {
            b[j] = subtract2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 + 1; _j < columns; _j++) {
            bNew[_j] = subtract2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = firstIndex; j < lastIndex; j++) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J > i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtract2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name98 = "usolveAll";
var dependencies98 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createUsolveAll = factory(name98, dependencies98, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name98, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 - 1; j >= 0; j--) {
            b[j] = subtract2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 - 1; _j >= 0; _j--) {
            bNew[_j] = subtract2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = lastIndex - 1; j >= firstIndex; j--) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J < i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtract2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
var name99 = "matAlgo08xS0Sid";
var dependencies99 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = factory(name99, dependencies99, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i2;
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        w[i2] = mark;
        x[i2] = avalues[k];
        cindex.push(i2);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (w[i2] === mark) {
          x[i2] = cf(x[i2], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i2 = cindex[k];
        var v = x[i2];
        if (!eq(v, zero)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
var createUseMatrixForArrayScalar = factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return {
    "Array, number": typed2.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix2(x), y).valueOf()),
    "Array, BigNumber": typed2.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix2(x), y).valueOf()),
    "number, Array": typed2.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix2(y)).valueOf()),
    "BigNumber, Array": typed2.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix2(y)).valueOf())
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name100 = "leftShift";
var dependencies100 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createLeftShift = factory(name100, dependencies100, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name100, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name101 = "rightArithShift";
var dependencies101 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createRightArithShift = factory(name101, dependencies101, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name101, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name102 = "rightLogShift";
var dependencies102 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createRightLogShift = factory(name102, dependencies102, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name102, {
    "number, number": rightLogShiftNumber,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/logical/and.js
var name103 = "and";
var dependencies103 = ["typed", "matrix", "equalScalar", "zeros", "not"];
var createAnd = factory(name103, dependencies103, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name103, {
    "number, number": andNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => self(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed2.referToSelf((self) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, any": typed2.referToSelf((self) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "any, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(y, x, self, true);
    }),
    "any, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    }),
    "Array, any": typed2.referToSelf((self) => (x, y) => {
      return self(matrix2(x), y).valueOf();
    }),
    "any, Array": typed2.referToSelf((self) => (x, y) => {
      return self(x, matrix2(y)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/matrix/sort.js
var name104 = "sort";
var dependencies104 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = factory(name104, dependencies104, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    compare: compare2,
    compareNatural: compareNatural2
  } = _ref;
  var compareAsc = compare2;
  var compareDesc = (a, b) => -compare2(a, b);
  return typed2(name104, {
    Array: function Array2(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix2(x) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function ArrayFunction(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function MatrixFunction(x, _comparator2) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function ArrayString(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function MatrixString(x, order) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural2;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array) {
    if (arraySize(array).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix3) {
    if (matrix3.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});

// node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name105 = "ImmutableDenseMatrix";
var dependencies105 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = factory(name105, dependencies105, (_ref) => {
  var {
    smaller: smaller2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  function ImmutableDenseMatrix2(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix2 = new DenseMatrix2(data, datatype);
      this._data = matrix2._data;
      this._size = matrix2._size;
      this._datatype = matrix2._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix2.prototype = new DenseMatrix2();
  ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix2.prototype.subset = function(index2) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix2.prototype.subset.call(this, index2);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix2({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix2.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.clone = function() {
    return new ImmutableDenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix2.fromJSON = function(json) {
    return new ImmutableDenseMatrix2(json);
  };
  ImmutableDenseMatrix2.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : void 0;
    }
    return this._min;
  };
  ImmutableDenseMatrix2.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : void 0;
    }
    return this._max;
  };
  return ImmutableDenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name106 = "Index";
var dependencies106 = ["ImmutableDenseMatrix"];
var createIndexClass = factory(name106, dependencies106, (_ref) => {
  var {
    ImmutableDenseMatrix: ImmutableDenseMatrix2
  } = _ref;
  function Index2(ranges) {
    if (!(this instanceof Index2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._isScalar = true;
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        this._dimensions.push(arg2);
        this._isScalar = false;
      } else if (Array.isArray(arg2) || isMatrix(arg2)) {
        var m = _createImmutableMatrix(arg2.valueOf());
        this._dimensions.push(m);
        var size2 = m.size();
        if (size2.length !== 1 || size2[0] !== 1) {
          this._isScalar = false;
        }
      } else if (typeof arg2 === "number") {
        this._dimensions.push(_createImmutableMatrix([arg2]));
      } else if (typeof arg2 === "string") {
        this._dimensions.push(arg2);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
    }
  }
  Index2.prototype.type = "Index";
  Index2.prototype.isIndex = true;
  function _createImmutableMatrix(arg2) {
    for (var i2 = 0, l = arg2.length; i2 < l; i2++) {
      if (typeof arg2[i2] !== "number" || !isInteger(arg2[i2])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix2(arg2);
  }
  Index2.prototype.clone = function() {
    var index2 = new Index2();
    index2._dimensions = clone(this._dimensions);
    index2._isScalar = this._isScalar;
    return index2;
  };
  Index2.create = function(ranges) {
    var index2 = new Index2();
    Index2.apply(index2, ranges);
    return index2;
  };
  Index2.prototype.size = function() {
    var size2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var d = this._dimensions[i2];
      size2[i2] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size2;
  };
  Index2.prototype.max = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.max();
    }
    return values;
  };
  Index2.prototype.min = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.min();
    }
    return values;
  };
  Index2.prototype.forEach = function(callback) {
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      callback(this._dimensions[i2], i2, this);
    }
  };
  Index2.prototype.dimension = function(dim) {
    return this._dimensions[dim] || null;
  };
  Index2.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index2.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index2.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index2.prototype.toArray = function() {
    var array = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      array.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array;
  };
  Index2.prototype.valueOf = Index2.prototype.toArray;
  Index2.prototype.toString = function() {
    var strings = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index2.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index2.fromJSON = function(json) {
    return Index2.create(json.dimensions);
  };
  return Index2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name107 = "FibonacciHeap";
var dependencies107 = ["smaller", "larger"];
var createFibonacciHeapClass = factory(name107, dependencies107, (_ref) => {
  var {
    smaller: smaller2,
    larger: larger2
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap2() {
    if (!(this instanceof FibonacciHeap2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap2.prototype.type = "FibonacciHeap";
  FibonacciHeap2.prototype.isFibonacciHeap = true;
  FibonacciHeap2.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller2(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap2.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap2.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap2.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap2.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap2.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller2(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller2(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size2) {
    var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
    var array = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array[d];
        if (!y) {
          break;
        }
        if (larger2(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array[d] = null;
        d++;
      }
      array[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i2 = 0; i2 < arraySize2; i2++) {
      y = array[i2];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller2(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name108 = "Spa";
var dependencies108 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = factory(name108, dependencies108, (_ref) => {
  var {
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    FibonacciHeap: FibonacciHeap2
  } = _ref;
  function Spa2() {
    if (!(this instanceof Spa2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap2();
  }
  Spa2.prototype.type = "Spa";
  Spa2.prototype.isSpa = true;
  Spa2.prototype.set = function(i2, v) {
    if (!this._values[i2]) {
      var node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      this._values[i2].value = v;
    }
  };
  Spa2.prototype.get = function(i2) {
    var node = this._values[i2];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa2.prototype.accumulate = function(i2, v) {
    var node = this._values[i2];
    if (!node) {
      node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      node.value = addScalar2(node.value, v);
    }
  };
  Spa2.prototype.forEach = function(from, to2, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to2) {
      if (node.key >= from) {
        if (!equalScalar2(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var n = nodes[i2];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa2.prototype.swap = function(i2, j) {
    var nodei = this._values[i2];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i2, nodej.value);
      this._heap.remove(nodej);
      this._values[i2] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i2] = void 0;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/unit/Unit.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var name109 = "Unit";
var dependencies109 = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = factory(name109, dependencies109, (_ref) => {
  var {
    on,
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow2,
    abs: abs2,
    fix: fix2,
    round: round2,
    equal: equal2,
    isNumeric: isNumeric2,
    format: format4,
    number: number2,
    Complex: Complex3,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = number2;
  function Unit2(value, valuelessUnit) {
    if (!(this instanceof Unit2)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === void 0) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit2.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit2, "name", {
    value: "Unit"
  });
  Unit2.prototype.constructor = Unit2;
  Unit2.prototype.type = "Unit";
  Unit2.prototype.isUnit = true;
  var text, index2, c;
  function skipWhitespace() {
    while (c === " " || c === "	") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index2++;
    c = text.charAt(index2);
  }
  function revert(oldIndex) {
    index2 = oldIndex;
    c = text.charAt(index2);
  }
  function parseNumber() {
    var number3 = "";
    var oldIndex = index2;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number3 += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number3 += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number3 += c;
        next();
      }
      if (c === ".") {
        number3 += c;
        next();
      }
    }
    while (isDigit(c)) {
      number3 += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index2;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number3;
      }
      number3 = number3 + tentativeNumber;
      while (isDigit(c)) {
        number3 += c;
        next();
      }
    }
    return number3;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit2.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit2.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit2.parse = function(str, options) {
    options = options || {};
    text = str;
    index2 = -1;
    c = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit3 = new Unit2();
    unit3.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config2.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config2.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = void 0;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit3.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
        unit3.dimensions[i2] += (res.unit.dimensions[i2] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit3.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit3.value = value !== void 0 ? unit3._normalize(value) : null;
    return unit3;
  };
  Unit2.prototype.clone = function() {
    var unit3 = new Unit2();
    unit3.fixPrefix = this.fixPrefix;
    unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit3.value = clone(this.value);
    unit3.dimensions = this.dimensions.slice(0);
    unit3.units = [];
    for (var i2 = 0; i2 < this.units.length; i2++) {
      unit3.units[i2] = {};
      for (var p in this.units[i2]) {
        if (hasOwnProperty(this.units[i2], p)) {
          unit3.units[i2][p] = this.units[i2][p];
        }
      }
    }
    return unit3;
  };
  Unit2.prototype.valueType = function() {
    return typeOf(this.value);
  };
  Unit2.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  };
  Unit2.prototype._normalize = function(value) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = multiplyScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit2.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = divideScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty(UNITS, str)) {
      var unit3 = UNITS[str];
      var prefix = unit3.prefixes[""];
      return {
        unit: unit3,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
          if (_prefix !== void 0) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit2.isValuelessUnit = function(name187) {
    return _findUnit(name187) !== null;
  };
  Unit2.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (base.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equalBase = function(other) {
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (other.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equals = function(other) {
    return this.equalBase(other) && equal2(this.value, other.value);
  };
  Unit2.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) + (other.dimensions[i2] || 0);
    }
    for (var _i = 0; _i < other.units.length; _i++) {
      var inverted = _objectSpread({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.divideInto = function(numerator) {
    return new Unit2(numerator).divide(this);
  };
  Unit2.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) - (other.dimensions[i2] || 0);
    }
    for (var _i2 = 0; _i2 < other.units.length; _i2++) {
      var inverted = _objectSpread(_objectSpread({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.pow = function(p) {
    var res = this.clone();
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) * p;
    }
    for (var _i3 = 0; _i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow2(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit3) {
    if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config2.predictable) {
      return unit3.value;
    } else {
      return unit3;
    }
  }
  Unit2.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units[0].unit.offset === 0) {
        ret.value = abs2(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar2(unitValue, nominalOffset);
        ret.value = subtract2(abs2(addScalar2(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i2 in ret.units) {
      if (ret.units[i2].unit.name === "VA" || ret.units[i2].unit.name === "VAR") {
        ret.units[i2].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit2.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit2.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone(value);
    } else {
      var convert = Unit2._getNumberConverter(typeOf(value));
      var thisUnitValue = convert(this.units[0].unit.value);
      var thisNominalOffset = convert(this.units[0].unit.offset);
      var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
      var otherUnitValue = convert(other.units[0].unit.value);
      var otherNominalOffset = convert(other.units[0].unit.offset);
      var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
      other.value = subtract2(addScalar2(value, thisUnitOffset), otherUnitOffset);
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit2.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit2.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit2.prototype.toString = function() {
    return this.format();
  };
  Unit2.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };
  Unit2.fromJSON = function(json) {
    var unit3 = new Unit2(json.value, json.unit);
    unit3.fixPrefix = json.fixPrefix || false;
    return unit3;
  };
  Unit2.prototype.valueOf = Unit2.prototype.toString;
  Unit2.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          var baseDim = BASE_DIMENSIONS[i2];
          if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
            if (hasOwnProperty(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i2] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit2.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      var baseDim = BASE_DIMENSIONS[i2];
      if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
        if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i2] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    return ret;
  };
  Unit2.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i2 = 0; i2 < this.units.length; i2++) {
      if (this.units[i2].power > 0) {
        nNum++;
        strNum += " " + this.units[i2].prefix.name + this.units[i2].unit.name;
        if (Math.abs(this.units[i2].power - 1) > 1e-15) {
          strNum += "^" + this.units[i2].power;
        }
      } else if (this.units[i2].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0; _i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit2.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 1e-14;
    }
    for (var i2 in simp.units) {
      if (hasOwnProperty(simp.units, i2)) {
        if (simp.units[i2].unit) {
          if (simp.units[i2].unit.name === "VA" && isImaginary) {
            simp.units[i2].unit = UNITS.VAR;
          } else if (simp.units[i2].unit.name === "VAR" && !isImaginary) {
            simp.units[i2].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format4(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit2.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs2(this.value) : 0;
    var absUnitValue = abs2(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (hasOwnProperty(prefixes, p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {
          var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff2;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit2.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i2 = 0; i2 < parts.length; i2++) {
      x = x.to(parts[i2]);
      if (i2 === parts.length - 1)
        break;
      var xNumeric = x.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = void 0;
      var isNearlyEqual = equal2(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix2(x.toNumeric());
      }
      var y = new Unit2(xFixed, parts[i2].toString());
      ret.push(y);
      x = subtract2(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0; _i5 < ret.length; _i5++) {
      testSum = addScalar2(testSum, ret[_i5].value);
    }
    if (equal2(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: true
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    // length
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 6161152e-14,
      offset: 0
    },
    // 0.06161152 mL
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238481,
      offset: 0
    },
    // 238.4810 L
    // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: "fldr",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    floz: {
      name: "floz",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gi: {
      name: "gi",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cp: {
      name: "cp",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pt: {
      name: "pt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    qt: {
      name: "qt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gal: {
      name: "gal",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    bbl: {
      name: "bbl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    obl: {
      name: "obl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
    // Mass
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    // Angle
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = °C + 273.15
    // K(F) = (°F + 459.67) / 1.8
    // K(R) = °R / 1.8
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1 / 1.8,
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1 / 1.8,
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1 / 1.8,
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1 / 1.8,
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.NONE,
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex3.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config3) {
    if (config3.number === "BigNumber") {
      var pi2 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi2.div(180);
      UNITS.grad.value = pi2.div(200);
      UNITS.cycle.value = pi2.times(2);
      UNITS.arcsec.value = pi2.div(648e3);
      UNITS.arcmin.value = pi2.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648e3;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config2);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit2.setUnitSystem = function(name187) {
    if (hasOwnProperty(UNIT_SYSTEMS, name187)) {
      currentUnitSystem = UNIT_SYSTEMS[name187];
    } else {
      throw new Error("Unit system " + name187 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit2.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit2.typeConverters = {
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction3(x) {
      return new _Fraction(x);
    },
    Complex: function Complex4(x) {
      return x;
    },
    number: function number3(x) {
      return x;
    }
  };
  Unit2.prototype._numberConverter = function() {
    var convert = Unit2.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit2._getNumberConverter = function(type) {
    if (!Unit2.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit2.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty(UNITS, _key2)) {
      var unit2 = UNITS[_key2];
      unit2.dimensions = unit2.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit2.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name187) {
    for (var i2 = 0; i2 < name187.length; i2++) {
      c = name187.charAt(i2);
      if (i2 === 0 && !Unit2.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name187 + '"');
      }
      if (i2 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name187 + '"');
      }
    }
  }
  Unit2.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty(obj, _key4)) {
          Unit2.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i2 = 0; i2 < obj[_key4].aliases.length; i2++) {
            Unit2.deleteUnit(obj[_key4].aliases[i2]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty(obj, _key5)) {
        lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit2.createUnitSingle = function(name187, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name187 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty(UNITS, name187)) {
      throw new Error('Cannot create unit "' + name187 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name187);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name187 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i2 = 0; i2 < aliases.length; i2++) {
        if (hasOwnProperty(UNITS, aliases[i2])) {
          throw new Error('Cannot create alias "' + aliases[i2] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit2.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name187 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes && prefixes.toUpperCase) {
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name187 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name187 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name187,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name187,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name187 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit2.UNITS[name187] = newUnit;
    for (var _i8 = 0; _i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit2.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit2(null, name187);
  };
  Unit2.deleteUnit = function(name187) {
    delete Unit2.UNITS[name187];
  };
  Unit2.PREFIXES = PREFIXES;
  Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit2.BASE_UNITS = BASE_UNITS;
  Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit2.UNITS = UNITS;
  return Unit2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name110 = "unit";
var dependencies110 = ["typed", "Unit"];
var createUnitFunction = factory(name110, dependencies110, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name110, {
    Unit: function Unit3(x) {
      return x.clone();
    },
    string: function string2(x) {
      if (Unit2.isValuelessUnit(x)) {
        return new Unit2(null, x);
      }
      return Unit2.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit2) {
      return new Unit2(value, unit2);
    },
    "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
      return new Unit2(value);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name111 = "sparse";
var dependencies111 = ["typed", "SparseMatrix"];
var createSparse = factory(name111, dependencies111, (_ref) => {
  var {
    typed: typed2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name111, {
    "": function _() {
      return new SparseMatrix2([]);
    },
    string: function string2(datatype) {
      return new SparseMatrix2([], datatype);
    },
    "Array | Matrix": function ArrayMatrix(data) {
      return new SparseMatrix2(data);
    },
    "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
      return new SparseMatrix2(data, datatype);
    }
  });
});

// node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name112 = "createUnit";
var dependencies112 = ["typed", "Unit"];
var createCreateUnit = factory(name112, dependencies112, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name112, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function ObjectObject(obj, options) {
      return Unit2.createUnit(obj, options);
    },
    // Same as above but without the options.
    Object: function Object2(obj) {
      return Unit2.createUnit(obj, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name187, def, options) {
      var obj = {};
      obj[name187] = def;
      return Unit2.createUnit(obj, options);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function stringUnitStringObject(name187, def) {
      var obj = {};
      obj[name187] = def;
      return Unit2.createUnit(obj, {});
    },
    // Without a definition, creates a base unit.
    string: function string2(name187) {
      var obj = {};
      obj[name187] = {};
      return Unit2.createUnit(obj, {});
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name113 = "acos";
var dependencies113 = ["typed", "config", "Complex"];
var createAcos = factory(name113, dependencies113, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name113, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config2.predictable) {
        return Math.acos(x);
      } else {
        return new Complex3(x, 0).acos();
      }
    },
    Complex: function Complex4(x) {
      return x.acos();
    },
    BigNumber: function BigNumber2(x) {
      return x.acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name114 = "acosh";
var dependencies114 = ["typed", "config", "Complex"];
var createAcosh = factory(name114, dependencies114, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name114, {
    number: function number2(x) {
      if (x >= 1 || config2.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex3(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex3(x, 0).acosh();
    },
    Complex: function Complex4(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber2(x) {
      return x.acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name115 = "acot";
var dependencies115 = ["typed", "BigNumber"];
var createAcot = factory(name115, dependencies115, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name115, {
    number: acotNumber,
    Complex: function Complex3(x) {
      return x.acot();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name116 = "acoth";
var dependencies116 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = factory(name116, dependencies116, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name116, {
    number: function number2(x) {
      if (x >= 1 || x <= -1 || config2.predictable) {
        return acothNumber(x);
      }
      return new Complex3(x, 0).acoth();
    },
    Complex: function Complex4(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name117 = "acsc";
var dependencies117 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = factory(name117, dependencies117, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name117, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config2.predictable) {
        return acscNumber(x);
      }
      return new Complex3(x, 0).acsc();
    },
    Complex: function Complex4(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name118 = "acsch";
var dependencies118 = ["typed", "BigNumber"];
var createAcsch = factory(name118, dependencies118, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name118, {
    number: acschNumber,
    Complex: function Complex3(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name119 = "asec";
var dependencies119 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = factory(name119, dependencies119, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name119, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config2.predictable) {
        return asecNumber(x);
      }
      return new Complex3(x, 0).asec();
    },
    Complex: function Complex4(x) {
      return x.asec();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name120 = "asech";
var dependencies120 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = factory(name120, dependencies120, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name120, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config2.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config2.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex3(Math.log(ret - xInv), Math.PI);
      }
      return new Complex3(x, 0).asech();
    },
    Complex: function Complex4(x) {
      return x.asech();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name121 = "asin";
var dependencies121 = ["typed", "config", "Complex"];
var createAsin = factory(name121, dependencies121, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name121, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config2.predictable) {
        return Math.asin(x);
      } else {
        return new Complex3(x, 0).asin();
      }
    },
    Complex: function Complex4(x) {
      return x.asin();
    },
    BigNumber: function BigNumber2(x) {
      return x.asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name122 = "asinh";
var dependencies122 = ["typed"];
var createAsinh = factory(name122, dependencies122, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("asinh", {
    number: asinhNumber,
    Complex: function Complex3(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber2(x) {
      return x.asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name123 = "atan";
var dependencies123 = ["typed"];
var createAtan = factory(name123, dependencies123, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("atan", {
    number: function number2(x) {
      return Math.atan(x);
    },
    Complex: function Complex3(x) {
      return x.atan();
    },
    BigNumber: function BigNumber2(x) {
      return x.atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name124 = "atan2";
var dependencies124 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
var createAtan2 = factory(name124, dependencies124, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name124, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (y, x) => BigNumber2.atan2(y, x)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name125 = "atanh";
var dependencies125 = ["typed", "config", "Complex"];
var createAtanh = factory(name125, dependencies125, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name125, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config2.predictable) {
        return atanhNumber(x);
      }
      return new Complex3(x, 0).atanh();
    },
    Complex: function Complex4(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber2(x) {
      return x.atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
var createTrigUnit = factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    Unit: typed2.referToSelf((self) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed2.find(self, x.valueType())(x.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name126 = "cos";
var dependencies126 = ["typed"];
var createCos = factory(name126, dependencies126, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name126, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name127 = "cosh";
var dependencies127 = ["typed"];
var createCosh = factory(name127, dependencies127, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name127, {
    number: cosh,
    "Complex | BigNumber": (x) => x.cosh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name128 = "cot";
var dependencies128 = ["typed", "BigNumber"];
var createCot = factory(name128, dependencies128, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name128, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name129 = "coth";
var dependencies129 = ["typed", "BigNumber"];
var createCoth = factory(name129, dependencies129, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name129, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name130 = "csc";
var dependencies130 = ["typed", "BigNumber"];
var createCsc = factory(name130, dependencies130, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name130, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name131 = "csch";
var dependencies131 = ["typed", "BigNumber"];
var createCsch = factory(name131, dependencies131, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name131, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name132 = "sec";
var dependencies132 = ["typed", "BigNumber"];
var createSec = factory(name132, dependencies132, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name132, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name133 = "sech";
var dependencies133 = ["typed", "BigNumber"];
var createSech = factory(name133, dependencies133, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name133, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name134 = "sin";
var dependencies134 = ["typed"];
var createSin = factory(name134, dependencies134, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name134, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name135 = "sinh";
var dependencies135 = ["typed"];
var createSinh = factory(name135, dependencies135, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name135, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name136 = "tan";
var dependencies136 = ["typed"];
var createTan = factory(name136, dependencies136, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name136, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name137 = "tanh";
var dependencies137 = ["typed"];
var createTanh = factory(name137, dependencies137, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("tanh", {
    number: tanh,
    "Complex | BigNumber": (x) => x.tanh()
  });
});

// node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name138 = "setCartesian";
var dependencies138 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = factory(name138, dependencies138, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name138, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result = [];
      if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            result.push([b1[i2], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDifference.js
var name139 = "setDifference";
var dependencies139 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = factory(name139, dependencies139, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name139, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0) {
        result = [];
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1.toArray());
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        var inb2;
        for (var i2 = 0; i2 < b1.length; i2++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i2]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name140 = "setDistinct";
var dependencies140 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = factory(name140, dependencies140, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name140, {
    "Array | Matrix": function ArrayMatrix(a) {
      var result;
      if (subset2(size2(a), new Index2(0)) === 0) {
        result = [];
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        result = [];
        result.push(b[0]);
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            result.push(b[i2]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name141 = "setIntersect";
var dependencies141 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = factory(name141, dependencies141, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name141, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              result.push(b1[i2]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name142 = "setIsSubset";
var dependencies142 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = factory(name142, dependencies142, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name142, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return true;
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
      var inb2;
      for (var i2 = 0; i2 < b1.length; i2++) {
        inb2 = false;
        for (var j = 0; j < b2.length; j++) {
          if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name143 = "setMultiplicity";
var dependencies143 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = factory(name143, dependencies143, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name143, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e2, a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return 0;
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray());
      var count2 = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        if (compareNatural2(b[i2], e2) === 0) {
          count2++;
        }
      }
      return count2;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name144 = "setPowerset";
var dependencies144 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = factory(name144, dependencies144, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name144, {
    "Array | Matrix": function ArrayMatrix(a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return [];
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
      var result = [];
      var number2 = 0;
      while (number2.toString(2).length <= b.length) {
        result.push(_subset(b, number2.toString(2).split("").reverse()));
        number2++;
      }
      return _sort(result);
    }
  });
  function _subset(array, bitarray) {
    var result = [];
    for (var i2 = 0; i2 < bitarray.length; i2++) {
      if (bitarray[i2] === "1") {
        result.push(array[i2]);
      }
    }
    return result;
  }
  function _sort(array) {
    var temp = [];
    for (var i2 = array.length - 1; i2 > 0; i2--) {
      for (var j = 0; j < i2; j++) {
        if (array[j].length > array[j + 1].length) {
          temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }
});

// node_modules/mathjs/lib/esm/function/set/setSize.js
var name145 = "setSize";
var dependencies145 = ["typed", "compareNatural"];
var createSetSize = factory(name145, dependencies145, (_ref) => {
  var {
    typed: typed2,
    compareNatural: compareNatural2
  } = _ref;
  return typed2(name145, {
    "Array | Matrix": function ArrayMatrix(a) {
      return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
    },
    "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
      if (unique === false || a.length === 0) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        var count2 = 1;
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            count2++;
          }
        }
        return count2;
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name146 = "setSymDifference";
var dependencies146 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = factory(name146, dependencies146, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat2,
    subset: subset2,
    setDifference: setDifference2,
    Index: Index2
  } = _ref;
  return typed2(name146, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat2(setDifference2(b1, b2), setDifference2(b2, b1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setUnion.js
var name147 = "setUnion";
var dependencies147 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = factory(name147, dependencies147, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat2,
    subset: subset2,
    setIntersect: setIntersect2,
    setSymDifference: setSymDifference2,
    Index: Index2
  } = _ref;
  return typed2(name147, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat2(setSymDifference2(b1, b2), setIntersect2(b1, b2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name148 = "add";
var dependencies148 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix"];
var createAdd = factory(name148, dependencies148, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name148, {
    "any, any": addScalar2,
    "any, any, ...any": typed2.referToSelf((self) => (x, y, rest) => {
      var result = self(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self(result, rest[i2]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar2,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name149 = "norm";
var dependencies149 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = factory(name149, dependencies149, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    pow: pow2,
    conj: conj2,
    sqrt: sqrt2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    ctranspose: ctranspose2,
    eigs: eigs2
  } = _ref;
  return typed2(name149, {
    number: Math.abs,
    Complex: function Complex3(x) {
      return x.abs();
    },
    BigNumber: function BigNumber2(x) {
      return x.abs();
    },
    boolean: function boolean2(x) {
      return Math.abs(x);
    },
    Array: function Array2(x) {
      return _norm(matrix2(x), 2);
    },
    Matrix: function Matrix2(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
      return _norm(matrix2(x), p);
    },
    "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
      return _norm(x, p);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs2(value);
      if (larger2(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs2(value);
      if (!ninf || smaller2(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p === "fro") {
      return _norm(x, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar2(p, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add2(pow2(abs2(value), p), n);
        }, true);
        return pow2(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index2) {
      fro = add2(fro, multiply2(value, conj2(value)));
    });
    return abs2(sqrt2(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index2) {
      var j = index2[1];
      var cj = add2(c[j] || 0, abs2(value));
      if (larger2(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose2(x);
    var squaredX = multiply2(tx, x);
    var eigenVals = eigs2(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs2(sqrt2(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index2) {
      var i2 = index2[0];
      var ri = add2(r[i2] || 0, abs2(value));
      if (larger2(ri, maxr)) {
        maxr = ri;
      }
      r[i2] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p) {
    if (p === 1) {
      return _matrixNormOne(x);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x, p) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/dot.js
var name150 = "dot";
var dependencies150 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = factory(name150, dependencies150, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    conj: conj2,
    size: size2
  } = _ref;
  return typed2(name150, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype : void 0;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar2;
    var mul = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      var dt = adt;
      add2 = typed2.find(addScalar2, [dt, dt]);
      mul = typed2.find(multiplyScalar2, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul(conj2(adata[0]), bdata[0]);
      for (var i2 = 1; i2 < N; i2++) {
        c = add2(c, mul(conj2(adata[i2]), bdata[i2]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul(conj2(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c = add2(_c, mul(conj2(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul(conj2(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c2 = add2(_c2, mul(conj2(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul(conj2(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add2(_c3, mul(conj2(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add2 = addScalar2;
    var mul = multiplyScalar2;
    var i2 = 0;
    var j = 0;
    while (i2 < xindex.length && j < yindex.length) {
      var I = xindex[i2];
      var J = yindex[j];
      if (I < J) {
        i2++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add2(c, mul(xvalues[i2], yvalues[j]));
        i2++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size2(x);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/trace.js
var name151 = "trace";
var dependencies151 = ["typed", "matrix", "add"];
var createTrace = factory(name151, dependencies151, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    add: add2
  } = _ref;
  return typed2("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix2(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone
  });
  function _denseTrace(m) {
    var size2 = m._size;
    var data = m._data;
    switch (size2.length) {
      case 1:
        if (size2[0] === 1) {
          return clone(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
      case 2: {
        var rows = size2[0];
        var cols = size2[1];
        if (rows === cols) {
          var sum2 = 0;
          for (var i2 = 0; i2 < rows; i2++) {
            sum2 = add2(sum2, data[i2][i2]);
          }
          return sum2;
        } else {
          throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
    }
  }
  function _sparseTrace(m) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var size2 = m._size;
    var rows = size2[0];
    var columns = size2[1];
    if (rows === columns) {
      var sum2 = 0;
      if (values.length > 0) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = index2[k];
            if (i2 === j) {
              sum2 = add2(sum2, values[k]);
              break;
            }
            if (i2 > j) {
              break;
            }
          }
        }
      }
      return sum2;
    }
    throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name152 = "index";
var dependencies152 = ["typed", "Index"];
var createIndex = factory(name152, dependencies152, (_ref) => {
  var {
    typed: typed2,
    Index: Index2
  } = _ref;
  return typed2(name152, {
    "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
      var ranges = args.map(function(arg2) {
        if (isBigNumber(arg2)) {
          return arg2.toNumber();
        } else if (Array.isArray(arg2) || isMatrix(arg2)) {
          return arg2.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg2;
        }
      });
      var res = new Index2();
      Index2.apply(res, ranges);
      return res;
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name153 = "lup";
var dependencies153 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = factory(name153, dependencies153, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    larger: larger2,
    equalScalar: equalScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    Spa: Spa2
  } = _ref;
  return typed2(name153, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix3(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i2, j, k;
    var p = [];
    for (i2 = 0; i2 < rows; i2++) {
      p[i2] = i2;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i2 = 0; i2 < rows; i2++) {
          var min2 = Math.min(i2, j);
          var s = 0;
          for (k = 0; k < min2; k++) {
            s = addScalar2(s, multiplyScalar2(data[i2][k], data[k][j]));
          }
          data[i2][j] = subtract2(data[i2][j], s);
        }
      }
      var pi2 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i2 = j; i2 < rows; i2++) {
        var v = data[i2][j];
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = i2;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi2) {
        p[j] = [p[pi2], p[pi2] = p[j]][0];
        DenseMatrix2._swapRows(j, pi2, data);
      }
      if (j < rows) {
        for (i2 = j + 1; i2 < rows; i2++) {
          var vij = data[i2][j];
          if (!equalScalar2(vij, 0)) {
            data[i2][j] = divideScalar2(data[i2][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          if (i2 < columns) {
            udata[i2] = [];
          }
          ldata[i2] = [];
        }
        if (i2 < j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 0;
          }
          continue;
        }
        if (i2 === j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 1;
          }
          continue;
        }
        if (i2 < columns) {
          udata[i2][j] = 0;
        }
        if (j < rows) {
          ldata[i2][j] = data[i2][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i2 = 0, n = p.length; i2 < n; i2++) {
      pv[p[i2]] = i2;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i2, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i2 = 0; i2 < rows; i2++) {
      pvCo[i2] = i2;
      pvOc[i2] = i2;
    }
    var swapIndeces = function swapIndeces2(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop2() {
      var spa = new Spa2();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0; k < k1; k++) {
        i2 = index2[k];
        spa.set(pvCo[i2], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i3, vik) {
            if (i3 > k2) {
              spa.accumulate(i3, unaryMinus2(multiplyScalar2(vik, vkj)));
            }
          });
        });
      }
      var pi2 = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi2) {
        SparseMatrix2._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
        SparseMatrix2._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi2);
        swapIndeces(j, pi2);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar2(v, vjj);
          if (!equalScalar2(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var name154 = "qr";
var dependencies154 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
var createQr = factory(name154, dependencies154, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    identity: identity2,
    isZero: isZero2,
    equal: equal2,
    sign: sign2,
    sqrt: sqrt2,
    conj: conj2,
    unaryMinus: unaryMinus2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    complex: complex2
  } = _ref;
  return _extends(typed2(name154, {
    DenseMatrix: function DenseMatrix2(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix2(m) {
      return _sparseQR(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q = identity2([rows], "dense");
    var Qdata = Q._data;
    var R = m.clone();
    var Rdata = R._data;
    var i2, j, k;
    var w = zeros2([rows], "");
    for (k = 0; k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign2(pivot));
      var conjSgn = conj2(sgn);
      var alphaSquared = 0;
      for (i2 = k; i2 < rows; i2++) {
        alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i2][k], conj2(Rdata[i2][k])));
      }
      var alpha = multiplyScalar2(sgn, sqrt2(alphaSquared));
      if (!isZero2(alpha)) {
        var u1 = subtract2(pivot, alpha);
        w[k] = 1;
        for (i2 = k + 1; i2 < rows; i2++) {
          w[i2] = divideScalar2(Rdata[i2][k], u1);
        }
        var tau2 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
        var s = void 0;
        for (j = k; j < cols; j++) {
          s = 0;
          for (i2 = k; i2 < rows; i2++) {
            s = addScalar2(s, multiplyScalar2(conj2(w[i2]), Rdata[i2][j]));
          }
          s = multiplyScalar2(s, tau2);
          for (i2 = k; i2 < rows; i2++) {
            Rdata[i2][j] = multiplyScalar2(subtract2(Rdata[i2][j], multiplyScalar2(w[i2], s)), conjSgn);
          }
        }
        for (i2 = 0; i2 < rows; i2++) {
          s = 0;
          for (j = k; j < rows; j++) {
            s = addScalar2(s, multiplyScalar2(Qdata[i2][j], w[j]));
          }
          s = multiplyScalar2(s, tau2);
          for (j = k; j < rows; ++j) {
            Qdata[i2][j] = divideScalar2(subtract2(Qdata[i2][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
      for (var i2 = 0; i2 < Rdata.length; ++i2) {
        for (var j = 0; j < i2 && j < (Rdata[0] || []).length; ++j) {
          Rdata[i2][j] = zero;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a, pinv2, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0; k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i2 = w[head + p];
    if (i2 === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i2];
      ++top;
      w[stack + top] = i2;
    }
  }
  return k;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i2, inext;
  if (ata) {
    for (i2 = 0; i2 < m; i2++) {
      w[prev + i2] = -1;
    }
  }
  for (var k = 0; k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
      var r = aindex[p];
      i2 = ata ? w[prev + r] : r;
      for (; i2 !== -1 && i2 < k; i2 = inext) {
        inext = w[ancestor + i2];
        w[ancestor + i2] = k;
        if (inext === -1) {
          parent[i2] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i2) {
  return -i2 - 2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name155 = "csAmd";
var dependencies155 = ["add", "multiply", "transpose"];
var createCsAmd = factory(name155, dependencies155, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i2, j, k, k1, k2, e2, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
    while (nel < n) {
      for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) {
        ;
      }
      if (W[next + k] !== -1) {
        last[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p = cptr[k];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e2 = k;
          pj = p;
          ln = W[len + k] - elenk;
        } else {
          e2 = cindex[p++];
          pj = cptr[e2];
          ln = W[len + e2];
        }
        for (k2 = 1; k2 <= ln; k2++) {
          i2 = cindex[pj++];
          if ((nvi = W[nv + i2]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i2] = -nvi;
          cindex[pk2++] = i2;
          if (W[next + i2] !== -1) {
            last[W[next + i2]] = last[i2];
          }
          if (last[i2] !== -1) {
            W[next + last[i2]] = W[next + i2];
          } else {
            W[head + W[degree + i2]] = W[next + i2];
          }
        }
        if (e2 !== k) {
          cptr[e2] = csFlip(k);
          W[w + e2] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((eln = W[elen + i2]) <= 0) {
          continue;
        }
        nvi = -W[nv + i2];
        var wnvi = mark - nvi;
        for (p = cptr[i2], p1 = cptr[i2] + eln - 1; p <= p1; p++) {
          e2 = cindex[p];
          if (W[w + e2] >= mark) {
            W[w + e2] -= nvi;
          } else if (W[w + e2] !== 0) {
            W[w + e2] = W[degree + e2] + wnvi;
          }
        }
      }
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        p1 = cptr[i2];
        p2 = p1 + W[elen + i2] - 1;
        pn = p1;
        for (h = 0, d = 0, p = p1; p <= p2; p++) {
          e2 = cindex[p];
          if (W[w + e2] !== 0) {
            var dext = W[w + e2] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e2;
              h += e2;
            } else {
              cptr[e2] = csFlip(k);
              W[w + e2] = 0;
            }
          }
        }
        W[elen + i2] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i2];
        for (p = p2 + 1; p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h += j;
        }
        if (d === 0) {
          cptr[i2] = csFlip(k);
          nvi = -W[nv + i2];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i2] = 0;
          W[elen + i2] = -1;
        } else {
          W[degree + i2] = Math.min(W[degree + i2], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k;
          W[len + i2] = pn - p1 + 1;
          h = (h < 0 ? -h : h) % n;
          W[next + i2] = W[hhead + h];
          W[hhead + h] = i2;
          last[i2] = h;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if (W[nv + i2] >= 0) {
          continue;
        }
        h = last[i2];
        i2 = W[hhead + h];
        W[hhead + h] = -1;
        for (; i2 !== -1 && W[next + i2] !== -1; i2 = W[next + i2], mark++) {
          ln = W[len + i2];
          eln = W[elen + i2];
          for (p = cptr[i2] + 1; p <= cptr[i2] + ln - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i2;
          for (j = W[next + i2]; j !== -1; ) {
            var ok = W[len + j] === ln && W[elen + j] === eln;
            for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i2);
              W[nv + i2] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((nvi = -W[nv + i2]) <= 0) {
          continue;
        }
        W[nv + i2] = nvi;
        d = W[degree + i2] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i2;
        }
        W[next + i2] = W[head + d];
        last[i2] = -1;
        W[head + d] = i2;
        mindeg = Math.min(mindeg, d);
        W[degree + i2] = d;
        cindex[p++] = i2;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      cptr[i2] = csFlip(cptr[i2]);
    }
    for (j = 0; j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n; j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e2 = n; e2 >= 0; e2--) {
      if (W[nv + e2] <= 0) {
        continue;
      }
      if (cptr[e2] !== -1) {
        W[next + e2] = W[head + cptr[e2]];
        W[head + cptr[e2]] = e2;
      }
    }
    for (k = 0, i2 = 0; i2 <= n; i2++) {
      if (cptr[i2] === -1) {
        k = csTdfs(i2, k, W, head, next, P, w);
      }
    }
    P.splice(P.length - 1, 1);
    return P;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose2(a);
    if (order === 1 && n === m) {
      return add2(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0; j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1]; p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a = transpose2(at);
      return multiply2(at, a);
    }
    return multiply2(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k = 0; k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i2 = 0; i2 <= n; i2++) {
      W[head + i2] = -1;
      last[i2] = -1;
      W[next + i2] = -1;
      W[hhead + i2] = -1;
      W[nv + i2] = 1;
      W[w + i2] = 1;
      W[elen + i2] = 0;
      W[degree + i2] = W[len + i2];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var d = W[degree + i2];
      if (d === 0) {
        W[elen + i2] = -2;
        nel++;
        cptr[i2] = -1;
        W[w + i2] = 0;
      } else if (d > dense) {
        W[nv + i2] = 0;
        W[elen + i2] = -1;
        nel++;
        cptr[i2] = csFlip(n);
        W[nv + n]++;
      } else {
        var h = W[head + d];
        if (h !== -1) {
          last[h] = i2;
        }
        W[next + i2] = W[head + d];
        W[head + d] = i2;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0; k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i2, j) {
    return i2 !== j;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i2 <= j || w[first + j] <= w[maxfirst + i2]) {
    return -1;
  }
  w[maxfirst + i2] = w[first + j];
  var jprev = w[prevleaf + i2];
  w[prevleaf + i2] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i2;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {
      ;
    }
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name156 = "csCounts";
var dependencies156 = ["transpose"];
var createCsCounts = factory(name156, dependencies156, (_ref) => {
  var {
    transpose: transpose2
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i2, j, k, J, p, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0; k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose2(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0; k < n; k++) {
      j = post[k];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k;
      }
    }
    if (ata) {
      for (k = 0; k < n; k++) {
        w[post[k]] = k;
      }
      for (i2 = 0; i2 < m; i2++) {
        for (k = n, p0 = tptr[i2], p1 = tptr[i2 + 1], p = p0; p < p1; p++) {
          k = Math.min(k, w[tindex[p]]);
        }
        w[next + i2] = w[head + k];
        w[head + k] = i2;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      w[ancestor + i2] = i2;
    }
    for (k = 0; k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J]; p < tptr[J + 1]; p++) {
          i2 = tindex[p];
          var r = csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name157 = "csSqr";
var dependencies157 = ["add", "multiply", "transpose"];
var createCsSqr = factory(name157, dependencies157, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  var csAmd = createCsAmd({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csCounts = createCsCounts({
    transpose: transpose2
  });
  return function csSqr(order, a, qr2) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr2) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0; k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv2 = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i2, k, p, p0, p1;
    for (k = 0; k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i2 = 0; i2 < m; i2++) {
      leftmost[i2] = -1;
    }
    for (k = n - 1; k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        leftmost[aindex[p]] = k;
      }
    }
    for (i2 = m - 1; i2 >= 0; i2--) {
      pinv2[i2] = -1;
      k = leftmost[i2];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i2;
      }
      w[next + i2] = w[head + k];
      w[head + k] = i2;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0; k < n; k++) {
      i2 = w[head + k];
      s.lnz++;
      if (i2 < 0) {
        i2 = s.m2++;
      }
      pinv2[i2] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i2];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i2 = 0; i2 < m; i2++) {
      if (pinv2[i2] < 0) {
        pinv2[i2] = k++;
      }
    }
    return true;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i2) {
  return i2 < 0 ? csFlip(i2) : i2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g, top, xi, pinv2) {
  var index2 = g._index;
  var ptr = g._ptr;
  var size2 = g._size;
  var n = size2[1];
  var i2, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv2 ? pinv2[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i2 = index2[p];
      if (csMarked(ptr, i2)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i2;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g, b, k, xi, pinv2) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
    var i2 = bindex[p];
    if (!csMarked(gptr, i2)) {
      top = csDfs(i2, g, top, xi, pinv2);
    }
  }
  for (p = top; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name158 = "csSpsolve";
var dependencies158 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = factory(name158, dependencies158, (_ref) => {
  var {
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv2, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv2);
    for (p = top; p < n; p++) {
      x[xi[p]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      x[bindex[p]] = bvalues[p];
    }
    for (var px = top; px < n; px++) {
      var j = xi[px];
      var J = pinv2 ? pinv2[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (; p < q; p++) {
        var i2 = gindex[p];
        x[i2] = subtract2(x[i2], multiply2(gvalues[p], x[j]));
      }
    }
    return top;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name159 = "csLu";
var dependencies159 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = factory(name159, dependencies159, (_ref) => {
  var {
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size2 = m._size;
    var n = size2[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix2({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix2({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv2 = [];
    var i2, p;
    var x = [];
    var xi = [];
    for (i2 = 0; i2 < n; i2++) {
      x[i2] = 0;
      pinv2[i2] = -1;
      lptr[i2 + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0; k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
      var ipiv = -1;
      var a = -1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          var xabs = abs2(x[i2]);
          if (larger2(xabs, a)) {
            a = xabs;
            ipiv = i2;
          }
        } else {
          uindex[unz] = pinv2[i2];
          uvalues[unz++] = x[i2];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv2[col] < 0 && largerEq2(abs2(x[col]), multiply2(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv2[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          lindex[lnz] = i2;
          lvalues[lnz++] = divideScalar2(x[i2], pivot);
        }
        x[i2] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0; p < lnz; p++) {
      lindex[p] = pinv2[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv: pinv2
    };
  };
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name160 = "slu";
var dependencies160 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = factory(name160, dependencies160, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    transpose: transpose2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSqr = createCsSqr({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csLu = createCsLu({
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  });
  return typed2(name160, {
    "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
      if (!isInteger(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr(order, a, false);
      var f = csLu(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0; k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name161 = "lusolve";
var dependencies161 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = factory(name161, dependencies161, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    lup: lup2,
    slu: slu2,
    usolve: usolve2,
    lsolve: lsolve2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name161, {
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      a = matrix2(a);
      var d = lup2(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
      var d = slu2(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray(a)) {
      return matrix2(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y = lsolve2(l, b);
    var x = usolve2(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
var name162 = "polynomialRoot";
var dependencies162 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = factory(name162, dependencies162, (_ref) => {
  var {
    typed: typed2,
    isZero: isZero2,
    equalScalar: equalScalar2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    sqrt: sqrt2,
    unaryMinus: unaryMinus2,
    cbrt: cbrt2,
    typeOf: typeOf3,
    im: im2,
    re: re2
  } = _ref;
  return typed2(name162, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero2(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus2(divide2(coeffs[0], coeffs[1]))];
        case 3: {
          var [c, b, a] = coeffs;
          var denom = multiply2(2, a);
          var d1 = multiply2(b, b);
          var d2 = multiply2(4, a, c);
          if (equalScalar2(d1, d2))
            return [divide2(unaryMinus2(b), denom)];
          var discriminant = sqrt2(subtract2(d1, d2));
          return [divide2(subtract2(discriminant, b), denom), divide2(subtract2(unaryMinus2(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus2(multiply2(3, _a));
          var D0_1 = multiply2(_b, _b);
          var D0_2 = multiply2(3, _a, _c);
          var D1_1 = add2(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d));
          var D1_2 = multiply2(9, _a, _b, _c);
          if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
            return [divide2(_b, _denom)];
          }
          var Delta0 = subtract2(D0_1, D0_2);
          var Delta1 = subtract2(D1_1, D1_2);
          var discriminant1 = add2(multiply2(18, _a, _b, _c, d), multiply2(_b, _b, _c, _c));
          var discriminant2 = add2(multiply2(4, _b, _b, _b, d), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d, d));
          if (equalScalar2(discriminant1, discriminant2)) {
            return [
              divide2(subtract2(multiply2(4, _a, _b, _c), add2(multiply2(9, _a, _a, d), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
              // simple root
              divide2(subtract2(multiply2(9, _a, d), multiply2(_b, _c)), multiply2(2, Delta0))
              // double root
            ];
          }
          var Ccubed;
          if (equalScalar2(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide2(add2(Delta1, sqrt2(subtract2(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt2(Ccubed, allRoots).toArray().map((C) => divide2(add2(_b, C, divide2(Delta0, C)), _denom));
          return rawRoots.map((r) => {
            if (typeOf3(r) === "Complex" && equalScalar2(re2(r), re2(r) + im2(r))) {
              return re2(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/det.js
var name163 = "det";
var dependencies163 = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = factory(name163, dependencies163, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2,
    divideScalar: divideScalar2,
    isZero: isZero2,
    unaryMinus: unaryMinus2
  } = _ref;
  return typed2(name163, {
    any: function any(x) {
      return clone(x);
    },
    "Array | Matrix": function det2(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone(x);
        case 1:
          if (size2[0] === 1) {
            return clone(x.valueOf()[0]);
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows, cols);
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone(matrix3[0][0]);
    } else if (rows === 2) {
      return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
      for (var k = 0; k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero2(matrix3[k_][k])) {
          var _k = void 0;
          for (_k = k + 1; _k < rows; _k++) {
            if (!isZero2(matrix3[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix3[k_][k];
        }
        var piv = matrix3[k_][k];
        var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
        for (var i2 = k + 1; i2 < rows; i2++) {
          var i_ = rowIndices[i2];
          for (var j = k + 1; j < rows; j++) {
            matrix3[i_][j] = divideScalar2(subtract2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
          }
        }
      }
      var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus2(det2) : det2;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/inv.js
var name164 = "inv";
var dependencies164 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = factory(name164, dependencies164, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    addScalar: addScalar2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs2
  } = _ref;
  return typed2(name164, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar2(1, x.valueOf()[0])]);
            } else {
              return [divideScalar2(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
      }
    },
    any: function any(x) {
      return divideScalar2(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity2(rows).valueOf();
      for (var c = 0; c < cols; c++) {
        var ABig = abs2(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs2(A[r][c]) > ABig) {
            ABig = abs2(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar2(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar2(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name165 = "pinv";
var dependencies165 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = factory(name165, dependencies165, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    inv: inv2,
    deepEqual: deepEqual2,
    equal: equal2,
    dotDivide: dotDivide2,
    dot: dot2,
    ctranspose: ctranspose2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    add: add2,
    Complex: Complex3
  } = _ref;
  return typed2(name165, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (_isZeros(x))
            return ctranspose2(x);
          if (size2[0] === 1) {
            return inv2(x);
          } else {
            return dotDivide2(ctranspose2(x), dot2(x, x));
          }
        case 2: {
          if (_isZeros(x))
            return ctranspose2(x);
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            try {
              return inv2(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
              } else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
      }
    },
    any: function any(x) {
      if (equal2(x, 0))
        return clone(x);
      return divideScalar2(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
    var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
    return multiply2(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone(mat);
    var lead = 0;
    for (var r = 0; r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i2 = r;
      while (_isZero(M[i2][lead])) {
        i2++;
        if (rows === i2) {
          i2 = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i2], M[r]] = [M[r], M[i2]];
      var val = M[r][lead];
      for (var j = 0; j < cols; j++) {
        M[r][j] = dotDivide2(M[r][j], val);
      }
      for (var _i = 0; _i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0; _j < cols; _j++) {
          M[_i][_j] = add2(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
    var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal2(add2(x, Complex3(1, 1)), add2(0, Complex3(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual2(add2(arr, Complex3(1, 1)), add2(multiply2(arr, 0), Complex3(1, 1)));
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar: addScalar2,
    subtract: subtract2,
    flatten: flatten3,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type, findVectors) {
    if (findVectors === void 0) {
      findVectors = true;
    }
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    var vectors;
    if (findVectors) {
      vectors = findEigenvectors(arr, N, C, R, values, prec, type);
      vectors = matrixFromColumns2(...vectors);
    }
    return {
      values,
      vectors
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar2(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i2 = 0; i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i2 === j)
            continue;
          var c = abs2(arr[i2][j]);
          colNorm = addScalar2(colNorm, c);
          rowNorm = addScalar2(rowNorm, c);
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var _c = colNorm;
          var rowDivRadix = divideScalar2(rowNorm, radix);
          var rowMulRadix = multiplyScalar2(rowNorm, radix);
          while (smaller2(_c, rowDivRadix)) {
            _c = multiplyScalar2(_c, radixSq);
            f = multiplyScalar2(f, radix);
          }
          while (larger2(_c, rowMulRadix)) {
            _c = divideScalar2(_c, radixSq);
            f = divideScalar2(f, radix);
          }
          var condition = smaller2(divideScalar2(addScalar2(_c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar2(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar2(arr[i2][_j], f);
              arr[_j][i2] = multiplyScalar2(arr[_j][i2], g);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar2(Rdiag[i2], f);
            }
          }
        }
      }
    }
    return diag2(Rdiag);
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0; i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max2 = zero;
      for (var j = i2 + 1; j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs2(max2), abs2(el))) {
          max2 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs2(max2), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2; _j3 < N; _j3++) {
        var n = divideScalar2(arr[_j3][i2], max2);
        if (n === 0) {
          continue;
        }
        for (var k = 0; k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i2 + 1][k]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i2 + 1] = addScalar2(arr[_k][i2 + 1], multiplyScalar2(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = 0;
      for (var i2 = 0; i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q,
        R
      } = qr2(arr);
      arr = multiply2(R, Q);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar2(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q);
      }
      if (n === 1 || smaller2(abs2(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs2(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs2(a), abs2(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var λ of values) {
      var i2 = indexOf(uniqueValues, λ, equal2);
      if (i2 === -1) {
        uniqueValues.push(λ);
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag2(Array(N).fill(one));
    var failedLambdas = [];
    var _loop = function _loop2(_i42) {
      var λ2 = uniqueValues[_i42];
      var S = subtract2(U, multiply2(λ2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i42]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec == null) {
          failedLambdas.push(λ2);
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => flatten3(v)));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop(_i4);
    }
    if (failedLambdas.length !== 0) {
      var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
      err.values = values;
      err.vectors = vectors;
      throw err;
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar2(a, d);
    var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
    var x = multiplyScalar2(trA, 0.5);
    var y = multiplyScalar2(sqrt2(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
    return [addScalar2(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (smaller2(abs2(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger2(abs2(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nb = subtract2(b, l1);
    var nc = subtract2(c, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs2(nb), prec)) {
      return [[na, one], [nc, zero]];
    } else {
      return [[nb, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0; i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub of arr) {
      var n = sub.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
    var b;
    var i2 = 0;
    while (true) {
      b = randomOrthogonalVector(N, orthog, type);
      b = usolve2(A, b);
      if (larger2(norm2(b), largeNum)) {
        break;
      }
      if (++i2 >= 5) {
        return null;
      }
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex2(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    for (var w of orthog) {
      v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs2(sqrt2(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    return multiply2(divideScalar2(one, norm2(v)), v);
  }
  return complexEigs;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
function createRealSymmetric(_ref) {
  var {
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config2.epsilon;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    if (type === "number") {
      return diag2(arr, prec);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0; i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = createArray(N, 0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function diagBig(x, precision) {
    var N = x.length;
    var e0 = abs2(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0; i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAijBig(x);
    while (abs2(Vab[1]) >= abs2(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = createArray(N, 0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config2.epsilon) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs2(denom) <= config2.epsilon) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar2(0.5, atan3(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = createArray(N, 0);
    var Skj = createArray(N, 0);
    for (var k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos2(theta);
    var s = sin2(theta);
    var Ski = createArray(N, bignumber2(0));
    var Skj = createArray(N, bignumber2(0));
    for (var k = 0; k < N; k++) {
      Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i2]), multiplyScalar2(s, Sij[k][j]));
      Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i2]), multiplyScalar2(c, Sij[k][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos2(theta));
    var s = bignumber2(sin2(theta));
    var c2 = multiplyScalar2(c, c);
    var s2 = multiplyScalar2(s, s);
    var Aki = createArray(N, bignumber2(0));
    var Akj = createArray(N, bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i2][i2]), csHij), multiplyScalar2(s2, Hij[j][j]));
    var Ajj = add2(multiplyScalar2(s2, Hij[i2][i2]), csHij, multiplyScalar2(c2, Hij[j][j]));
    for (var k = 0; k < N; k++) {
      Aki[k] = subtract2(multiplyScalar2(c, Hij[i2][k]), multiplyScalar2(s, Hij[j][k]));
      Akj[k] = addScalar2(multiplyScalar2(s, Hij[i2][k]), multiplyScalar2(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = createArray(N, 0);
    var Akj = createArray(N, 0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0; k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (abs2(maxMij) < abs2(Mij[i2][j])) {
          maxMij = abs2(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S) {
    var N = E.length;
    var values = Array(N);
    var vectors = Array(N);
    for (var k = 0; k < N; k++) {
      vectors[k] = Array(N);
    }
    for (var i2 = 0; i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0; j < E.length; j++) {
        if (abs2(E[j]) < abs2(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i2] = E.splice(minID, 1)[0];
      for (var _k5 = 0; _k5 < N; _k5++) {
        vectors[_k5][i2] = S[_k5][minID];
        S[_k5].splice(minID, 1);
      }
    }
    return {
      values,
      vectors
    };
  }
  function createArray(size2, value) {
    var array = new Array(size2);
    for (var i2 = 0; i2 < size2; i2++) {
      array[i2] = value;
    }
    return array;
  }
  return main;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name166 = "eigs";
var dependencies166 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = factory(name166, dependencies166, (_ref) => {
  var {
    config: config2,
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    subtract: subtract2,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2,
    larger: larger2,
    column: column2,
    flatten: flatten3,
    number: number2,
    complex: complex2,
    sqrt: sqrt2,
    diag: diag2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    im: im2,
    re: re2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  var doRealSymetric = createRealSymmetric({
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    column: column2,
    flatten: flatten3,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    complex: complex2,
    multiply: multiply2,
    add: add2
  });
  var doComplexEigs = createComplexEigs({
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    flatten: flatten3,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    qr: qr2,
    inv: inv2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  });
  return typed2("eigs", {
    Array: function Array2(x) {
      var mat = matrix2(x);
      return computeValuesAndVectors(mat);
    },
    "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
      var mat = matrix2(x);
      return computeValuesAndVectors(mat, prec);
    },
    Matrix: function Matrix2(mat) {
      var {
        values,
        vectors
      } = computeValuesAndVectors(mat);
      return {
        values: matrix2(values),
        vectors: matrix2(vectors)
      };
    },
    "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
      var {
        values,
        vectors
      } = computeValuesAndVectors(mat, prec);
      return {
        values: matrix2(values),
        vectors: matrix2(vectors)
      };
    }
  });
  function computeValuesAndVectors(mat, prec) {
    if (prec === void 0) {
      prec = config2.epsilon;
    }
    var size2 = mat.size();
    if (size2.length !== 2 || size2[0] !== size2[1]) {
      throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
    }
    var arr = mat.toArray();
    var N = size2[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymetric(arr, N, prec, _type);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type);
  }
  function isSymmetric(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2; j < N; j++) {
        if (larger2(bignumber2(abs2(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        if (larger2(bignumber2(abs2(im2(arr[i2][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        arr[i2][j] = re2(arr[i2][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        var el = arr[i2][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0; _i < N; _i++) {
        for (var _j = 0; _j < N; _j++) {
          arr[_i][_j] = complex2(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        for (var _j2 = 0; _j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0; _i3 < N; _i3++) {
        for (var _j3 = 0; _j3 < N; _j3++) {
          arr[_i3][_j3] = number2(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/expm.js
var name167 = "expm";
var dependencies167 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = factory(name167, dependencies167, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    identity: identity2,
    inv: inv2,
    multiply: multiply2
  } = _ref;
  return typed2(name167, {
    Matrix: function Matrix2(A) {
      var size2 = A.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
      }
      var n = size2[0];
      var eps = 1e-15;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply2(A, Math.pow(2, -j));
      var N = identity2(n);
      var D = identity2(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i2 = 1; i2 <= q; i2++) {
        if (i2 > 1) {
          AposToI = multiply2(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
        N = add2(N, multiply2(factor, AposToI));
        D = add2(D, multiply2(factor * alternate, AposToI));
      }
      var R = multiply2(inv2(D), N);
      for (var _i = 0; _i < j; _i++) {
        R = multiply2(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var rowSum = 0;
      for (var j = 0; j < n; j++) {
        rowSum += abs2(A.get([i2, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0; k < maxSearchSize; k++) {
      for (var q = 0; q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i2 = 2; i2 <= q; i2++) {
      qfac *= i2;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name168 = "sqrtm";
var dependencies168 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = factory(name168, dependencies168, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    map: map2,
    sqrt: sqrt2,
    subtract: subtract2,
    inv: inv2,
    size: size2,
    max: max2,
    identity: identity2
  } = _ref;
  var _maxIterations = 1e3;
  var _tolerance = 1e-6;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity2(size2(A));
    do {
      var Yk = Y;
      Y = multiply2(0.5, add2(Yk, inv2(Z)));
      Z = multiply2(0.5, add2(Z, inv2(Yk)));
      error = max2(abs2(subtract2(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed2(name168, {
    "Array | Matrix": function ArrayMatrix(A) {
      var size3 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size3.length) {
        case 1:
          if (size3[0] === 1) {
            return map2(A, sqrt2);
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size3) + ")");
          }
        case 2: {
          var rows = size3[0];
          var cols = size3[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size3) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + format2(size3) + ")");
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sylvester.js
var name169 = "sylvester";
var dependencies169 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = factory(name169, dependencies169, (_ref) => {
  var {
    typed: typed2,
    schur: schur2,
    matrixFromColumns: matrixFromColumns2,
    matrix: matrix2,
    multiply: multiply2,
    range: range2,
    concat: concat2,
    transpose: transpose2,
    index: index2,
    subset: subset2,
    add: add2,
    subtract: subtract2,
    identity: identity2,
    lusolve: lusolve2,
    abs: abs2
  } = _ref;
  return typed2(name169, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function ArrayMatrixMatrix(A, B, C) {
      return _sylvester(matrix2(A), B, C);
    },
    "Array, Array, Matrix": function ArrayArrayMatrix(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), C);
    },
    "Array, Matrix, Array": function ArrayMatrixArray(A, B, C) {
      return _sylvester(matrix2(A), B, matrix2(C));
    },
    "Matrix, Array, Matrix": function MatrixArrayMatrix(A, B, C) {
      return _sylvester(A, matrix2(B), C);
    },
    "Matrix, Array, Array": function MatrixArrayArray(A, B, C) {
      return _sylvester(A, matrix2(B), matrix2(C));
    },
    "Matrix, Matrix, Array": function MatrixMatrixArray(A, B, C) {
      return _sylvester(A, B, matrix2(C));
    },
    "Array, Array, Array": function ArrayArrayArray(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), matrix2(C)).toArray();
    }
  });
  function _sylvester(A, B, C) {
    var n = B.size()[0];
    var m = A.size()[0];
    var sA = schur2(A);
    var F = sA.T;
    var U = sA.U;
    var sB = schur2(multiply2(-1, B));
    var G = sB.T;
    var V = sB.U;
    var D = multiply2(multiply2(transpose2(U), C), V);
    var all2 = range2(0, m);
    var y = [];
    var hc = (a, b) => concat2(a, b, 1);
    var vc = (a, b) => concat2(a, b, 0);
    for (var k = 0; k < n; k++) {
      if (k < n - 1 && abs2(subset2(G, index2(k + 1, k))) > 1e-5) {
        var RHS = vc(subset2(D, index2(all2, k)), subset2(D, index2(all2, k + 1)));
        for (var j = 0; j < k; j++) {
          RHS = add2(RHS, vc(multiply2(y[j], subset2(G, index2(j, k))), multiply2(y[j], subset2(G, index2(j, k + 1)))));
        }
        var gkk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k))));
        var gmk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k))));
        var gkm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k + 1))));
        var gmm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k + 1))));
        var LHS = vc(hc(add2(F, gkk), gmk), hc(gkm, add2(F, gmm)));
        var yAux = lusolve2(LHS, RHS);
        y[k] = yAux.subset(index2(range2(0, m), 0));
        y[k + 1] = yAux.subset(index2(range2(m, 2 * m), 0));
        k++;
      } else {
        var _RHS = subset2(D, index2(all2, k));
        for (var _j = 0; _j < k; _j++) {
          _RHS = add2(_RHS, multiply2(y[_j], subset2(G, index2(_j, k))));
        }
        var _gkk = subset2(G, index2(k, k));
        var _LHS = subtract2(F, multiply2(_gkk, identity2(m)));
        y[k] = lusolve2(_LHS, _RHS);
      }
    }
    var Y = matrix2(matrixFromColumns2(...y));
    var X = multiply2(U, multiply2(Y, transpose2(V)));
    return X;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
var name170 = "schur";
var dependencies170 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = factory(name170, dependencies170, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    identity: identity2,
    multiply: multiply2,
    qr: qr2,
    norm: norm2,
    subtract: subtract2
  } = _ref;
  return typed2(name170, {
    Array: function Array2(X) {
      var r = _schur(matrix2(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix2(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A = X;
    var U = identity2(n);
    var k = 0;
    var A0;
    do {
      A0 = A;
      var QR = qr2(A);
      var Q = QR.Q;
      var R = QR.R;
      A = multiply2(R, Q);
      U = multiply2(U, Q);
      if (k++ > 100) {
        break;
      }
    } while (norm2(subtract2(A, A0)) > 1e-4);
    return {
      U,
      T: A
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/lyap.js
var name171 = "lyap";
var dependencies171 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = factory(name171, dependencies171, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    sylvester: sylvester2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return typed2(name171, {
    "Matrix, Matrix": function MatrixMatrix(A, Q) {
      return sylvester2(A, transpose2(A), multiply2(-1, Q));
    },
    "Array, Matrix": function ArrayMatrix(A, Q) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), multiply2(-1, Q));
    },
    "Matrix, Array": function MatrixArray(A, Q) {
      return sylvester2(A, transpose2(matrix2(A)), matrix2(multiply2(-1, Q)));
    },
    "Array, Array": function ArrayArray(A, Q) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), matrix2(multiply2(-1, Q))).toArray();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name172 = "divide";
var dependencies172 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = factory(name172, dependencies172, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    inv: inv2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2("divide", extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, divideScalar2, false);
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, divideScalar2, false);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, divideScalar2, false).valueOf();
    },
    "any, Array | Matrix": function anyArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    }
  }, divideScalar2.signatures));
});

// node_modules/mathjs/lib/esm/function/geometry/distance.js
var name173 = "distance";
var dependencies173 = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "unaryMinus", "sqrt", "abs"];
var createDistance = factory(name173, dependencies173, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    subtract: subtract2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    unaryMinus: unaryMinus2,
    sqrt: sqrt2,
    abs: abs2
  } = _ref;
  return typed2(name173, {
    "Array, Array, Array": function ArrayArrayArray(x, y, z) {
      if (x.length === 2 && y.length === 2 && z.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        var m = divideScalar2(subtract2(z[1], z[0]), subtract2(y[1], y[0]));
        var xCoeff = multiplyScalar2(multiplyScalar2(m, m), y[0]);
        var yCoeff = unaryMinus2(multiplyScalar2(m, y[0]));
        var constant = x[1];
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function ObjectObjectObject(x, y, z) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var m = divideScalar2(subtract2(z.lineTwoPtY, z.lineTwoPtX), subtract2(y.lineOnePtY, y.lineOnePtX));
          var xCoeff = multiplyScalar2(multiplyScalar2(m, m), y.lineOnePtX);
          var yCoeff = unaryMinus2(multiplyScalar2(m, y.lineOnePtX));
          var constant = x.pointX;
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function ArrayArray(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function ObjectObject(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array2(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a = [];
    for (var i2 = 0; i2 < keys.length; i2++) {
      a.push(o[keys[i2]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs2(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
    var den = sqrt2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
    return divideScalar2(num, den);
  }
  function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
    var num = [subtract2(multiplyScalar2(subtract2(y0, y), c), multiplyScalar2(subtract2(z0, z), b)), subtract2(multiplyScalar2(subtract2(z0, z), a), multiplyScalar2(subtract2(x0, x), c)), subtract2(multiplyScalar2(subtract2(x0, x), b), multiplyScalar2(subtract2(y0, y), a))];
    num = sqrt2(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
    var den = sqrt2(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
    return divideScalar2(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff2 = 0;
    for (var i2 = 0; i2 < vectorSize; i2++) {
      diff2 = subtract2(x[i2], y[i2]);
      result = addScalar2(multiplyScalar2(diff2, diff2), result);
    }
    return sqrt2(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i2 = 0; i2 < a.length - 1; i2++) {
      for (var j = i2 + 1; j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i2][0], a[i2][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i2][0], a[i2][1], a[i2][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name174 = "intersect";
var dependencies174 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = factory(name174, dependencies174, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    abs: abs2,
    add: add2,
    addScalar: addScalar2,
    matrix: matrix2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    smaller: smaller2,
    equalScalar: equalScalar2,
    flatten: flatten3,
    isZero: isZero2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix2(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
      return arr === null ? null : matrix2(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten3(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract2(o1, p1b);
    var d2 = subtract2(o2, p2b);
    var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
    if (isZero2(det2))
      return null;
    if (smaller2(abs2(det2), config2.epsilon)) {
      return null;
    }
    var d20o11 = multiplyScalar2(d2[0], o1[1]);
    var d21o10 = multiplyScalar2(d2[1], o1[0]);
    var d20o21 = multiplyScalar2(d2[0], o2[1]);
    var d21o20 = multiplyScalar2(d2[1], o2[0]);
    var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
    return add2(multiply2(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e2, f, g, h, i2, j, k, l) {
    var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
    var add22 = multiplyScalar2(subtract2(e2, f), subtract2(g, h));
    var add3 = multiplyScalar2(subtract2(i2, j), subtract2(k, l));
    return addScalar2(addScalar2(add1, add22), add3);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
    var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
    if (isZero2(denominator))
      return null;
    var ta = divideScalar2(numerator, denominator);
    var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
    var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
    var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
    var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
    var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
    var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
    var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
    if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
    var x1x = multiplyScalar2(x1, x);
    var x2x = multiplyScalar2(x2, x);
    var y1y = multiplyScalar2(y1, y);
    var y2y = multiplyScalar2(y2, y);
    var z1z = multiplyScalar2(z1, z);
    var z2z = multiplyScalar2(z2, z);
    var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
    var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar2(numerator, denominator);
    var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
    var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
    var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
    return [px, py, pz];
  }
});

// node_modules/mathjs/lib/esm/function/probability/combinations.js
var name175 = "combinations";
var dependencies175 = ["typed"];
var createCombinations = factory(name175, dependencies175, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name175, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var nMinusk = n.minus(k);
      var one = new BigNumber2(1);
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i2 = one; i2.lte(nMinusk); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusk.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
    // TODO: implement support for collection in combinations
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/gamma.js
var name176 = "gamma";
var dependencies176 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = factory(name176, dependencies176, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    multiplyScalar: multiplyScalar2,
    pow: pow2,
    BigNumber: _BigNumber,
    Complex: Complex3
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex3(1 - n.re, -n.im);
      var r = new Complex3(Math.PI * n.re, Math.PI * n.im);
      return new Complex3(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex3(n.re - 1, n.im);
    var x = new Complex3(gammaP[0], 0);
    for (var i2 = 1; i2 < gammaP.length; ++i2) {
      var gammaPval = new Complex3(gammaP[i2], 0);
      x = x.add(gammaPval.div(n.add(i2)));
    }
    var t = new Complex3(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed2(name176, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber2(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config2.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod2 = new Big(n);
    var sum2 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum2 += p;
      prod2 = prod2.times(sum2);
    }
    return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
  }
});

// node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name177 = "lgamma";
var dependencies177 = ["Complex", "typed"];
var createLgamma = factory(name177, dependencies177, (_ref) => {
  var {
    Complex: Complex3,
    typed: typed2
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return typed2(name177, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber2() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex3(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex3(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex3(1 - n.re, -n.im));
      return new Complex3(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex3(1, 0).div(z);
    var rzz = rz.div(z);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i2 = 2; i2 < 8; i2++) {
      var tmp = b;
      b = -s * a + coeffs[i2];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
  }
});

// node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name178 = "kldivergence";
var dependencies178 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = factory(name178, dependencies178, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divide: divide2,
    sum: sum2,
    multiply: multiply2,
    map: map2,
    dotDivide: dotDivide2,
    log: log3,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name178, {
    "Array, Array": function ArrayArray(q, p) {
      return _kldiv(matrix2(q), matrix2(p));
    },
    "Matrix, Array": function MatrixArray(q, p) {
      return _kldiv(q, matrix2(p));
    },
    "Array, Matrix": function ArrayMatrix(q, p) {
      return _kldiv(matrix2(q), p);
    },
    "Matrix, Matrix": function MatrixMatrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum2(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum2(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide2(q, sum2(q));
    var pnorm = divide2(p, sum2(p));
    var result = sum2(multiply2(qnorm, map2(dotDivide2(qnorm, pnorm), (x) => log3(x))));
    if (isNumeric2(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});

// node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name179 = "leafCount";
var dependencies179 = ["parse", "typed"];
var createLeafCount = factory(name179, dependencies179, (_ref) => {
  var {
    parse: parse2,
    typed: typed2
  } = _ref;
  function countLeaves(node) {
    var count2 = 0;
    node.forEach((n) => {
      count2 += countLeaves(n);
    });
    return count2 || 1;
  }
  return typed2(name179, {
    Node: function Node2(expr) {
      return countLeaves(expr);
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name180 = "symbolicEqual";
var dependencies180 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = factory(name180, dependencies180, (_ref) => {
  var {
    parse: parse2,
    simplify: simplify2,
    typed: typed2,
    OperatorNode: OperatorNode2
  } = _ref;
  function _symbolicEqual(e1, e2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var diff2 = new OperatorNode2("-", "subtract", [e1, e2]);
    var simplified = simplify2(diff2, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed2(name180, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});

// node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
var createSpeedOfLight = unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = unitFactory("klitzing", "25812.807459304513", "ohm");
var createJosephson = unitFactory("josephson", "4.835978484169836e14 Hz V", "Hz V^-1");
var createBohrRadius = unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name187, valueStr, unitStr) {
  var dependencies187 = ["config", "Unit", "BigNumber"];
  return factory(name187, dependencies187, (_ref) => {
    var {
      config: config2,
      Unit: Unit2,
      BigNumber: BigNumber2
    } = _ref;
    var value = config2.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit2(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name187, value) {
  var dependencies187 = ["config", "BigNumber"];
  return factory(name187, dependencies187, (_ref2) => {
    var {
      config: config2,
      BigNumber: BigNumber2
    } = _ref2;
    return config2.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}

// node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name181 = "column";
var dependencies181 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = factory(name181, dependencies181, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var column2 = createColumn({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name182 = "index";
var dependencies182 = ["Index"];
var createIndexTransform = factory(name182, dependencies182, (_ref) => {
  var {
    Index: Index2
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        arg2.start--;
        arg2.end -= arg2.step > 0 ? 0 : 2;
      } else if (arg2 && arg2.isSet === true) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg2) || isMatrix(arg2)) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isNumber(arg2)) {
        arg2--;
      } else if (isBigNumber(arg2)) {
        arg2 = arg2.toNumber() - 1;
      } else if (typeof arg2 === "string") {
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      args[i2] = arg2;
    }
    var res = new Index2();
    Index2.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name183 = "row";
var dependencies183 = ["typed", "Index", "matrix", "range"];
var createRowTransform = factory(name183, dependencies183, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var row2 = createRow({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name184 = "subset";
var dependencies184 = ["typed", "matrix"];
var createSubsetTransform = factory(name184, dependencies184, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var subset2 = createSubset({
    typed: typed2,
    matrix: matrix2
  });
  return typed2("subset", {
    "...any": function any(args) {
      try {
        return subset2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name185 = "concat";
var dependencies185 = ["typed", "matrix", "isInteger"];
var createConcatTransform = factory(name185, dependencies185, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  var concat2 = createConcat({
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  });
  return typed2("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name186 = "diff";
var dependencies186 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = factory(name186, dependencies186, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  } = _ref;
  var diff2 = createDiff({
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  });
  return typed2(name186, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber = createBigNumberClass({
  config
});
var Complex2 = createComplexClass({});
var e = createE({
  BigNumber,
  config
});
var _false = createFalse({});
var fineStructure = createFineStructure({
  BigNumber,
  config
});
var Fraction2 = createFractionClass({});
var i = createI({
  Complex: Complex2
});
var _Infinity = createInfinity({
  BigNumber,
  config
});
var LN10 = createLN10({
  BigNumber,
  config
});
var LOG10E = createLOG10E({
  BigNumber,
  config
});
var Matrix = createMatrixClass({});
var _NaN = createNaN({
  BigNumber,
  config
});
var _null = createNull({});
var phi = createPhi({
  BigNumber,
  config
});
var Range = createRangeClass({});
var ResultSet = createResultSet({});
var SQRT1_2 = createSQRT1_2({
  BigNumber,
  config
});
var sackurTetrode = createSackurTetrode({
  BigNumber,
  config
});
var tau = createTau({
  BigNumber,
  config
});
var _true = createTrue({});
var version = createVersion({});
var DenseMatrix = createDenseMatrixClass({
  Matrix
});
var efimovFactor = createEfimovFactor({
  BigNumber,
  config
});
var LN2 = createLN2({
  BigNumber,
  config
});
var pi = createPi({
  BigNumber,
  config
});
var replacer = createReplacer({});
var SQRT2 = createSQRT2({
  BigNumber,
  config
});
var typed = createTyped({
  BigNumber,
  Complex: Complex2,
  DenseMatrix,
  Fraction: Fraction2
});
var unaryPlus = createUnaryPlus({
  BigNumber,
  config,
  typed
});
var weakMixingAngle = createWeakMixingAngle({
  BigNumber,
  config
});
var abs = createAbs({
  typed
});
var acos = createAcos({
  Complex: Complex2,
  config,
  typed
});
var acot = createAcot({
  BigNumber,
  typed
});
var acsc = createAcsc({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var addScalar = createAddScalar({
  typed
});
var arg = createArg({
  typed
});
var asech = createAsech({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var asinh = createAsinh({
  typed
});
var atan = createAtan({
  typed
});
var atanh = createAtanh({
  Complex: Complex2,
  config,
  typed
});
var bignumber = createBignumber({
  BigNumber,
  typed
});
var bitNot = createBitNot({
  typed
});
var boolean = createBoolean({
  typed
});
var clone2 = createClone({
  typed
});
var combinations = createCombinations({
  typed
});
var complex = createComplex({
  Complex: Complex2,
  typed
});
var conj = createConj({
  typed
});
var cosh2 = createCosh({
  typed
});
var coth = createCoth({
  BigNumber,
  typed
});
var csc = createCsc({
  BigNumber,
  typed
});
var cube = createCube({
  typed
});
var equalScalar = createEqualScalar({
  config,
  typed
});
var erf = createErf({
  typed
});
var exp = createExp({
  typed
});
var expm1 = createExpm1({
  Complex: Complex2,
  typed
});
var filter = createFilter({
  typed
});
var forEach = createForEach({
  typed
});
var format3 = createFormat({
  typed
});
var getMatrixDataType = createGetMatrixDataType({
  typed
});
var hex = createHex({
  format: format3,
  typed
});
var im = createIm({
  typed
});
var isInteger2 = createIsInteger({
  typed
});
var isNegative = createIsNegative({
  typed
});
var isPositive = createIsPositive({
  typed
});
var isZero = createIsZero({
  typed
});
var LOG2E = createLOG2E({
  BigNumber,
  config
});
var lgamma = createLgamma({
  Complex: Complex2,
  typed
});
var log10 = createLog10({
  Complex: Complex2,
  config,
  typed
});
var log2 = createLog2({
  Complex: Complex2,
  config,
  typed
});
var map = createMap({
  typed
});
var multiplyScalar = createMultiplyScalar({
  typed
});
var not = createNot({
  typed
});
var number = createNumber({
  typed
});
var oct = createOct({
  format: format3,
  typed
});
var pickRandom = createPickRandom({
  config,
  typed
});
var print = createPrint({
  typed
});
var random = createRandom({
  config,
  typed
});
var re = createRe({
  typed
});
var sec = createSec({
  BigNumber,
  typed
});
var sign = createSign({
  BigNumber,
  Fraction: Fraction2,
  complex,
  typed
});
var sin = createSin({
  typed
});
var SparseMatrix = createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed
});
var splitUnit = createSplitUnit({
  typed
});
var square = createSquare({
  typed
});
var string = createString({
  typed
});
var tan = createTan({
  typed
});
var typeOf2 = createTypeOf({
  typed
});
var acosh = createAcosh({
  Complex: Complex2,
  config,
  typed
});
var acsch = createAcsch({
  BigNumber,
  typed
});
var apply = createApply({
  isInteger: isInteger2,
  typed
});
var asec = createAsec({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var bin = createBin({
  format: format3,
  typed
});
var combinationsWithRep = createCombinationsWithRep({
  typed
});
var cos = createCos({
  typed
});
var csch = createCsch({
  BigNumber,
  typed
});
var isNaN2 = createIsNaN({
  typed
});
var isPrime = createIsPrime({
  typed
});
var randomInt = createRandomInt({
  config,
  typed
});
var sech = createSech({
  BigNumber,
  typed
});
var sinh = createSinh({
  typed
});
var sparse = createSparse({
  SparseMatrix,
  typed
});
var sqrt = createSqrt({
  Complex: Complex2,
  config,
  typed
});
var tanh2 = createTanh({
  typed
});
var unaryMinus = createUnaryMinus({
  typed
});
var acoth = createAcoth({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var cot = createCot({
  BigNumber,
  typed
});
var fraction = createFraction({
  Fraction: Fraction2,
  typed
});
var isNumeric = createIsNumeric({
  typed
});
var matrix = createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed
});
var matrixFromFunction = createMatrixFromFunction({
  isZero,
  matrix,
  typed
});
var mod = createMod({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var nthRoot = createNthRoot({
  BigNumber,
  equalScalar,
  matrix,
  typed
});
var numeric = createNumeric({
  bignumber,
  fraction,
  number
});
var or = createOr({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var prod = createProd({
  config,
  multiplyScalar,
  numeric,
  typed
});
var reshape2 = createReshape({
  isInteger: isInteger2,
  matrix,
  typed
});
var size = createSize({
  matrix,
  config,
  typed
});
var smaller = createSmaller({
  DenseMatrix,
  config,
  matrix,
  typed
});
var squeeze2 = createSqueeze({
  matrix,
  typed
});
var subset = createSubset({
  matrix,
  typed
});
var subtract = createSubtract({
  DenseMatrix,
  addScalar,
  equalScalar,
  matrix,
  typed,
  unaryMinus
});
var to = createTo({
  matrix,
  typed
});
var transpose = createTranspose({
  matrix,
  typed
});
var xgcd = createXgcd({
  BigNumber,
  config,
  matrix,
  typed
});
var zeros = createZeros({
  BigNumber,
  config,
  matrix,
  typed
});
var and = createAnd({
  equalScalar,
  matrix,
  not,
  typed,
  zeros
});
var bitAnd = createBitAnd({
  equalScalar,
  matrix,
  typed
});
var bitXor2 = createBitXor({
  DenseMatrix,
  matrix,
  typed
});
var cbrt = createCbrt({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  config,
  isNegative,
  matrix,
  typed,
  unaryMinus
});
var compare = createCompare({
  BigNumber,
  DenseMatrix,
  Fraction: Fraction2,
  config,
  equalScalar,
  matrix,
  typed
});
var compareText = createCompareText({
  matrix,
  typed
});
var concat = createConcat({
  isInteger: isInteger2,
  matrix,
  typed
});
var count = createCount({
  prod,
  size,
  typed
});
var ctranspose = createCtranspose({
  conj,
  transpose,
  typed
});
var diag = createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix,
  typed
});
var divideScalar = createDivideScalar({
  numeric,
  typed
});
var dotDivide = createDotDivide({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  typed
});
var equal = createEqual({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var fft = createFft({
  addScalar,
  divideScalar,
  exp,
  i,
  matrix,
  multiplyScalar,
  tau,
  typed
});
var flatten2 = createFlatten({
  matrix,
  typed
});
var gcd = createGcd({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var hasNumericValue = createHasNumericValue({
  isNumeric,
  typed
});
var hypot = createHypot({
  abs,
  addScalar,
  divideScalar,
  isPositive,
  multiplyScalar,
  smaller,
  sqrt,
  typed
});
var ifft = createIfft({
  conj,
  dotDivide,
  fft,
  typed
});
var kron = createKron({
  matrix,
  multiplyScalar,
  typed
});
var largerEq = createLargerEq({
  DenseMatrix,
  config,
  matrix,
  typed
});
var leftShift = createLeftShift({
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var lsolve = createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var matrixFromColumns = createMatrixFromColumns({
  flatten: flatten2,
  matrix,
  size,
  typed
});
var min = createMin({
  config,
  numeric,
  smaller,
  typed
});
var mode = createMode({
  isNaN: isNaN2,
  isNumeric,
  typed
});
var nthRoots = createNthRoots({
  Complex: Complex2,
  config,
  divideScalar,
  typed
});
var ones = createOnes({
  BigNumber,
  config,
  matrix,
  typed
});
var partitionSelect = createPartitionSelect({
  compare,
  isNaN: isNaN2,
  isNumeric,
  typed
});
var resize2 = createResize({
  config,
  matrix
});
var rightArithShift = createRightArithShift({
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var round = createRound({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var smallerEq = createSmallerEq({
  DenseMatrix,
  config,
  matrix,
  typed
});
var unequal = createUnequal({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  typed
});
var usolve = createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var xor = createXor({
  DenseMatrix,
  matrix,
  typed
});
var add = createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  equalScalar,
  matrix,
  typed
});
var atan2 = createAtan2({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var bitOr = createBitOr({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var catalan = createCatalan({
  addScalar,
  combinations,
  divideScalar,
  isInteger: isInteger2,
  isNegative,
  multiplyScalar,
  typed
});
var compareNatural = createCompareNatural({
  compare,
  typed
});
var cumsum = createCumSum({
  add,
  typed,
  unaryPlus
});
var deepEqual = createDeepEqual({
  equal,
  typed
});
var diff = createDiff({
  matrix,
  number,
  subtract,
  typed
});
var dot = createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed
});
var equalText = createEqualText({
  compareText,
  isZero,
  typed
});
var floor = createFloor({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var identity = createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config,
  matrix,
  typed
});
var invmod = createInvmod({
  BigNumber,
  add,
  config,
  equal,
  isInteger: isInteger2,
  mod,
  smaller,
  typed,
  xgcd
});
var larger = createLarger({
  DenseMatrix,
  config,
  matrix,
  typed
});
var log = createLog({
  Complex: Complex2,
  config,
  divideScalar,
  typed
});
var lsolveAll = createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var matrixFromRows = createMatrixFromRows({
  flatten: flatten2,
  matrix,
  size,
  typed
});
var multiply = createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var qr = createQr({
  addScalar,
  complex,
  conj,
  divideScalar,
  equal,
  identity,
  isZero,
  matrix,
  multiplyScalar,
  sign,
  sqrt,
  subtract,
  typed,
  unaryMinus,
  zeros
});
var range = createRange({
  bignumber,
  matrix,
  config,
  larger,
  largerEq,
  smaller,
  smallerEq,
  typed
});
var rightLogShift = createRightLogShift({
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var setSize = createSetSize({
  compareNatural,
  typed
});
var slu = createSlu({
  SparseMatrix,
  abs,
  add,
  divideScalar,
  larger,
  largerEq,
  multiply,
  subtract,
  transpose,
  typed
});
var sum = createSum({
  add,
  config,
  numeric,
  typed
});
var trace = createTrace({
  add,
  matrix,
  typed
});
var usolveAll = createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var asin = createAsin({
  Complex: Complex2,
  config,
  typed
});
var ceil = createCeil({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var composition = createComposition({
  addScalar,
  combinations,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  larger,
  typed
});
var cross = createCross({
  matrix,
  multiply,
  subtract,
  typed
});
var det = createDet({
  divideScalar,
  isZero,
  matrix,
  multiply,
  subtract,
  typed,
  unaryMinus
});
var distance = createDistance({
  abs,
  addScalar,
  divideScalar,
  multiplyScalar,
  sqrt,
  subtract,
  typed,
  unaryMinus
});
var dotMultiply = createDotMultiply({
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var FibonacciHeap = createFibonacciHeapClass({
  larger,
  smaller
});
var fix = createFix({
  Complex: Complex2,
  DenseMatrix,
  ceil,
  equalScalar,
  floor,
  matrix,
  typed,
  zeros
});
var ImmutableDenseMatrix = createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
});
var Index = createIndexClass({
  ImmutableDenseMatrix
});
var intersect = createIntersect({
  abs,
  add,
  addScalar,
  config,
  divideScalar,
  equalScalar,
  flatten: flatten2,
  isNumeric,
  isZero,
  matrix,
  multiply,
  multiplyScalar,
  smaller,
  subtract,
  typed
});
var lcm = createLcm({
  equalScalar,
  matrix,
  typed
});
var log1p2 = createLog1p({
  Complex: Complex2,
  config,
  divideScalar,
  log,
  typed
});
var max = createMax({
  config,
  larger,
  numeric,
  typed
});
var quantileSeq = createQuantileSeq({
  add,
  compare,
  multiply,
  partitionSelect,
  typed
});
var row = createRow({
  Index,
  matrix,
  range,
  typed
});
var setCartesian = createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setDistinct = createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setIsSubset = createSetIsSubset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setPowerset = createSetPowerset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var sort = createSort({
  compare,
  compareNatural,
  matrix,
  typed
});
var column = createColumn({
  Index,
  matrix,
  range,
  typed
});
var index = createIndex({
  Index,
  typed
});
var inv = createInv({
  abs,
  addScalar,
  det,
  divideScalar,
  identity,
  matrix,
  multiply,
  typed,
  unaryMinus
});
var pinv = createPinv({
  Complex: Complex2,
  add,
  ctranspose,
  deepEqual,
  divideScalar,
  dot,
  dotDivide,
  equal,
  inv,
  matrix,
  multiply,
  typed
});
var pow = createPow({
  Complex: Complex2,
  config,
  fraction,
  identity,
  inv,
  matrix,
  multiply,
  number,
  typed
});
var setDifference = createSetDifference({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setMultiplicity = createSetMultiplicity({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var Spa = createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var sqrtm = createSqrtm({
  abs,
  add,
  identity,
  inv,
  map,
  max,
  multiply,
  size,
  sqrt,
  subtract,
  typed
});
var Unit = createUnitClass({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  abs,
  addScalar,
  config,
  divideScalar,
  equal,
  fix,
  format: format3,
  isNumeric,
  multiplyScalar,
  number,
  pow,
  round,
  subtract
});
var vacuumImpedance = createVacuumImpedance({
  BigNumber,
  Unit,
  config
});
var wienDisplacement = createWienDisplacement({
  BigNumber,
  Unit,
  config
});
var atomicMass = createAtomicMass({
  BigNumber,
  Unit,
  config
});
var bohrMagneton = createBohrMagneton({
  BigNumber,
  Unit,
  config
});
var boltzmann = createBoltzmann({
  BigNumber,
  Unit,
  config
});
var conductanceQuantum = createConductanceQuantum({
  BigNumber,
  Unit,
  config
});
var createUnit = createCreateUnit({
  Unit,
  typed
});
var deuteronMass = createDeuteronMass({
  BigNumber,
  Unit,
  config
});
var dotPow = createDotPow({
  DenseMatrix,
  equalScalar,
  matrix,
  pow,
  typed
});
var electricConstant = createElectricConstant({
  BigNumber,
  Unit,
  config
});
var elementaryCharge = createElementaryCharge({
  BigNumber,
  Unit,
  config
});
var expm = createExpm({
  abs,
  add,
  identity,
  inv,
  multiply,
  typed
});
var faraday = createFaraday({
  BigNumber,
  Unit,
  config
});
var firstRadiation = createFirstRadiation({
  BigNumber,
  Unit,
  config
});
var gamma = createGamma({
  BigNumber,
  Complex: Complex2,
  config,
  multiplyScalar,
  pow,
  typed
});
var gravitationConstant = createGravitationConstant({
  BigNumber,
  Unit,
  config
});
var hartreeEnergy = createHartreeEnergy({
  BigNumber,
  Unit,
  config
});
var klitzing = createKlitzing({
  BigNumber,
  Unit,
  config
});
var loschmidt = createLoschmidt({
  BigNumber,
  Unit,
  config
});
var magneticConstant = createMagneticConstant({
  BigNumber,
  Unit,
  config
});
var molarMass = createMolarMass({
  BigNumber,
  Unit,
  config
});
var molarPlanckConstant = createMolarPlanckConstant({
  BigNumber,
  Unit,
  config
});
var neutronMass = createNeutronMass({
  BigNumber,
  Unit,
  config
});
var nuclearMagneton = createNuclearMagneton({
  BigNumber,
  Unit,
  config
});
var planckCharge = createPlanckCharge({
  BigNumber,
  Unit,
  config
});
var planckLength = createPlanckLength({
  BigNumber,
  Unit,
  config
});
var planckTemperature = createPlanckTemperature({
  BigNumber,
  Unit,
  config
});
var protonMass = createProtonMass({
  BigNumber,
  Unit,
  config
});
var reducedPlanckConstant = createReducedPlanckConstant({
  BigNumber,
  Unit,
  config
});
var rydberg = createRydberg({
  BigNumber,
  Unit,
  config
});
var secondRadiation = createSecondRadiation({
  BigNumber,
  Unit,
  config
});
var setSymDifference = createSetSymDifference({
  Index,
  concat,
  setDifference,
  size,
  subset,
  typed
});
var speedOfLight = createSpeedOfLight({
  BigNumber,
  Unit,
  config
});
var stefanBoltzmann = createStefanBoltzmann({
  BigNumber,
  Unit,
  config
});
var thomsonCrossSection = createThomsonCrossSection({
  BigNumber,
  Unit,
  config
});
var avogadro = createAvogadro({
  BigNumber,
  Unit,
  config
});
var bohrRadius = createBohrRadius({
  BigNumber,
  Unit,
  config
});
var coulomb = createCoulomb({
  BigNumber,
  Unit,
  config
});
var divide = createDivide({
  divideScalar,
  equalScalar,
  inv,
  matrix,
  multiply,
  typed
});
var electronMass = createElectronMass({
  BigNumber,
  Unit,
  config
});
var factorial = createFactorial({
  gamma,
  typed
});
var gravity = createGravity({
  BigNumber,
  Unit,
  config
});
var inverseConductanceQuantum = createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config
});
var lup = createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtract,
  typed,
  unaryMinus
});
var magneticFluxQuantum = createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config
});
var molarMassC12 = createMolarMassC12({
  BigNumber,
  Unit,
  config
});
var multinomial = createMultinomial({
  add,
  divide,
  factorial,
  isInteger: isInteger2,
  isPositive,
  multiply,
  typed
});
var permutations = createPermutations({
  factorial,
  typed
});
var planckMass = createPlanckMass({
  BigNumber,
  Unit,
  config
});
var polynomialRoot = createPolynomialRoot({
  add,
  cbrt,
  divide,
  equalScalar,
  im,
  isZero,
  multiply,
  re,
  sqrt,
  subtract,
  typeOf: typeOf2,
  typed,
  unaryMinus
});
var setIntersect = createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var stirlingS2 = createStirlingS2({
  bignumber,
  addScalar,
  combinations,
  divideScalar,
  factorial,
  isInteger: isInteger2,
  isNegative,
  larger,
  multiplyScalar,
  number,
  pow,
  subtract,
  typed
});
var unit = createUnitFunction({
  Unit,
  typed
});
var bellNumbers = createBellNumbers({
  addScalar,
  isInteger: isInteger2,
  isNegative,
  stirlingS2,
  typed
});
var eigs = createEigs({
  abs,
  add,
  addScalar,
  atan,
  bignumber,
  column,
  complex,
  config,
  cos,
  diag,
  divideScalar,
  dot,
  equal,
  flatten: flatten2,
  im,
  inv,
  larger,
  matrix,
  matrixFromColumns,
  multiply,
  multiplyScalar,
  number,
  qr,
  re,
  sin,
  smaller,
  sqrt,
  subtract,
  typed,
  usolve,
  usolveAll
});
var fermiCoupling = createFermiCoupling({
  BigNumber,
  Unit,
  config
});
var mean = createMean({
  add,
  divide,
  typed
});
var molarVolume = createMolarVolume({
  BigNumber,
  Unit,
  config
});
var planckConstant = createPlanckConstant({
  BigNumber,
  Unit,
  config
});
var quantumOfCirculation = createQuantumOfCirculation({
  BigNumber,
  Unit,
  config
});
var setUnion = createSetUnion({
  Index,
  concat,
  setIntersect,
  setSymDifference,
  size,
  subset,
  typed
});
var variance = createVariance({
  add,
  apply,
  divide,
  isNaN: isNaN2,
  multiply,
  subtract,
  typed
});
var classicalElectronRadius = createClassicalElectronRadius({
  BigNumber,
  Unit,
  config
});
var lusolve = createLusolve({
  DenseMatrix,
  lsolve,
  lup,
  matrix,
  slu,
  typed,
  usolve
});
var median = createMedian({
  add,
  compare,
  divide,
  partitionSelect,
  typed
});
var kldivergence = createKldivergence({
  divide,
  dotDivide,
  isNumeric,
  log,
  map,
  matrix,
  multiply,
  sum,
  typed
});
var mad = createMad({
  abs,
  map,
  median,
  subtract,
  typed
});
var std = createStd({
  map,
  sqrt,
  typed,
  variance
});
var gasConstant = createGasConstant({
  BigNumber,
  Unit,
  config
});
var norm = createNorm({
  abs,
  add,
  conj,
  ctranspose,
  eigs,
  equalScalar,
  larger,
  matrix,
  multiply,
  pow,
  smaller,
  sqrt,
  typed
});
var rotationMatrix = createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config,
  cos,
  matrix,
  multiplyScalar,
  norm,
  sin,
  typed,
  unaryMinus
});
var planckTime = createPlanckTime({
  BigNumber,
  Unit,
  config
});
var schur = createSchur({
  identity,
  matrix,
  multiply,
  norm,
  qr,
  subtract,
  typed
});
var rotate = createRotate({
  multiply,
  rotationMatrix,
  typed
});
var sylvester = createSylvester({
  abs,
  add,
  concat,
  identity,
  index,
  lusolve,
  matrix,
  matrixFromColumns,
  multiply,
  range,
  schur,
  subset,
  subtract,
  transpose,
  typed
});
var lyap = createLyap({
  matrix,
  multiply,
  sylvester,
  transpose,
  typed
});

// node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed
});
var chain = createChain({
  Chain,
  typed
});
var AccessorNode = createAccessorNode({
  Node,
  subset
});
var AssignmentNode = createAssignmentNode({
  matrix,
  Node,
  subset
});
var IndexNode = createIndexNode({
  Node,
  size
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config,
  numeric,
  typed
});
var resolve = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse,
  typed
});
var simplifyConstant = createSimplifyConstant({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config,
  mathWithTransform,
  matrix,
  parse,
  typed
});
var compile = createCompile({
  parse,
  typed
});
var Help = createHelpClass({
  parse
});
var leafCount = createLeafCount({
  parse,
  typed
});
var simplifyCore = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  divide,
  equal,
  isZero,
  multiply,
  parse,
  pow,
  subtract,
  typed
});
var evaluate = createEvaluate({
  parse,
  typed
});
var help = createHelp({
  Help,
  mathWithTransform,
  typed
});
var Parser = createParserClass({
  evaluate
});
var simplify = createSimplify({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse,
  pow,
  resolve,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
var symbolicEqual = createSymbolicEqual({
  OperatorNode,
  parse,
  simplify,
  typed
});
var derivative = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config,
  equal,
  isZero,
  numeric,
  parse,
  simplify,
  typed
});
var parser = createParser({
  Parser,
  typed
});
var rationalize = createRationalize({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse,
  pow,
  simplify,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
_extends(math, {
  e,
  false: _false,
  fineStructure,
  i,
  Infinity: _Infinity,
  LN10,
  LOG10E,
  NaN: _NaN,
  null: _null,
  phi,
  SQRT1_2,
  sackurTetrode,
  tau,
  true: _true,
  "E": e,
  version,
  efimovFactor,
  LN2,
  pi,
  replacer,
  reviver,
  SQRT2,
  typed,
  unaryPlus,
  "PI": pi,
  weakMixingAngle,
  abs,
  acos,
  acot,
  acsc,
  addScalar,
  arg,
  asech,
  asinh,
  atan,
  atanh,
  bignumber,
  bitNot,
  boolean,
  clone: clone2,
  combinations,
  complex,
  conj,
  cosh: cosh2,
  coth,
  csc,
  cube,
  equalScalar,
  erf,
  exp,
  expm1,
  filter,
  forEach,
  format: format3,
  getMatrixDataType,
  hex,
  im,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  lgamma,
  log10,
  log2,
  map,
  multiplyScalar,
  not,
  number,
  oct,
  pickRandom,
  print,
  random,
  re,
  sec,
  sign,
  sin,
  splitUnit,
  square,
  string,
  tan,
  typeOf: typeOf2,
  acosh,
  acsch,
  apply,
  asec,
  bin,
  chain,
  combinationsWithRep,
  cos,
  csch,
  isNaN: isNaN2,
  isPrime,
  randomInt,
  sech,
  sinh,
  sparse,
  sqrt,
  tanh: tanh2,
  unaryMinus,
  acoth,
  cot,
  fraction,
  isNumeric,
  matrix,
  matrixFromFunction,
  mod,
  nthRoot,
  numeric,
  or,
  prod,
  reshape: reshape2,
  size,
  smaller,
  squeeze: squeeze2,
  subset,
  subtract,
  to,
  transpose,
  xgcd,
  zeros,
  and,
  bitAnd,
  bitXor: bitXor2,
  cbrt,
  compare,
  compareText,
  concat,
  count,
  ctranspose,
  diag,
  divideScalar,
  dotDivide,
  equal,
  fft,
  flatten: flatten2,
  gcd,
  hasNumericValue,
  hypot,
  ifft,
  kron,
  largerEq,
  leftShift,
  lsolve,
  matrixFromColumns,
  min,
  mode,
  nthRoots,
  ones,
  partitionSelect,
  resize: resize2,
  rightArithShift,
  round,
  smallerEq,
  unequal,
  usolve,
  xor,
  add,
  atan2,
  bitOr,
  catalan,
  compareNatural,
  cumsum,
  deepEqual,
  diff,
  dot,
  equalText,
  floor,
  identity,
  invmod,
  larger,
  log,
  lsolveAll,
  matrixFromRows,
  multiply,
  qr,
  range,
  rightLogShift,
  setSize,
  slu,
  sum,
  trace,
  usolveAll,
  asin,
  ceil,
  composition,
  cross,
  det,
  distance,
  dotMultiply,
  fix,
  intersect,
  lcm,
  log1p: log1p2,
  max,
  quantileSeq,
  row,
  setCartesian,
  setDistinct,
  setIsSubset,
  setPowerset,
  sort,
  column,
  index,
  inv,
  pinv,
  pow,
  setDifference,
  setMultiplicity,
  sqrtm,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  createUnit,
  deuteronMass,
  dotPow,
  electricConstant,
  elementaryCharge,
  expm,
  faraday,
  firstRadiation,
  gamma,
  gravitationConstant,
  hartreeEnergy,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  reducedPlanckConstant,
  rydberg,
  secondRadiation,
  setSymDifference,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  coulomb,
  divide,
  electronMass,
  factorial,
  gravity,
  inverseConductanceQuantum,
  lup,
  magneticFluxQuantum,
  molarMassC12,
  multinomial,
  parse,
  permutations,
  planckMass,
  polynomialRoot,
  resolve,
  setIntersect,
  simplifyConstant,
  stirlingS2,
  unit,
  bellNumbers,
  compile,
  eigs,
  fermiCoupling,
  leafCount,
  mean,
  molarVolume,
  planckConstant,
  quantumOfCirculation,
  setUnion,
  simplifyCore,
  variance,
  classicalElectronRadius,
  evaluate,
  help,
  lusolve,
  median,
  simplify,
  symbolicEqual,
  derivative,
  kldivergence,
  mad,
  parser,
  rationalize,
  std,
  gasConstant,
  norm,
  rotationMatrix,
  planckTime,
  schur,
  rotate,
  sylvester,
  lyap,
  config
});
_extends(mathWithTransform, math, {
  filter: createFilterTransform({
    typed
  }),
  forEach: createForEachTransform({
    typed
  }),
  map: createMapTransform({
    typed
  }),
  apply: createApplyTransform({
    isInteger: isInteger2,
    typed
  }),
  diff: createDiffTransform({
    bignumber,
    matrix,
    number,
    subtract,
    typed
  }),
  subset: createSubsetTransform({
    matrix,
    typed
  }),
  concat: createConcatTransform({
    isInteger: isInteger2,
    matrix,
    typed
  }),
  max: createMaxTransform({
    config,
    larger,
    numeric,
    typed
  }),
  min: createMinTransform({
    config,
    numeric,
    smaller,
    typed
  }),
  range: createRangeTransform({
    bignumber,
    matrix,
    config,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  }),
  sum: createSumTransform({
    add,
    config,
    numeric,
    typed
  }),
  cumsum: createCumSumTransform({
    add,
    typed,
    unaryPlus
  }),
  row: createRowTransform({
    Index,
    matrix,
    range,
    typed
  }),
  column: createColumnTransform({
    Index,
    matrix,
    range,
    typed
  }),
  index: createIndexTransform({
    Index
  }),
  mean: createMeanTransform({
    add,
    divide,
    typed
  }),
  variance: createVarianceTransform({
    add,
    apply,
    divide,
    isNaN: isNaN2,
    multiply,
    subtract,
    typed
  }),
  std: createStdTransform({
    map,
    sqrt,
    typed,
    variance
  })
});
_extends(classes, {
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  AccessorNode,
  AssignmentNode,
  IndexNode,
  FibonacciHeap,
  ImmutableDenseMatrix,
  Index,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBigNumberClass.generated.js
var BigNumberDependencies = {
  createBigNumberClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesComplexClass.generated.js
var ComplexDependencies = {
  createComplexClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixClass.generated.js
var MatrixDependencies = {
  createMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDenseMatrixClass.generated.js
var DenseMatrixDependencies = {
  MatrixDependencies,
  createDenseMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFractionClass.generated.js
var FractionDependencies = {
  createFractionClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTyped.generated.js
var typedDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  DenseMatrixDependencies,
  FractionDependencies,
  createTyped
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAbs.generated.js
var absDependencies = {
  typedDependencies,
  createAbs
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNode.generated.js
var NodeDependencies = {
  createNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEqualScalar.generated.js
var equalScalarDependencies = {
  typedDependencies,
  createEqualScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSparseMatrixClass.generated.js
var SparseMatrixDependencies = {
  MatrixDependencies,
  equalScalarDependencies,
  typedDependencies,
  createSparseMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrix.generated.js
var matrixDependencies = {
  DenseMatrixDependencies,
  MatrixDependencies,
  SparseMatrixDependencies,
  typedDependencies,
  createMatrix
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubset.generated.js
var subsetDependencies = {
  matrixDependencies,
  typedDependencies,
  createSubset
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAccessorNode.generated.js
var AccessorNodeDependencies = {
  NodeDependencies,
  subsetDependencies,
  createAccessorNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcos.generated.js
var acosDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAcos
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcosh.generated.js
var acoshDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAcosh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcot.generated.js
var acotDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createAcot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcoth.generated.js
var acothDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAcoth
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcsc.generated.js
var acscDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAcsc
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcsch.generated.js
var acschDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createAcsch
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAddScalar.generated.js
var addScalarDependencies = {
  typedDependencies,
  createAddScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAdd.generated.js
var addDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  addScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createAdd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNot.generated.js
var notDependencies = {
  typedDependencies,
  createNot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesZeros.generated.js
var zerosDependencies = {
  BigNumberDependencies,
  matrixDependencies,
  typedDependencies,
  createZeros
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAnd.generated.js
var andDependencies = {
  equalScalarDependencies,
  matrixDependencies,
  notDependencies,
  typedDependencies,
  zerosDependencies,
  createAnd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsInteger.generated.js
var isIntegerDependencies = {
  typedDependencies,
  createIsInteger
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesApply.generated.js
var applyDependencies = {
  isIntegerDependencies,
  typedDependencies,
  createApply
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesApplyTransform.generated.js
var applyTransformDependencies = {
  isIntegerDependencies,
  typedDependencies,
  createApplyTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesArg.generated.js
var argDependencies = {
  typedDependencies,
  createArg
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesArrayNode.generated.js
var ArrayNodeDependencies = {
  NodeDependencies,
  createArrayNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsec.generated.js
var asecDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAsec
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsech.generated.js
var asechDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAsech
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsin.generated.js
var asinDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAsin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsinh.generated.js
var asinhDependencies = {
  typedDependencies,
  createAsinh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAssignmentNode.generated.js
var AssignmentNodeDependencies = {
  matrixDependencies,
  NodeDependencies,
  subsetDependencies,
  createAssignmentNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtan.generated.js
var atanDependencies = {
  typedDependencies,
  createAtan
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtan2.generated.js
var atan2Dependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createAtan2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtanh.generated.js
var atanhDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAtanh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBignumber.generated.js
var bignumberDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createBignumber
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFraction.generated.js
var fractionDependencies = {
  FractionDependencies,
  typedDependencies,
  createFraction
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNumber.generated.js
var numberDependencies = {
  typedDependencies,
  createNumber
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNumeric.generated.js
var numericDependencies = {
  bignumberDependencies,
  fractionDependencies,
  numberDependencies,
  createNumeric
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDivideScalar.generated.js
var divideScalarDependencies = {
  numericDependencies,
  typedDependencies,
  createDivideScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEqual.generated.js
var equalDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createEqual
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRound.generated.js
var roundDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createRound
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCeil.generated.js
var ceilDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  roundDependencies,
  typedDependencies,
  zerosDependencies,
  createCeil
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFloor.generated.js
var floorDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  roundDependencies,
  typedDependencies,
  zerosDependencies,
  createFloor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFix.generated.js
var fixDependencies = {
  ComplexDependencies,
  DenseMatrixDependencies,
  ceilDependencies,
  equalScalarDependencies,
  floorDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createFix
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFormat.generated.js
var formatDependencies = {
  typedDependencies,
  createFormat
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsNumeric.generated.js
var isNumericDependencies = {
  typedDependencies,
  createIsNumeric
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMultiplyScalar.generated.js
var multiplyScalarDependencies = {
  typedDependencies,
  createMultiplyScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIdentity.generated.js
var identityDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createIdentity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsZero.generated.js
var isZeroDependencies = {
  typedDependencies,
  createIsZero
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConj.generated.js
var conjDependencies = {
  typedDependencies,
  createConj
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSize.generated.js
var sizeDependencies = {
  matrixDependencies,
  typedDependencies,
  createSize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDot.generated.js
var dotDependencies = {
  addScalarDependencies,
  conjDependencies,
  multiplyScalarDependencies,
  sizeDependencies,
  typedDependencies,
  createDot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMultiply.generated.js
var multiplyDependencies = {
  addScalarDependencies,
  dotDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createMultiply
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnaryMinus.generated.js
var unaryMinusDependencies = {
  typedDependencies,
  createUnaryMinus
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubtract.generated.js
var subtractDependencies = {
  DenseMatrixDependencies,
  addScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createSubtract
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDet.generated.js
var detDependencies = {
  divideScalarDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createDet
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInv.generated.js
var invDependencies = {
  absDependencies,
  addScalarDependencies,
  detDependencies,
  divideScalarDependencies,
  identityDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createInv
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPow.generated.js
var powDependencies = {
  ComplexDependencies,
  fractionDependencies,
  identityDependencies,
  invDependencies,
  matrixDependencies,
  multiplyDependencies,
  numberDependencies,
  typedDependencies,
  createPow
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnitClass.generated.js
var UnitDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  FractionDependencies,
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  equalDependencies,
  fixDependencies,
  formatDependencies,
  isNumericDependencies,
  multiplyScalarDependencies,
  numberDependencies,
  powDependencies,
  roundDependencies,
  subtractDependencies,
  createUnitClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtomicMass.generated.js
var atomicMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createAtomicMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAvogadro.generated.js
var avogadroDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createAvogadro
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsNegative.generated.js
var isNegativeDependencies = {
  typedDependencies,
  createIsNegative
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCombinations.generated.js
var combinationsDependencies = {
  typedDependencies,
  createCombinations
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGamma.generated.js
var gammaDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  multiplyScalarDependencies,
  powDependencies,
  typedDependencies,
  createGamma
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFactorial.generated.js
var factorialDependencies = {
  gammaDependencies,
  typedDependencies,
  createFactorial
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLarger.generated.js
var largerDependencies = {
  DenseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createLarger
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStirlingS2.generated.js
var stirlingS2Dependencies = {
  bignumberDependencies,
  addScalarDependencies,
  combinationsDependencies,
  divideScalarDependencies,
  factorialDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  largerDependencies,
  multiplyScalarDependencies,
  numberDependencies,
  powDependencies,
  subtractDependencies,
  typedDependencies,
  createStirlingS2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBellNumbers.generated.js
var bellNumbersDependencies = {
  addScalarDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  stirlingS2Dependencies,
  typedDependencies,
  createBellNumbers
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBin.generated.js
var binDependencies = {
  formatDependencies,
  typedDependencies,
  createBin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitAnd.generated.js
var bitAndDependencies = {
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createBitAnd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitNot.generated.js
var bitNotDependencies = {
  typedDependencies,
  createBitNot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitOr.generated.js
var bitOrDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createBitOr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitXor.generated.js
var bitXorDependencies = {
  DenseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createBitXor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesResultSet.generated.js
var ResultSetDependencies = {
  createResultSet
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBlockNode.generated.js
var BlockNodeDependencies = {
  NodeDependencies,
  ResultSetDependencies,
  createBlockNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBohrMagneton.generated.js
var bohrMagnetonDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createBohrMagneton
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBohrRadius.generated.js
var bohrRadiusDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createBohrRadius
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBoltzmann.generated.js
var boltzmannDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createBoltzmann
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBoolean.generated.js
var booleanDependencies = {
  typedDependencies,
  createBoolean
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCatalan.generated.js
var catalanDependencies = {
  addScalarDependencies,
  combinationsDependencies,
  divideScalarDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createCatalan
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCbrt.generated.js
var cbrtDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  FractionDependencies,
  isNegativeDependencies,
  matrixDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createCbrt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesChainClass.generated.js
var ChainDependencies = {
  typedDependencies,
  createChainClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesChain.generated.js
var chainDependencies = {
  ChainDependencies,
  typedDependencies,
  createChain
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesClassicalElectronRadius.generated.js
var classicalElectronRadiusDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createClassicalElectronRadius
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesClone.generated.js
var cloneDependencies = {
  typedDependencies,
  createClone
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSmaller.generated.js
var smallerDependencies = {
  DenseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createSmaller
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesImmutableDenseMatrixClass.generated.js
var ImmutableDenseMatrixDependencies = {
  DenseMatrixDependencies,
  smallerDependencies,
  createImmutableDenseMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndexClass.generated.js
var IndexDependencies = {
  ImmutableDenseMatrixDependencies,
  createIndexClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLargerEq.generated.js
var largerEqDependencies = {
  DenseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createLargerEq
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSmallerEq.generated.js
var smallerEqDependencies = {
  DenseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createSmallerEq
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRange.generated.js
var rangeDependencies = {
  bignumberDependencies,
  matrixDependencies,
  largerDependencies,
  largerEqDependencies,
  smallerDependencies,
  smallerEqDependencies,
  typedDependencies,
  createRange
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesColumn.generated.js
var columnDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createColumn
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesColumnTransform.generated.js
var columnTransformDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createColumnTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCombinationsWithRep.generated.js
var combinationsWithRepDependencies = {
  typedDependencies,
  createCombinationsWithRep
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompare.generated.js
var compareDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  FractionDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createCompare
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompareNatural.generated.js
var compareNaturalDependencies = {
  compareDependencies,
  typedDependencies,
  createCompareNatural
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompareText.generated.js
var compareTextDependencies = {
  matrixDependencies,
  typedDependencies,
  createCompareText
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConditionalNode.generated.js
var ConditionalNodeDependencies = {
  NodeDependencies,
  createConditionalNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConstantNode.generated.js
var ConstantNodeDependencies = {
  NodeDependencies,
  createConstantNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFunctionAssignmentNode.generated.js
var FunctionAssignmentNodeDependencies = {
  NodeDependencies,
  typedDependencies,
  createFunctionAssignmentNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSymbolNode.generated.js
var SymbolNodeDependencies = {
  UnitDependencies,
  NodeDependencies,
  createSymbolNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFunctionNode.generated.js
var FunctionNodeDependencies = {
  NodeDependencies,
  SymbolNodeDependencies,
  createFunctionNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndexNode.generated.js
var IndexNodeDependencies = {
  NodeDependencies,
  sizeDependencies,
  createIndexNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesObjectNode.generated.js
var ObjectNodeDependencies = {
  NodeDependencies,
  createObjectNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOperatorNode.generated.js
var OperatorNodeDependencies = {
  NodeDependencies,
  createOperatorNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParenthesisNode.generated.js
var ParenthesisNodeDependencies = {
  NodeDependencies,
  createParenthesisNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRangeNode.generated.js
var RangeNodeDependencies = {
  NodeDependencies,
  createRangeNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRelationalNode.generated.js
var RelationalNodeDependencies = {
  NodeDependencies,
  createRelationalNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParse.generated.js
var parseDependencies = {
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  AssignmentNodeDependencies,
  BlockNodeDependencies,
  ConditionalNodeDependencies,
  ConstantNodeDependencies,
  FunctionAssignmentNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  RangeNodeDependencies,
  RelationalNodeDependencies,
  SymbolNodeDependencies,
  numericDependencies,
  typedDependencies,
  createParse
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompile.generated.js
var compileDependencies = {
  parseDependencies,
  typedDependencies,
  createCompile
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesComplex.generated.js
var complexDependencies = {
  ComplexDependencies,
  typedDependencies,
  createComplex
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsPositive.generated.js
var isPositiveDependencies = {
  typedDependencies,
  createIsPositive
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesComposition.generated.js
var compositionDependencies = {
  addScalarDependencies,
  combinationsDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  isPositiveDependencies,
  largerDependencies,
  typedDependencies,
  createComposition
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConcat.generated.js
var concatDependencies = {
  isIntegerDependencies,
  matrixDependencies,
  typedDependencies,
  createConcat
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConcatTransform.generated.js
var concatTransformDependencies = {
  isIntegerDependencies,
  matrixDependencies,
  typedDependencies,
  createConcatTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConductanceQuantum.generated.js
var conductanceQuantumDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createConductanceQuantum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCos.generated.js
var cosDependencies = {
  typedDependencies,
  createCos
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCosh.generated.js
var coshDependencies = {
  typedDependencies,
  createCosh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCot.generated.js
var cotDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCoth.generated.js
var cothDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCoth
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCoulomb.generated.js
var coulombDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createCoulomb
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesProd.generated.js
var prodDependencies = {
  multiplyScalarDependencies,
  numericDependencies,
  typedDependencies,
  createProd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCount.generated.js
var countDependencies = {
  prodDependencies,
  sizeDependencies,
  typedDependencies,
  createCount
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCreateUnit.generated.js
var createUnitDependencies = {
  UnitDependencies,
  typedDependencies,
  createCreateUnit
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCross.generated.js
var crossDependencies = {
  matrixDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  createCross
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCsc.generated.js
var cscDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCsc
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCsch.generated.js
var cschDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCsch
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTranspose.generated.js
var transposeDependencies = {
  matrixDependencies,
  typedDependencies,
  createTranspose
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCtranspose.generated.js
var ctransposeDependencies = {
  conjDependencies,
  transposeDependencies,
  typedDependencies,
  createCtranspose
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCube.generated.js
var cubeDependencies = {
  typedDependencies,
  createCube
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnaryPlus.generated.js
var unaryPlusDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createUnaryPlus
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCumSum.generated.js
var cumsumDependencies = {
  addDependencies,
  typedDependencies,
  unaryPlusDependencies,
  createCumSum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCumSumTransform.generated.js
var cumsumTransformDependencies = {
  addDependencies,
  typedDependencies,
  unaryPlusDependencies,
  createCumSumTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDeepEqual.generated.js
var deepEqualDependencies = {
  equalDependencies,
  typedDependencies,
  createDeepEqual
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDivide.generated.js
var divideDependencies = {
  divideScalarDependencies,
  equalScalarDependencies,
  invDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  createDivide
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesResolve.generated.js
var resolveDependencies = {
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  parseDependencies,
  typedDependencies,
  createResolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSimplifyConstant.generated.js
var simplifyConstantDependencies = {
  bignumberDependencies,
  fractionDependencies,
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  SymbolNodeDependencies,
  matrixDependencies,
  parseDependencies,
  typedDependencies,
  createSimplifyConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSimplifyCore.generated.js
var simplifyCoreDependencies = {
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  addDependencies,
  divideDependencies,
  equalDependencies,
  isZeroDependencies,
  multiplyDependencies,
  parseDependencies,
  powDependencies,
  subtractDependencies,
  typedDependencies,
  createSimplifyCore
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSimplify.generated.js
var simplifyDependencies = {
  bignumberDependencies,
  fractionDependencies,
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  addDependencies,
  divideDependencies,
  equalDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  parseDependencies,
  powDependencies,
  resolveDependencies,
  simplifyConstantDependencies,
  simplifyCoreDependencies,
  subtractDependencies,
  typedDependencies,
  createSimplify
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDerivative.generated.js
var derivativeDependencies = {
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  equalDependencies,
  isZeroDependencies,
  numericDependencies,
  parseDependencies,
  simplifyDependencies,
  typedDependencies,
  createDerivative
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDeuteronMass.generated.js
var deuteronMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createDeuteronMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDiag.generated.js
var diagDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createDiag
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDiff.generated.js
var diffDependencies = {
  matrixDependencies,
  numberDependencies,
  subtractDependencies,
  typedDependencies,
  createDiff
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDiffTransform.generated.js
var diffTransformDependencies = {
  bignumberDependencies,
  matrixDependencies,
  numberDependencies,
  subtractDependencies,
  typedDependencies,
  createDiffTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSqrt.generated.js
var sqrtDependencies = {
  ComplexDependencies,
  typedDependencies,
  createSqrt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDistance.generated.js
var distanceDependencies = {
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  multiplyScalarDependencies,
  sqrtDependencies,
  subtractDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createDistance
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDotDivide.generated.js
var dotDivideDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createDotDivide
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDotMultiply.generated.js
var dotMultiplyDependencies = {
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createDotMultiply
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDotPow.generated.js
var dotPowDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  powDependencies,
  typedDependencies,
  createDotPow
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesE.generated.js
var eDependencies = {
  BigNumberDependencies,
  createE
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEfimovFactor.generated.js
var efimovFactorDependencies = {
  BigNumberDependencies,
  createEfimovFactor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFlatten.generated.js
var flattenDependencies = {
  matrixDependencies,
  typedDependencies,
  createFlatten
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIm.generated.js
var imDependencies = {
  typedDependencies,
  createIm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixFromColumns.generated.js
var matrixFromColumnsDependencies = {
  flattenDependencies,
  matrixDependencies,
  sizeDependencies,
  typedDependencies,
  createMatrixFromColumns
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSign.generated.js
var signDependencies = {
  BigNumberDependencies,
  FractionDependencies,
  complexDependencies,
  typedDependencies,
  createSign
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQr.generated.js
var qrDependencies = {
  addScalarDependencies,
  complexDependencies,
  conjDependencies,
  divideScalarDependencies,
  equalDependencies,
  identityDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  signDependencies,
  sqrtDependencies,
  subtractDependencies,
  typedDependencies,
  unaryMinusDependencies,
  zerosDependencies,
  createQr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRe.generated.js
var reDependencies = {
  typedDependencies,
  createRe
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSin.generated.js
var sinDependencies = {
  typedDependencies,
  createSin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUsolve.generated.js
var usolveDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractDependencies,
  typedDependencies,
  createUsolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUsolveAll.generated.js
var usolveAllDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractDependencies,
  typedDependencies,
  createUsolveAll
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEigs.generated.js
var eigsDependencies = {
  absDependencies,
  addDependencies,
  addScalarDependencies,
  atanDependencies,
  bignumberDependencies,
  columnDependencies,
  complexDependencies,
  cosDependencies,
  diagDependencies,
  divideScalarDependencies,
  dotDependencies,
  equalDependencies,
  flattenDependencies,
  imDependencies,
  invDependencies,
  largerDependencies,
  matrixDependencies,
  matrixFromColumnsDependencies,
  multiplyDependencies,
  multiplyScalarDependencies,
  numberDependencies,
  qrDependencies,
  reDependencies,
  sinDependencies,
  smallerDependencies,
  sqrtDependencies,
  subtractDependencies,
  typedDependencies,
  usolveDependencies,
  usolveAllDependencies,
  createEigs
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesElectricConstant.generated.js
var electricConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createElectricConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesElectronMass.generated.js
var electronMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createElectronMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesElementaryCharge.generated.js
var elementaryChargeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createElementaryCharge
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEqualText.generated.js
var equalTextDependencies = {
  compareTextDependencies,
  isZeroDependencies,
  typedDependencies,
  createEqualText
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesErf.generated.js
var erfDependencies = {
  typedDependencies,
  createErf
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEvaluate.generated.js
var evaluateDependencies = {
  parseDependencies,
  typedDependencies,
  createEvaluate
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesExp.generated.js
var expDependencies = {
  typedDependencies,
  createExp
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesExpm.generated.js
var expmDependencies = {
  absDependencies,
  addDependencies,
  identityDependencies,
  invDependencies,
  multiplyDependencies,
  typedDependencies,
  createExpm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesExpm1.generated.js
var expm1Dependencies = {
  ComplexDependencies,
  typedDependencies,
  createExpm1
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFalse.generated.js
var falseDependencies = {
  createFalse
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFaraday.generated.js
var faradayDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createFaraday
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFermiCoupling.generated.js
var fermiCouplingDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createFermiCoupling
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesI.generated.js
var iDependencies = {
  ComplexDependencies,
  createI
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTau.generated.js
var tauDependencies = {
  BigNumberDependencies,
  createTau
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFft.generated.js
var fftDependencies = {
  addScalarDependencies,
  divideScalarDependencies,
  expDependencies,
  iDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  tauDependencies,
  typedDependencies,
  createFft
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFibonacciHeapClass.generated.js
var FibonacciHeapDependencies = {
  largerDependencies,
  smallerDependencies,
  createFibonacciHeapClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFilter.generated.js
var filterDependencies = {
  typedDependencies,
  createFilter
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFilterTransform.generated.js
var filterTransformDependencies = {
  typedDependencies,
  createFilterTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFineStructure.generated.js
var fineStructureDependencies = {
  BigNumberDependencies,
  createFineStructure
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFirstRadiation.generated.js
var firstRadiationDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createFirstRadiation
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesForEach.generated.js
var forEachDependencies = {
  typedDependencies,
  createForEach
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesForEachTransform.generated.js
var forEachTransformDependencies = {
  typedDependencies,
  createForEachTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGasConstant.generated.js
var gasConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createGasConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGcd.generated.js
var gcdDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createGcd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGetMatrixDataType.generated.js
var getMatrixDataTypeDependencies = {
  typedDependencies,
  createGetMatrixDataType
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGravitationConstant.generated.js
var gravitationConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createGravitationConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGravity.generated.js
var gravityDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createGravity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHartreeEnergy.generated.js
var hartreeEnergyDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createHartreeEnergy
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHasNumericValue.generated.js
var hasNumericValueDependencies = {
  isNumericDependencies,
  typedDependencies,
  createHasNumericValue
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHelpClass.generated.js
var HelpDependencies = {
  parseDependencies,
  createHelpClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHelp.generated.js
var helpDependencies = {
  HelpDependencies,
  typedDependencies,
  createHelp
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHex.generated.js
var hexDependencies = {
  formatDependencies,
  typedDependencies,
  createHex
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHypot.generated.js
var hypotDependencies = {
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  isPositiveDependencies,
  multiplyScalarDependencies,
  smallerDependencies,
  sqrtDependencies,
  typedDependencies,
  createHypot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIfft.generated.js
var ifftDependencies = {
  conjDependencies,
  dotDivideDependencies,
  fftDependencies,
  typedDependencies,
  createIfft
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndex.generated.js
var indexDependencies = {
  IndexDependencies,
  typedDependencies,
  createIndex
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndexTransform.generated.js
var indexTransformDependencies = {
  IndexDependencies,
  createIndexTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInfinity.generated.js
var InfinityDependencies = {
  BigNumberDependencies,
  createInfinity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIntersect.generated.js
var intersectDependencies = {
  absDependencies,
  addDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  flattenDependencies,
  isNumericDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  multiplyScalarDependencies,
  smallerDependencies,
  subtractDependencies,
  typedDependencies,
  createIntersect
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInverseConductanceQuantum.generated.js
var inverseConductanceQuantumDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createInverseConductanceQuantum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMod.generated.js
var modDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createMod
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesXgcd.generated.js
var xgcdDependencies = {
  BigNumberDependencies,
  matrixDependencies,
  typedDependencies,
  createXgcd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInvmod.generated.js
var invmodDependencies = {
  BigNumberDependencies,
  addDependencies,
  equalDependencies,
  isIntegerDependencies,
  modDependencies,
  smallerDependencies,
  typedDependencies,
  xgcdDependencies,
  createInvmod
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsNaN.generated.js
var isNaNDependencies = {
  typedDependencies,
  createIsNaN
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsPrime.generated.js
var isPrimeDependencies = {
  typedDependencies,
  createIsPrime
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog.generated.js
var logDependencies = {
  ComplexDependencies,
  divideScalarDependencies,
  typedDependencies,
  createLog
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMap.generated.js
var mapDependencies = {
  typedDependencies,
  createMap
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSum.generated.js
var sumDependencies = {
  addDependencies,
  numericDependencies,
  typedDependencies,
  createSum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesKldivergence.generated.js
var kldivergenceDependencies = {
  divideDependencies,
  dotDivideDependencies,
  isNumericDependencies,
  logDependencies,
  mapDependencies,
  matrixDependencies,
  multiplyDependencies,
  sumDependencies,
  typedDependencies,
  createKldivergence
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesKlitzing.generated.js
var klitzingDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createKlitzing
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesKron.generated.js
var kronDependencies = {
  matrixDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createKron
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLN10.generated.js
var LN10Dependencies = {
  BigNumberDependencies,
  createLN10
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLN2.generated.js
var LN2Dependencies = {
  BigNumberDependencies,
  createLN2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLOG10E.generated.js
var LOG10EDependencies = {
  BigNumberDependencies,
  createLOG10E
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLOG2E.generated.js
var LOG2EDependencies = {
  BigNumberDependencies,
  createLOG2E
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLcm.generated.js
var lcmDependencies = {
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createLcm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLeafCount.generated.js
var leafCountDependencies = {
  parseDependencies,
  typedDependencies,
  createLeafCount
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLeftShift.generated.js
var leftShiftDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createLeftShift
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLgamma.generated.js
var lgammaDependencies = {
  ComplexDependencies,
  typedDependencies,
  createLgamma
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog10.generated.js
var log10Dependencies = {
  ComplexDependencies,
  typedDependencies,
  createLog10
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog1p.generated.js
var log1pDependencies = {
  ComplexDependencies,
  divideScalarDependencies,
  logDependencies,
  typedDependencies,
  createLog1p
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog2.generated.js
var log2Dependencies = {
  ComplexDependencies,
  typedDependencies,
  createLog2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLoschmidt.generated.js
var loschmidtDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createLoschmidt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLsolve.generated.js
var lsolveDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractDependencies,
  typedDependencies,
  createLsolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLsolveAll.generated.js
var lsolveAllDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractDependencies,
  typedDependencies,
  createLsolveAll
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSpaClass.generated.js
var SpaDependencies = {
  FibonacciHeapDependencies,
  addScalarDependencies,
  equalScalarDependencies,
  createSpaClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLup.generated.js
var lupDependencies = {
  DenseMatrixDependencies,
  SpaDependencies,
  SparseMatrixDependencies,
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  largerDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createLup
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSlu.generated.js
var sluDependencies = {
  SparseMatrixDependencies,
  absDependencies,
  addDependencies,
  divideScalarDependencies,
  largerDependencies,
  largerEqDependencies,
  multiplyDependencies,
  subtractDependencies,
  transposeDependencies,
  typedDependencies,
  createSlu
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLusolve.generated.js
var lusolveDependencies = {
  DenseMatrixDependencies,
  lsolveDependencies,
  lupDependencies,
  matrixDependencies,
  sluDependencies,
  typedDependencies,
  usolveDependencies,
  createLusolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNorm.generated.js
var normDependencies = {
  absDependencies,
  addDependencies,
  conjDependencies,
  ctransposeDependencies,
  eigsDependencies,
  equalScalarDependencies,
  largerDependencies,
  matrixDependencies,
  multiplyDependencies,
  powDependencies,
  smallerDependencies,
  sqrtDependencies,
  typedDependencies,
  createNorm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSchur.generated.js
var schurDependencies = {
  identityDependencies,
  matrixDependencies,
  multiplyDependencies,
  normDependencies,
  qrDependencies,
  subtractDependencies,
  typedDependencies,
  createSchur
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSylvester.generated.js
var sylvesterDependencies = {
  absDependencies,
  addDependencies,
  concatDependencies,
  identityDependencies,
  indexDependencies,
  lusolveDependencies,
  matrixDependencies,
  matrixFromColumnsDependencies,
  multiplyDependencies,
  rangeDependencies,
  schurDependencies,
  subsetDependencies,
  subtractDependencies,
  transposeDependencies,
  typedDependencies,
  createSylvester
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLyap.generated.js
var lyapDependencies = {
  matrixDependencies,
  multiplyDependencies,
  sylvesterDependencies,
  transposeDependencies,
  typedDependencies,
  createLyap
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPartitionSelect.generated.js
var partitionSelectDependencies = {
  compareDependencies,
  isNaNDependencies,
  isNumericDependencies,
  typedDependencies,
  createPartitionSelect
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMedian.generated.js
var medianDependencies = {
  addDependencies,
  compareDependencies,
  divideDependencies,
  partitionSelectDependencies,
  typedDependencies,
  createMedian
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMad.generated.js
var madDependencies = {
  absDependencies,
  mapDependencies,
  medianDependencies,
  subtractDependencies,
  typedDependencies,
  createMad
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMagneticConstant.generated.js
var magneticConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMagneticConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMagneticFluxQuantum.generated.js
var magneticFluxQuantumDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMagneticFluxQuantum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMapTransform.generated.js
var mapTransformDependencies = {
  typedDependencies,
  createMapTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixFromFunction.generated.js
var matrixFromFunctionDependencies = {
  isZeroDependencies,
  matrixDependencies,
  typedDependencies,
  createMatrixFromFunction
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixFromRows.generated.js
var matrixFromRowsDependencies = {
  flattenDependencies,
  matrixDependencies,
  sizeDependencies,
  typedDependencies,
  createMatrixFromRows
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMax.generated.js
var maxDependencies = {
  largerDependencies,
  numericDependencies,
  typedDependencies,
  createMax
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMaxTransform.generated.js
var maxTransformDependencies = {
  largerDependencies,
  numericDependencies,
  typedDependencies,
  createMaxTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMean.generated.js
var meanDependencies = {
  addDependencies,
  divideDependencies,
  typedDependencies,
  createMean
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMeanTransform.generated.js
var meanTransformDependencies = {
  addDependencies,
  divideDependencies,
  typedDependencies,
  createMeanTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMin.generated.js
var minDependencies = {
  numericDependencies,
  smallerDependencies,
  typedDependencies,
  createMin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMinTransform.generated.js
var minTransformDependencies = {
  numericDependencies,
  smallerDependencies,
  typedDependencies,
  createMinTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMode.generated.js
var modeDependencies = {
  isNaNDependencies,
  isNumericDependencies,
  typedDependencies,
  createMode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarMass.generated.js
var molarMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarMassC12.generated.js
var molarMassC12Dependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarMassC12
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarPlanckConstant.generated.js
var molarPlanckConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarPlanckConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarVolume.generated.js
var molarVolumeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarVolume
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMultinomial.generated.js
var multinomialDependencies = {
  addDependencies,
  divideDependencies,
  factorialDependencies,
  isIntegerDependencies,
  isPositiveDependencies,
  multiplyDependencies,
  typedDependencies,
  createMultinomial
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNaN.generated.js
var NaNDependencies = {
  BigNumberDependencies,
  createNaN
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNeutronMass.generated.js
var neutronMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createNeutronMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNthRoot.generated.js
var nthRootDependencies = {
  BigNumberDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createNthRoot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNthRoots.generated.js
var nthRootsDependencies = {
  ComplexDependencies,
  divideScalarDependencies,
  typedDependencies,
  createNthRoots
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNuclearMagneton.generated.js
var nuclearMagnetonDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createNuclearMagneton
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNull.generated.js
var nullDependencies = {
  createNull
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOct.generated.js
var octDependencies = {
  formatDependencies,
  typedDependencies,
  createOct
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOnes.generated.js
var onesDependencies = {
  BigNumberDependencies,
  matrixDependencies,
  typedDependencies,
  createOnes
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOr.generated.js
var orDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createOr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParserClass.generated.js
var ParserDependencies = {
  evaluateDependencies,
  createParserClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParser.generated.js
var parserDependencies = {
  ParserDependencies,
  typedDependencies,
  createParser
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPermutations.generated.js
var permutationsDependencies = {
  factorialDependencies,
  typedDependencies,
  createPermutations
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPhi.generated.js
var phiDependencies = {
  BigNumberDependencies,
  createPhi
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPi.generated.js
var piDependencies = {
  BigNumberDependencies,
  createPi
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPickRandom.generated.js
var pickRandomDependencies = {
  typedDependencies,
  createPickRandom
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPinv.generated.js
var pinvDependencies = {
  ComplexDependencies,
  addDependencies,
  ctransposeDependencies,
  deepEqualDependencies,
  divideScalarDependencies,
  dotDependencies,
  dotDivideDependencies,
  equalDependencies,
  invDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  createPinv
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckCharge.generated.js
var planckChargeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckCharge
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckConstant.generated.js
var planckConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckLength.generated.js
var planckLengthDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckLength
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckMass.generated.js
var planckMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckTemperature.generated.js
var planckTemperatureDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckTemperature
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckTime.generated.js
var planckTimeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckTime
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTypeOf.generated.js
var typeOfDependencies = {
  typedDependencies,
  createTypeOf
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPolynomialRoot.generated.js
var polynomialRootDependencies = {
  addDependencies,
  cbrtDependencies,
  divideDependencies,
  equalScalarDependencies,
  imDependencies,
  isZeroDependencies,
  multiplyDependencies,
  reDependencies,
  sqrtDependencies,
  subtractDependencies,
  typeOfDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createPolynomialRoot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPrint.generated.js
var printDependencies = {
  typedDependencies,
  createPrint
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesProtonMass.generated.js
var protonMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createProtonMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQuantileSeq.generated.js
var quantileSeqDependencies = {
  addDependencies,
  compareDependencies,
  multiplyDependencies,
  partitionSelectDependencies,
  typedDependencies,
  createQuantileSeq
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQuantumOfCirculation.generated.js
var quantumOfCirculationDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createQuantumOfCirculation
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRandom.generated.js
var randomDependencies = {
  typedDependencies,
  createRandom
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRandomInt.generated.js
var randomIntDependencies = {
  typedDependencies,
  createRandomInt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRangeClass.generated.js
var RangeDependencies = {
  createRangeClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRangeTransform.generated.js
var rangeTransformDependencies = {
  bignumberDependencies,
  matrixDependencies,
  largerDependencies,
  largerEqDependencies,
  smallerDependencies,
  smallerEqDependencies,
  typedDependencies,
  createRangeTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRationalize.generated.js
var rationalizeDependencies = {
  bignumberDependencies,
  fractionDependencies,
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  addDependencies,
  divideDependencies,
  equalDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  parseDependencies,
  powDependencies,
  simplifyDependencies,
  simplifyConstantDependencies,
  simplifyCoreDependencies,
  subtractDependencies,
  typedDependencies,
  createRationalize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReducedPlanckConstant.generated.js
var reducedPlanckConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createReducedPlanckConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReplacer.generated.js
var replacerDependencies = {
  createReplacer
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReshape.generated.js
var reshapeDependencies = {
  isIntegerDependencies,
  matrixDependencies,
  typedDependencies,
  createReshape
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesResize.generated.js
var resizeDependencies = {
  matrixDependencies,
  createResize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReviver.generated.js
var reviverDependencies = {
  createReviver
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRightArithShift.generated.js
var rightArithShiftDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createRightArithShift
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRightLogShift.generated.js
var rightLogShiftDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createRightLogShift
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRotationMatrix.generated.js
var rotationMatrixDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  addScalarDependencies,
  cosDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  normDependencies,
  sinDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createRotationMatrix
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRotate.generated.js
var rotateDependencies = {
  multiplyDependencies,
  rotationMatrixDependencies,
  typedDependencies,
  createRotate
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRow.generated.js
var rowDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createRow
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRowTransform.generated.js
var rowTransformDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createRowTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRydberg.generated.js
var rydbergDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createRydberg
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSQRT1_2.generated.js
var SQRT1_2Dependencies = {
  // eslint-disable-line camelcase
  BigNumberDependencies,
  createSQRT1_2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSQRT2.generated.js
var SQRT2Dependencies = {
  BigNumberDependencies,
  createSQRT2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSackurTetrode.generated.js
var sackurTetrodeDependencies = {
  BigNumberDependencies,
  createSackurTetrode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSec.generated.js
var secDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createSec
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSech.generated.js
var sechDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createSech
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSecondRadiation.generated.js
var secondRadiationDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createSecondRadiation
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetCartesian.generated.js
var setCartesianDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetCartesian
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetDifference.generated.js
var setDifferenceDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetDifference
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetDistinct.generated.js
var setDistinctDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetDistinct
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetIntersect.generated.js
var setIntersectDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetIntersect
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetIsSubset.generated.js
var setIsSubsetDependencies = {
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetIsSubset
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetMultiplicity.generated.js
var setMultiplicityDependencies = {
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetMultiplicity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetPowerset.generated.js
var setPowersetDependencies = {
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetPowerset
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetSize.generated.js
var setSizeDependencies = {
  compareNaturalDependencies,
  typedDependencies,
  createSetSize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetSymDifference.generated.js
var setSymDifferenceDependencies = {
  IndexDependencies,
  concatDependencies,
  setDifferenceDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetSymDifference
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetUnion.generated.js
var setUnionDependencies = {
  IndexDependencies,
  concatDependencies,
  setIntersectDependencies,
  setSymDifferenceDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetUnion
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSinh.generated.js
var sinhDependencies = {
  typedDependencies,
  createSinh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSort.generated.js
var sortDependencies = {
  compareDependencies,
  compareNaturalDependencies,
  matrixDependencies,
  typedDependencies,
  createSort
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSparse.generated.js
var sparseDependencies = {
  SparseMatrixDependencies,
  typedDependencies,
  createSparse
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSpeedOfLight.generated.js
var speedOfLightDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createSpeedOfLight
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSplitUnit.generated.js
var splitUnitDependencies = {
  typedDependencies,
  createSplitUnit
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSqrtm.generated.js
var sqrtmDependencies = {
  absDependencies,
  addDependencies,
  identityDependencies,
  invDependencies,
  mapDependencies,
  maxDependencies,
  multiplyDependencies,
  sizeDependencies,
  sqrtDependencies,
  subtractDependencies,
  typedDependencies,
  createSqrtm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSquare.generated.js
var squareDependencies = {
  typedDependencies,
  createSquare
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSqueeze.generated.js
var squeezeDependencies = {
  matrixDependencies,
  typedDependencies,
  createSqueeze
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVariance.generated.js
var varianceDependencies = {
  addDependencies,
  applyDependencies,
  divideDependencies,
  isNaNDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  createVariance
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStd.generated.js
var stdDependencies = {
  mapDependencies,
  sqrtDependencies,
  typedDependencies,
  varianceDependencies,
  createStd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStdTransform.generated.js
var stdTransformDependencies = {
  mapDependencies,
  sqrtDependencies,
  typedDependencies,
  varianceDependencies,
  createStdTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStefanBoltzmann.generated.js
var stefanBoltzmannDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createStefanBoltzmann
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesString.generated.js
var stringDependencies = {
  typedDependencies,
  createString
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubsetTransform.generated.js
var subsetTransformDependencies = {
  matrixDependencies,
  typedDependencies,
  createSubsetTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSumTransform.generated.js
var sumTransformDependencies = {
  addDependencies,
  numericDependencies,
  typedDependencies,
  createSumTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSymbolicEqual.generated.js
var symbolicEqualDependencies = {
  OperatorNodeDependencies,
  parseDependencies,
  simplifyDependencies,
  typedDependencies,
  createSymbolicEqual
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTan.generated.js
var tanDependencies = {
  typedDependencies,
  createTan
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTanh.generated.js
var tanhDependencies = {
  typedDependencies,
  createTanh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesThomsonCrossSection.generated.js
var thomsonCrossSectionDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createThomsonCrossSection
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTo.generated.js
var toDependencies = {
  matrixDependencies,
  typedDependencies,
  createTo
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTrace.generated.js
var traceDependencies = {
  addDependencies,
  matrixDependencies,
  typedDependencies,
  createTrace
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTrue.generated.js
var trueDependencies = {
  createTrue
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnequal.generated.js
var unequalDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createUnequal
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnitFunction.generated.js
var unitDependencies = {
  UnitDependencies,
  typedDependencies,
  createUnitFunction
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUppercaseE.generated.js
var EDependencies = {
  eDependencies,
  createUppercaseE
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUppercasePi.generated.js
var PIDependencies = {
  piDependencies,
  createUppercasePi
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVacuumImpedance.generated.js
var vacuumImpedanceDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createVacuumImpedance
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVarianceTransform.generated.js
var varianceTransformDependencies = {
  addDependencies,
  applyDependencies,
  divideDependencies,
  isNaNDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  createVarianceTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVersion.generated.js
var versionDependencies = {
  createVersion
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesWeakMixingAngle.generated.js
var weakMixingAngleDependencies = {
  BigNumberDependencies,
  createWeakMixingAngle
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesWienDisplacement.generated.js
var wienDisplacementDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createWienDisplacement
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesXor.generated.js
var xorDependencies = {
  DenseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createXor
};

// node_modules/mathjs/lib/esm/entry/allFactoriesAny.js
var all = factoriesAny_exports;
export {
  AccessorNode,
  AccessorNodeDependencies,
  ArgumentsError,
  ArrayNode,
  ArrayNodeDependencies,
  AssignmentNode,
  AssignmentNodeDependencies,
  BigNumber,
  BigNumberDependencies,
  BlockNode,
  BlockNodeDependencies,
  Chain,
  ChainDependencies,
  Complex2 as Complex,
  ComplexDependencies,
  ConditionalNode,
  ConditionalNodeDependencies,
  ConstantNode,
  ConstantNodeDependencies,
  DenseMatrix,
  DenseMatrixDependencies,
  DimensionError,
  EDependencies,
  FibonacciHeap,
  FibonacciHeapDependencies,
  Fraction2 as Fraction,
  FractionDependencies,
  FunctionAssignmentNode,
  FunctionAssignmentNodeDependencies,
  FunctionNode,
  FunctionNodeDependencies,
  Help,
  HelpDependencies,
  ImmutableDenseMatrix,
  ImmutableDenseMatrixDependencies,
  Index,
  IndexDependencies,
  IndexError,
  IndexNode,
  IndexNodeDependencies,
  InfinityDependencies,
  LN10,
  LN10Dependencies,
  LN2,
  LN2Dependencies,
  LOG10E,
  LOG10EDependencies,
  LOG2E,
  LOG2EDependencies,
  Matrix,
  MatrixDependencies,
  NaNDependencies,
  Node,
  NodeDependencies,
  ObjectNode,
  ObjectNodeDependencies,
  OperatorNode,
  OperatorNodeDependencies,
  PIDependencies,
  ParenthesisNode,
  ParenthesisNodeDependencies,
  Parser,
  ParserDependencies,
  Range,
  RangeDependencies,
  RangeNode,
  RangeNodeDependencies,
  RelationalNode,
  RelationalNodeDependencies,
  ResultSet,
  ResultSetDependencies,
  SQRT1_2,
  SQRT1_2Dependencies,
  SQRT2,
  SQRT2Dependencies,
  Spa,
  SpaDependencies,
  SparseMatrix,
  SparseMatrixDependencies,
  SymbolNode,
  SymbolNodeDependencies,
  Unit,
  UnitDependencies,
  _Infinity,
  _NaN,
  _false,
  _null,
  _true,
  abs,
  absDependencies,
  acos,
  acosDependencies,
  acosh,
  acoshDependencies,
  acot,
  acotDependencies,
  acoth,
  acothDependencies,
  acsc,
  acscDependencies,
  acsch,
  acschDependencies,
  add,
  addDependencies,
  addScalar,
  addScalarDependencies,
  all,
  and,
  andDependencies,
  apply,
  applyDependencies,
  applyTransformDependencies,
  arg,
  argDependencies,
  asec,
  asecDependencies,
  asech,
  asechDependencies,
  asin,
  asinDependencies,
  asinh,
  asinhDependencies,
  atan,
  atan2,
  atan2Dependencies,
  atanDependencies,
  atanh,
  atanhDependencies,
  atomicMass,
  atomicMassDependencies,
  avogadro,
  avogadroDependencies,
  bellNumbers,
  bellNumbersDependencies,
  bignumber,
  bignumberDependencies,
  bin,
  binDependencies,
  bitAnd,
  bitAndDependencies,
  bitNot,
  bitNotDependencies,
  bitOr,
  bitOrDependencies,
  bitXor2 as bitXor,
  bitXorDependencies,
  bohrMagneton,
  bohrMagnetonDependencies,
  bohrRadius,
  bohrRadiusDependencies,
  boltzmann,
  boltzmannDependencies,
  boolean,
  booleanDependencies,
  catalan,
  catalanDependencies,
  cbrt,
  cbrtDependencies,
  ceil,
  ceilDependencies,
  chain,
  chainDependencies,
  classicalElectronRadius,
  classicalElectronRadiusDependencies,
  clone2 as clone,
  cloneDependencies,
  column,
  columnDependencies,
  columnTransformDependencies,
  combinations,
  combinationsDependencies,
  combinationsWithRep,
  combinationsWithRepDependencies,
  compare,
  compareDependencies,
  compareNatural,
  compareNaturalDependencies,
  compareText,
  compareTextDependencies,
  compile,
  compileDependencies,
  complex,
  complexDependencies,
  composition,
  compositionDependencies,
  concat,
  concatDependencies,
  concatTransformDependencies,
  conductanceQuantum,
  conductanceQuantumDependencies,
  config,
  conj,
  conjDependencies,
  cos,
  cosDependencies,
  cosh2 as cosh,
  coshDependencies,
  cot,
  cotDependencies,
  coth,
  cothDependencies,
  coulomb,
  coulombDependencies,
  count,
  countDependencies,
  create,
  createAbs,
  createAccessorNode,
  createAcos,
  createAcosh,
  createAcot,
  createAcoth,
  createAcsc,
  createAcsch,
  createAdd,
  createAddScalar,
  createAnd,
  createApply,
  createApplyTransform,
  createArg,
  createArrayNode,
  createAsec,
  createAsech,
  createAsin,
  createAsinh,
  createAssignmentNode,
  createAtan,
  createAtan2,
  createAtanh,
  createAtomicMass,
  createAvogadro,
  createBellNumbers,
  createBigNumberClass,
  createBignumber,
  createBin,
  createBitAnd,
  createBitNot,
  createBitOr,
  createBitXor,
  createBlockNode,
  createBohrMagneton,
  createBohrRadius,
  createBoltzmann,
  createBoolean,
  createCatalan,
  createCbrt,
  createCeil,
  createChain,
  createChainClass,
  createClassicalElectronRadius,
  createClone,
  createColumn,
  createColumnTransform,
  createCombinations,
  createCombinationsWithRep,
  createCompare,
  createCompareNatural,
  createCompareText,
  createCompile,
  createComplex,
  createComplexClass,
  createComposition,
  createConcat,
  createConcatTransform,
  createConditionalNode,
  createConductanceQuantum,
  createConj,
  createConstantNode,
  createCos,
  createCosh,
  createCot,
  createCoth,
  createCoulomb,
  createCount,
  createCreateUnit,
  createCross,
  createCsc,
  createCsch,
  createCtranspose,
  createCube,
  createCumSum,
  createCumSumTransform,
  createDeepEqual,
  createDenseMatrixClass,
  createDerivative,
  createDet,
  createDeuteronMass,
  createDiag,
  createDiff,
  createDiffTransform,
  createDistance,
  createDivide,
  createDivideScalar,
  createDot,
  createDotDivide,
  createDotMultiply,
  createDotPow,
  createE,
  createEfimovFactor,
  createEigs,
  createElectricConstant,
  createElectronMass,
  createElementaryCharge,
  createEqual,
  createEqualScalar,
  createEqualText,
  createErf,
  createEvaluate,
  createExp,
  createExpm,
  createExpm1,
  createFactorial,
  createFalse,
  createFaraday,
  createFermiCoupling,
  createFft,
  createFibonacciHeapClass,
  createFilter,
  createFilterTransform,
  createFineStructure,
  createFirstRadiation,
  createFix,
  createFlatten,
  createFloor,
  createForEach,
  createForEachTransform,
  createFormat,
  createFraction,
  createFractionClass,
  createFunctionAssignmentNode,
  createFunctionNode,
  createGamma,
  createGasConstant,
  createGcd,
  createGetMatrixDataType,
  createGravitationConstant,
  createGravity,
  createHartreeEnergy,
  createHasNumericValue,
  createHelp,
  createHelpClass,
  createHex,
  createHypot,
  createI,
  createIdentity,
  createIfft,
  createIm,
  createImmutableDenseMatrixClass,
  createIndex,
  createIndexClass,
  createIndexNode,
  createIndexTransform,
  createInfinity,
  createIntersect,
  createInv,
  createInverseConductanceQuantum,
  createInvmod,
  createIsInteger,
  createIsNaN,
  createIsNegative,
  createIsNumeric,
  createIsPositive,
  createIsPrime,
  createIsZero,
  createKldivergence,
  createKlitzing,
  createKron,
  createLN10,
  createLN2,
  createLOG10E,
  createLOG2E,
  createLarger,
  createLargerEq,
  createLcm,
  createLeafCount,
  createLeftShift,
  createLgamma,
  createLog,
  createLog10,
  createLog1p,
  createLog2,
  createLoschmidt,
  createLsolve,
  createLsolveAll,
  createLup,
  createLusolve,
  createLyap,
  createMad,
  createMagneticConstant,
  createMagneticFluxQuantum,
  createMap,
  createMapTransform,
  createMatrix,
  createMatrixClass,
  createMatrixFromColumns,
  createMatrixFromFunction,
  createMatrixFromRows,
  createMax,
  createMaxTransform,
  createMean,
  createMeanTransform,
  createMedian,
  createMin,
  createMinTransform,
  createMod,
  createMode,
  createMolarMass,
  createMolarMassC12,
  createMolarPlanckConstant,
  createMolarVolume,
  createMultinomial,
  createMultiply,
  createMultiplyScalar,
  createNaN,
  createNeutronMass,
  createNode,
  createNorm,
  createNot,
  createNthRoot,
  createNthRoots,
  createNuclearMagneton,
  createNull,
  createNumber,
  createNumeric,
  createObjectNode,
  createOct,
  createOnes,
  createOperatorNode,
  createOr,
  createParenthesisNode,
  createParse,
  createParser,
  createParserClass,
  createPartitionSelect,
  createPermutations,
  createPhi,
  createPi,
  createPickRandom,
  createPinv,
  createPlanckCharge,
  createPlanckConstant,
  createPlanckLength,
  createPlanckMass,
  createPlanckTemperature,
  createPlanckTime,
  createPolynomialRoot,
  createPow,
  createPrint,
  createProd,
  createProtonMass,
  createQr,
  createQuantileSeq,
  createQuantumOfCirculation,
  createRandom,
  createRandomInt,
  createRange,
  createRangeClass,
  createRangeNode,
  createRangeTransform,
  createRationalize,
  createRe,
  createReducedPlanckConstant,
  createRelationalNode,
  createReplacer,
  createReshape,
  createResize,
  createResolve,
  createResultSet,
  createReviver,
  createRightArithShift,
  createRightLogShift,
  createRotate,
  createRotationMatrix,
  createRound,
  createRow,
  createRowTransform,
  createRydberg,
  createSQRT1_2,
  createSQRT2,
  createSackurTetrode,
  createSchur,
  createSec,
  createSech,
  createSecondRadiation,
  createSetCartesian,
  createSetDifference,
  createSetDistinct,
  createSetIntersect,
  createSetIsSubset,
  createSetMultiplicity,
  createSetPowerset,
  createSetSize,
  createSetSymDifference,
  createSetUnion,
  createSign,
  createSimplify,
  createSimplifyConstant,
  createSimplifyCore,
  createSin,
  createSinh,
  createSize,
  createSlu,
  createSmaller,
  createSmallerEq,
  createSort,
  createSpaClass,
  createSparse,
  createSparseMatrixClass,
  createSpeedOfLight,
  createSplitUnit,
  createSqrt,
  createSqrtm,
  createSquare,
  createSqueeze,
  createStd,
  createStdTransform,
  createStefanBoltzmann,
  createStirlingS2,
  createString,
  createSubset,
  createSubsetTransform,
  createSubtract,
  createSum,
  createSumTransform,
  createSylvester,
  createSymbolNode,
  createSymbolicEqual,
  createTan,
  createTanh,
  createTau,
  createThomsonCrossSection,
  createTo,
  createTrace,
  createTranspose,
  createTrue,
  createTypeOf,
  createTyped,
  createUnaryMinus,
  createUnaryPlus,
  createUnequal,
  createUnit,
  createUnitClass,
  createUnitDependencies,
  createUnitFunction,
  createUppercaseE,
  createUppercasePi,
  createUsolve,
  createUsolveAll,
  createVacuumImpedance,
  createVariance,
  createVarianceTransform,
  createVersion,
  createWeakMixingAngle,
  createWienDisplacement,
  createXgcd,
  createXor,
  createZeros,
  cross,
  crossDependencies,
  csc,
  cscDependencies,
  csch,
  cschDependencies,
  ctranspose,
  ctransposeDependencies,
  cube,
  cubeDependencies,
  cumsum,
  cumsumDependencies,
  cumsumTransformDependencies,
  deepEqual,
  deepEqualDependencies,
  derivative,
  derivativeDependencies,
  det,
  detDependencies,
  deuteronMass,
  deuteronMassDependencies,
  diag,
  diagDependencies,
  diff,
  diffDependencies,
  diffTransformDependencies,
  distance,
  distanceDependencies,
  divide,
  divideDependencies,
  divideScalar,
  divideScalarDependencies,
  embeddedDocs as docs,
  dot,
  dotDependencies,
  dotDivide,
  dotDivideDependencies,
  dotMultiply,
  dotMultiplyDependencies,
  dotPow,
  dotPowDependencies,
  e,
  eDependencies,
  efimovFactor,
  efimovFactorDependencies,
  eigs,
  eigsDependencies,
  electricConstant,
  electricConstantDependencies,
  electronMass,
  electronMassDependencies,
  elementaryCharge,
  elementaryChargeDependencies,
  equal,
  equalDependencies,
  equalScalar,
  equalScalarDependencies,
  equalText,
  equalTextDependencies,
  erf,
  erfDependencies,
  evaluate,
  evaluateDependencies,
  exp,
  expDependencies,
  expm,
  expm1,
  expm1Dependencies,
  expmDependencies,
  factorial,
  factorialDependencies,
  factory,
  falseDependencies,
  faraday,
  faradayDependencies,
  fermiCoupling,
  fermiCouplingDependencies,
  fft,
  fftDependencies,
  filter,
  filterDependencies,
  filterTransformDependencies,
  fineStructure,
  fineStructureDependencies,
  firstRadiation,
  firstRadiationDependencies,
  fix,
  fixDependencies,
  flatten2 as flatten,
  flattenDependencies,
  floor,
  floorDependencies,
  forEach,
  forEachDependencies,
  forEachTransformDependencies,
  format3 as format,
  formatDependencies,
  fraction,
  fractionDependencies,
  gamma,
  gammaDependencies,
  gasConstant,
  gasConstantDependencies,
  gcd,
  gcdDependencies,
  getMatrixDataType,
  getMatrixDataTypeDependencies,
  gravitationConstant,
  gravitationConstantDependencies,
  gravity,
  gravityDependencies,
  hartreeEnergy,
  hartreeEnergyDependencies,
  hasNumericValue,
  hasNumericValueDependencies,
  help,
  helpDependencies,
  hex,
  hexDependencies,
  hypot,
  hypotDependencies,
  i,
  iDependencies,
  identity,
  identityDependencies,
  ifft,
  ifftDependencies,
  im,
  imDependencies,
  index,
  indexDependencies,
  indexTransformDependencies,
  intersect,
  intersectDependencies,
  inv,
  invDependencies,
  inverseConductanceQuantum,
  inverseConductanceQuantumDependencies,
  invmod,
  invmodDependencies,
  isAccessorNode,
  isArray,
  isArrayNode,
  isAssignmentNode,
  isBigNumber,
  isBlockNode,
  isBoolean,
  isChain,
  isCollection,
  isComplex,
  isConditionalNode,
  isConstantNode,
  isDate,
  isDenseMatrix,
  isFraction,
  isFunction,
  isFunctionAssignmentNode,
  isFunctionNode,
  isHelp,
  isIndex,
  isIndexNode,
  isInteger2 as isInteger,
  isIntegerDependencies,
  isMatrix,
  isNaN2 as isNaN,
  isNaNDependencies,
  isNegative,
  isNegativeDependencies,
  isNode,
  isNull,
  isNumber,
  isNumeric,
  isNumericDependencies,
  isObject,
  isObjectNode,
  isOperatorNode,
  isParenthesisNode,
  isPositive,
  isPositiveDependencies,
  isPrime,
  isPrimeDependencies,
  isRange,
  isRangeNode,
  isRegExp,
  isRelationalNode,
  isResultSet,
  isSparseMatrix,
  isString,
  isSymbolNode,
  isUndefined,
  isUnit,
  isZero,
  isZeroDependencies,
  kldivergence,
  kldivergenceDependencies,
  klitzing,
  klitzingDependencies,
  kron,
  kronDependencies,
  larger,
  largerDependencies,
  largerEq,
  largerEqDependencies,
  lcm,
  lcmDependencies,
  leafCount,
  leafCountDependencies,
  leftShift,
  leftShiftDependencies,
  lgamma,
  lgammaDependencies,
  log,
  log10,
  log10Dependencies,
  log1p2 as log1p,
  log1pDependencies,
  log2,
  log2Dependencies,
  logDependencies,
  loschmidt,
  loschmidtDependencies,
  lsolve,
  lsolveAll,
  lsolveAllDependencies,
  lsolveDependencies,
  lup,
  lupDependencies,
  lusolve,
  lusolveDependencies,
  lyap,
  lyapDependencies,
  mad,
  madDependencies,
  magneticConstant,
  magneticConstantDependencies,
  magneticFluxQuantum,
  magneticFluxQuantumDependencies,
  map,
  mapDependencies,
  mapTransformDependencies,
  matrix,
  matrixDependencies,
  matrixFromColumns,
  matrixFromColumnsDependencies,
  matrixFromFunction,
  matrixFromFunctionDependencies,
  matrixFromRows,
  matrixFromRowsDependencies,
  max,
  maxDependencies,
  maxTransformDependencies,
  mean,
  meanDependencies,
  meanTransformDependencies,
  median,
  medianDependencies,
  min,
  minDependencies,
  minTransformDependencies,
  mod,
  modDependencies,
  mode,
  modeDependencies,
  molarMass,
  molarMassC12,
  molarMassC12Dependencies,
  molarMassDependencies,
  molarPlanckConstant,
  molarPlanckConstantDependencies,
  molarVolume,
  molarVolumeDependencies,
  multinomial,
  multinomialDependencies,
  multiply,
  multiplyDependencies,
  multiplyScalar,
  multiplyScalarDependencies,
  neutronMass,
  neutronMassDependencies,
  norm,
  normDependencies,
  not,
  notDependencies,
  nthRoot,
  nthRootDependencies,
  nthRoots,
  nthRootsDependencies,
  nuclearMagneton,
  nuclearMagnetonDependencies,
  nullDependencies,
  number,
  numberDependencies,
  numeric,
  numericDependencies,
  oct,
  octDependencies,
  ones,
  onesDependencies,
  or,
  orDependencies,
  parse,
  parseDependencies,
  parser,
  parserDependencies,
  partitionSelect,
  partitionSelectDependencies,
  permutations,
  permutationsDependencies,
  phi,
  phiDependencies,
  pi,
  piDependencies,
  pickRandom,
  pickRandomDependencies,
  pinv,
  pinvDependencies,
  planckCharge,
  planckChargeDependencies,
  planckConstant,
  planckConstantDependencies,
  planckLength,
  planckLengthDependencies,
  planckMass,
  planckMassDependencies,
  planckTemperature,
  planckTemperatureDependencies,
  planckTime,
  planckTimeDependencies,
  polynomialRoot,
  polynomialRootDependencies,
  pow,
  powDependencies,
  print,
  printDependencies,
  prod,
  prodDependencies,
  protonMass,
  protonMassDependencies,
  qr,
  qrDependencies,
  quantileSeq,
  quantileSeqDependencies,
  quantumOfCirculation,
  quantumOfCirculationDependencies,
  random,
  randomDependencies,
  randomInt,
  randomIntDependencies,
  range,
  rangeDependencies,
  rangeTransformDependencies,
  rationalize,
  rationalizeDependencies,
  re,
  reDependencies,
  reducedPlanckConstant,
  reducedPlanckConstantDependencies,
  replacer,
  replacerDependencies,
  reshape2 as reshape,
  reshapeDependencies,
  resize2 as resize,
  resizeDependencies,
  resolve,
  resolveDependencies,
  reviver,
  reviverDependencies,
  rightArithShift,
  rightArithShiftDependencies,
  rightLogShift,
  rightLogShiftDependencies,
  rotate,
  rotateDependencies,
  rotationMatrix,
  rotationMatrixDependencies,
  round,
  roundDependencies,
  row,
  rowDependencies,
  rowTransformDependencies,
  rydberg,
  rydbergDependencies,
  sackurTetrode,
  sackurTetrodeDependencies,
  schur,
  schurDependencies,
  sec,
  secDependencies,
  sech,
  sechDependencies,
  secondRadiation,
  secondRadiationDependencies,
  setCartesian,
  setCartesianDependencies,
  setDifference,
  setDifferenceDependencies,
  setDistinct,
  setDistinctDependencies,
  setIntersect,
  setIntersectDependencies,
  setIsSubset,
  setIsSubsetDependencies,
  setMultiplicity,
  setMultiplicityDependencies,
  setPowerset,
  setPowersetDependencies,
  setSize,
  setSizeDependencies,
  setSymDifference,
  setSymDifferenceDependencies,
  setUnion,
  setUnionDependencies,
  sign,
  signDependencies,
  simplify,
  simplifyConstant,
  simplifyConstantDependencies,
  simplifyCore,
  simplifyCoreDependencies,
  simplifyDependencies,
  sin,
  sinDependencies,
  sinh,
  sinhDependencies,
  size,
  sizeDependencies,
  slu,
  sluDependencies,
  smaller,
  smallerDependencies,
  smallerEq,
  smallerEqDependencies,
  sort,
  sortDependencies,
  sparse,
  sparseDependencies,
  speedOfLight,
  speedOfLightDependencies,
  splitUnit,
  splitUnitDependencies,
  sqrt,
  sqrtDependencies,
  sqrtm,
  sqrtmDependencies,
  square,
  squareDependencies,
  squeeze2 as squeeze,
  squeezeDependencies,
  std,
  stdDependencies,
  stdTransformDependencies,
  stefanBoltzmann,
  stefanBoltzmannDependencies,
  stirlingS2,
  stirlingS2Dependencies,
  string,
  stringDependencies,
  subset,
  subsetDependencies,
  subsetTransformDependencies,
  subtract,
  subtractDependencies,
  sum,
  sumDependencies,
  sumTransformDependencies,
  sylvester,
  sylvesterDependencies,
  symbolicEqual,
  symbolicEqualDependencies,
  tan,
  tanDependencies,
  tanh2 as tanh,
  tanhDependencies,
  tau,
  tauDependencies,
  thomsonCrossSection,
  thomsonCrossSectionDependencies,
  to,
  toDependencies,
  trace,
  traceDependencies,
  transpose,
  transposeDependencies,
  trueDependencies,
  typeOf2 as typeOf,
  typeOfDependencies,
  typed,
  typedDependencies,
  unaryMinus,
  unaryMinusDependencies,
  unaryPlus,
  unaryPlusDependencies,
  unequal,
  unequalDependencies,
  unit,
  unitDependencies,
  usolve,
  usolveAll,
  usolveAllDependencies,
  usolveDependencies,
  vacuumImpedance,
  vacuumImpedanceDependencies,
  variance,
  varianceDependencies,
  varianceTransformDependencies,
  version,
  versionDependencies,
  weakMixingAngle,
  weakMixingAngleDependencies,
  wienDisplacement,
  wienDisplacementDependencies,
  xgcd,
  xgcdDependencies,
  xor,
  xorDependencies,
  zeros,
  zerosDependencies
};
/*! Bundled license information:

complex.js/complex.js:
  (**
   * @license Complex.js v2.1.1 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.2.0 05/03/2022
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)
*/
//# sourceMappingURL=mathjs.js.map
