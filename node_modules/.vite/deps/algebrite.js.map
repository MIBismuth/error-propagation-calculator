{
  "version": 3,
  "sources": ["../../big-integer/BigInteger.js", "../../algebrite/dist/algebrite.js"],
  "sourcesContent": ["var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n", "// Generated by CoffeeScript 2.5.1\n(function() {\n\n  /* arg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the angle of complex z.\n\n  */\n  /*\n   Argument (angle) of complex z\n\n    z    arg(z)\n    -    ------\n\n    a    0\n\n    -a    -pi      See note 3 below\n\n    (-1)^a    a pi\n\n    exp(a + i b)  b\n\n    a b    arg(a) + arg(b)\n\n    a + i b    arctan(b/a)\n\n  Result by quadrant\n\n    z    arg(z)\n    -    ------\n\n    1 + i    1/4 pi\n\n    1 - i    -1/4 pi\n\n    -1 + i    3/4 pi\n\n    -1 - i    -3/4 pi\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. Symbols in z are assumed to be positive and real.\n\n    3. Negative direction adds -pi to angle.\n\n       Example: z = (-1)^(1/3), abs(z) = 1/3 pi, abs(-z) = -2/3 pi\n\n    4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      arg(numerator(z)) - arg(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  /*\n   Returns the coefficient of the imaginary part of complex z\n\n    z    imag(z)\n    -    -------\n\n    a + i b    b\n\n    exp(i a)  sin(a)\n  */\n  /* Power function\n\n    Input:    push  Base\n\n        push  Exponent\n\n    Output:    Result on stack\n  */\n  /*\n  Convert complex z to rectangular form\n\n    Input:    push  z\n\n    Output:    Result on stack\n  */\n  /* det =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the determinant of matrix m.\n  Uses Gaussian elimination for numerical matrices.\n\n  Example:\n\n    det(((1,2),(3,4)))\n    > -2\n\n  */\n  /* adj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).\n\n  */\n  /*\n   Guesses a rational for each float in the passed expression\n  */\n  /* arccos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse cosine of x.\n\n  */\n  /* arccosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic cosine of x.\n\n  */\n  /* arcsin =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse sine of x.\n\n  */\n  /* arcsinh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic sine of x.\n\n  */\n  /* arctan =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse tangent of x.\n\n  */\n  /* arctanh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic tangent of x.\n\n  */\n  /* besselj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Returns a solution to the Bessel differential equation (Bessel function of first kind).\n\n  Recurrence relation:\n\n    besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)\n\n    besselj(x,1/2) = sqrt(2/pi/x) sin(x)\n\n    besselj(x,-1/2) = sqrt(2/pi/x) cos(x)\n\n  For negative n, reorder the recurrence relation as:\n\n    besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)\n\n  Substitute n+2 for n to obtain\n\n    besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)\n\n  Examples:\n\n    besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)\n\n    besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)\n\n  */\n  /* bessely =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Bessel function of second kind.\n\n  */\n  /* ceiling =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns the smallest integer not less than x.\n\n  */\n  /* check =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p\n\n  General description\n  -------------------\n  Returns whether the predicate p is true/false or unknown:\n  0 if false, 1 if true or remains unevaluated if unknown.\n  Note that if \"check\" is passed an assignment, it turns it into a test,\n  i.e. check(a = b) is turned into check(a==b) \n  so \"a\" is not assigned anything.\n  Like in many programming languages, \"check\" also gives truthyness/falsyness\n  for numeric values. In which case, \"true\" is returned for non-zero values.\n  Potential improvements: \"check\" can't evaluate strings yet.\n\n  */\n  /* choose =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  n,k\n\n  General description\n  -------------------\n\n  Returns the number of combinations of n items taken k at a time.\n\n  For example, the number of five card hands is choose(52,5)\n\n  ```\n                            n!\n        choose(n,k) = -------------\n                       k! (n - k)!\n  ```\n  */\n  /* circexp =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns expression x with circular and hyperbolic functions converted to exponential forms. Sometimes this will simplify an expression.\n\n  */\n  /* clear =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Completely wipes a variable from the environment (while doing x = quote(x) just unassigns it).\n\n  */\n  /* clearall =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n\n  Completely wipes all variables from the environment.\n\n  */\n  /* cofactor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,i,j\n\n  General description\n  -------------------\n  Cofactor of a matrix component.\n  Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).\n  This function returns c[i,j].\n\n  */\n  /* conj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the complex conjugate of z.\n\n  */\n  /* contract =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,i,j\n\n  General description\n  -------------------\n  Contract across tensor indices i.e. returns \"a\" summed over indices i and j.\n  If i and j are omitted then 1 and 2 are used.\n  contract(m) is equivalent to the trace of matrix m.\n\n  */\n  /* cosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the hyperbolic cosine of x\n\n  ```\n              exp(x) + exp(-x)\n    cosh(x) = ----------------\n                     2\n  ```\n\n  */\n  /* deg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x\n\n  General description\n  -------------------\n  Returns the degree of polynomial p(x).\n\n  */\n  /* denominator =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the denominator of expression x.\n\n  */\n  /* dim =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,n\n\n  General description\n  -------------------\n  Returns the cardinality of the nth index of tensor \"m\".\n\n  */\n  /* do =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Evaluates each argument from left to right. Returns the result of the last argument.\n\n  */\n  /* eigenval =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues of m. See \"eigen\" for more info.\n\n  */\n  /* eigenvec =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvectors of m. See \"eigen\" for more info.\n\n  */\n  /* erf =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Authors\n  -------\n  philippe.billet@noos.fr\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Error function erf(x).\n  erf(-x)=erf(x)\n\n  */\n  /*\n  Remove terms that involve a given symbol or expression. For example...\n\n    filter(x^2 + x + 1, x)    =>  1\n\n    filter(x^2 + x + 1, x^2)  =>  x + 1\n  */\n  /* dot =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n\n  The inner (or dot) operator gives products of vectors,\n  matrices, and tensors.\n\n  Note that for Algebrite, the elements of a vector/matrix\n  can only be scalars. This allows for example to flesh out\n  matrix multiplication using the usual multiplication.\n  So for example block-representations are not allowed.\n\n  There is an aweful lot of confusion between sw packages on\n  what dot and inner do.\n\n  First off, the \"dot\" operator is different from the\n  mathematical notion of dot product, which can be\n  slightly confusing.\n\n  The mathematical notion of dot product is here:\n    http://mathworld.wolfram.com/DotProduct.html\n\n  However, \"dot\" does that and a bunch of other things,\n  i.e. in Algebrite\n  dot/inner does what the dot of Mathematica does, i.e.:\n\n  scalar product of vectors:\n\n    inner((a, b, c), (x, y, z))\n    > a x + b y + c z\n\n  products of matrices and vectors:\n\n    inner(((a, b), (c,d)), (x, y))\n    > (a x + b y,c x + d y)\n\n    inner((x, y), ((a, b), (c,d)))\n    > (a x + c y,b x + d y)\n\n    inner((x, y), ((a, b), (c,d)), (r, s))\n    > a r x + b s x + c r y + d s y\n\n  matrix product:\n\n    inner(((a,b),(c,d)),((r,s),(t,u)))\n    > ((a r + b t,a s + b u),(c r + d t,c s + d u))\n\n  the \"dot/inner\" operator is associative and\n  distributive but not commutative.\n\n  In Mathematica, Inner is a generalisation of Dot where\n  the user can specify the multiplication and the addition\n  operators.\n  But here in Algebrite they do the same thing.\n\n   https://reference.wolfram.com/language/ref/Dot.html\n   https://reference.wolfram.com/language/ref/Inner.html\n\n   http://uk.mathworks.com/help/matlab/ref/dot.html\n   http://uk.mathworks.com/help/matlab/ref/mtimes.html\n\n  */\n  /*\n   Laguerre function\n\n  Example\n\n    laguerre(x,3)\n\n  Result\n\n       1   3    3   2\n    - --- x  + --- x  - 3 x + 1\n       6        2\n\n  The computation uses the following recurrence relation.\n\n    L(x,0,k) = 1\n\n    L(x,1,k) = -x + k + 1\n\n    n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)\n\n  In the \"for\" loop i = n-1 so the recurrence relation becomes\n\n    (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)\n  */\n  /*\n   Return the leading coefficient of a polynomial.\n\n  Example\n\n    leading(5x^2+x+1,x)\n\n  Result\n\n    5\n\n  The result is undefined if P is not a polynomial.\n  */\n  /*\n   Legendre function\n\n  Example\n\n    legendre(x,3,0)\n\n  Result\n\n     5   3    3\n    --- x  - --- x\n     2        2\n\n  The computation uses the following recurrence relation.\n\n    P(x,0) = 1\n\n    P(x,1) = x\n\n    n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)\n\n  In the \"for\" loop we have i = n-1 so the recurrence relation becomes\n\n    (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)\n\n  For m > 0\n\n    P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)\n  */\n  /*\n  Convert complex z to polar form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    polar(z) = abs(z) * exp(i * arg(z))\n  */\n  /*\n   Returns the real part of complex z\n\n    z    real(z)\n    -    -------\n\n    a + i b    a\n\n    exp(i a)  cos(a)\n  */\n  /*\n  Taylor expansion of a function\n\n    push(F)\n    push(X)\n    push(N)\n    push(A)\n    taylor()\n  */\n  /*\n  // up to 100 blocks of 100,000 atoms\n\n  #define M 100\n  #define N 100000\n\n  U *mem[M]\n  int mcount\n\n  U *free_list\n  int free_count\n\n  U *\n  alloc(void)\n  {\n    U *p\n    if (free_count == 0) {\n      if (mcount == 0)\n        alloc_mem()\n      else {\n        gc()\n        if (free_count < N * mcount / 2)\n          alloc_mem()\n      }\n      if (free_count == 0)\n        stop(\"atom space exhausted\")\n    }\n    p = free_list\n    free_list = free_list->u.cons.cdr\n    free_count--\n    return p\n  }\n   */\n  /*\n   Compare adjacent terms in s[] and combine if possible.\n\n    Returns the number of terms remaining in s[].\n\n    n  number of terms in s[] initially\n  */\n  /* cross =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u,v\n\n  General description\n  -------------------\n  Returns the cross product of vectors u and v.\n\n  */\n  /* curl =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u\n\n  General description\n  -------------------\n  Returns the curl of vector u.\n\n  */\n  /*\n    Clear all patterns\n  */\n  /*\n  if 0\n\n   * left brace\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = x - 2\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n   * right brace\n\n    emit_x++\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = emit_x\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n    emit_x++\n\n  endif\n   */\n  /*\n   For example...\n\n    push(F)\n    push(X)\n    filter()\n    F = pop()\n  */\n  /*\n   Symbolic addition\n\n    Terms in a sum are combined if they are identical modulo rational\n    coefficients.\n\n    For example, A + 2A becomes 3A.\n\n    However, the sum A + sqrt(2) A is not modified.\n\n    Combining terms can lead to second-order effects.\n\n    For example, consider the case of\n\n      1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A\n\n    The first two terms are combined to yield 2 sqrt(2) A.\n\n    This result can now be combined with the third term to yield\n\n      3 sqrt(2) A\n  */\n  /*\n   Table of integrals\n\n  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where\n\n    A  is the template expression\n\n    B  is the result expression\n\n    C  is an optional list of conditional expressions\n  */\n  /*\n   Partition a term\n\n    Input stack:\n\n      term (factor or product of factors)\n\n      free variable\n\n    Output stack:\n\n      constant expression\n\n      variable expression\n  */\n  /*\n    Substitute new expr for old expr in expr.\n\n    Input:  push  expr\n\n      push  old expr\n\n      push  new expr\n\n    Output:  Result on stack\n  */\n  var $, ABS, ADD, ADJ, AND, APPROXRATIO, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ASSUME_REAL_VARIABLES, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLEARALL, CLEARPATTERNS, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DEBUG_ABS, DEBUG_ARG, DEBUG_CLOCKFORM, DEBUG_IMAG, DEBUG_IS, DEBUG_MULTIPLY, DEBUG_POWER, DEBUG_RATIONALIZE, DEBUG_RECT, DEBUG_SIMPLIFY, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_approxratio, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clearall, Eval_clearpatterns, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_function_reference, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_lookup, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_pattern, Eval_patternsinfo, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_print2dascii, Eval_printcomputer, Eval_printhuman, Eval_printlatex, Eval_printlist, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_round, Eval_setq, Eval_sgn, Eval_shape, Eval_silentpattern, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sum, Eval_sym, Eval_symbolsinfo, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, FORCE_FIXED_PRINTOUT, FUNCTION, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LAST_2DASCII_PRINT, LAST_FULL_PRINT, LAST_LATEX_PRINT, LAST_LIST_PRINT, LAST_PLAIN_PRINT, LAST_PRINT, LCM, LEADING, LEGENDRE, LOG, LOOKUP, M, MAXDIM, MAXPRIMETAB, MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES, MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE, MAX_FIXED_PRINTOUT_DIGITS, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PATTERN, PATTERNSINFO, PI, POLAR, POWER, PRIME, PRINT, PRINT2DASCII, PRINTFULL, PRINTLATEX, PRINTLIST, PRINTMODE_2DASCII, PRINTMODE_COMPUTER, PRINTMODE_HUMAN, PRINTMODE_LATEX, PRINTMODE_LIST, PRINTOUTRESULT, PRINTPLAIN, PRINT_LEAVE_E_ALONE, PRINT_LEAVE_X_ALONE, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, ROUND, SECRETX, SELFTEST, SETQ, SGN, SHAPE, SILENTPATTERN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOLSINFO, SYMBOL_A, SYMBOL_A_UNDERSCORE, SYMBOL_B, SYMBOL_B_UNDERSCORE, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_IDENTITY_MATRIX, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_X_UNDERSCORE, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TIMING_DEBUGS, TOS, TRACE, TRANSPOSE, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEQ, T_NEWLINE, T_QUOTASSIGN, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, VERSION, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, _print, abs, absValFloat, absval, absval_tensor, add, addSymbolLeftOfAssignment, addSymbolRightOfAssignment, add_all, add_factor_to_accumulator, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, approxAll, approxLogs, approxLogsOfRationals, approxOneRatioOnly, approxRadicals, approxRadicalsOfRationals, approxRationalsOfLogs, approxRationalsOfPowersOfE, approxRationalsOfPowersOfPI, approxRationalsOfRadicals, approxSineOfRationalMultiplesOfPI, approxSineOfRationals, approxTrigonometric, approx_just_an_integer, approx_logarithmsOfRationals, approx_nothingUseful, approx_radicalOfRatio, approx_ratioOfRadical, approx_rationalOfE, approx_rationalOfPi, approx_rationalsOfLogarithms, approx_sine_of_pi_times_rational, approx_sine_of_rational, approxratioRecursive, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, areunivarpolysfactoredorexpandedform, arg, arglist, assignmentFound, avoidCalculatingPowersIntoArctans, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, called_from_Algebra_block, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, chainOfUserSymbolsNotFunctionsBeingEvaluated, charTabIndex, chartab, checkFloatHasWorkedOutCompletely, check_esc_flag, check_stack, check_tensor_dimensions, choose, choose_check_args, circexp, clearAlgebraEnvironment, clearRenamedVariablesToAvoidBindingToExternalScope, clear_symbols, clear_term, clearall, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, codeGen, coeff, cofactor, collectLatexStringFromReturnValue, collectUserSymbols, combine_factors, combine_gammas, combine_terms, compareState, compare_numbers, compare_rationals, compare_tensors, compatible, computeDependenciesFromAlgebra, computeResultsAndJavaScriptFromAlgebra, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, countOccurrencesOfSymbol, count_denominators, counter, countsize, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, defineSomeHandyConstants, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, do_clearPatterns, do_clearall, do_simplify_nested_radicals, dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication, dotprod_unicode, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, evaluatingAsFloats, evaluatingPolar, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f10, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, fill_buf, filter, filter_main, filter_sum, filter_tensor, findDependenciesInScript, findPossibleClockForm, findPossibleExponentialForm, findroot, fixup_fraction, fixup_power, flag, floatToRatioRoutine, fmt_index, fmt_level, fmt_x, frame, freeze, functionInvokationsScanningStack, gamma, gamma_of_sum, gammaf, gcd, gcd_main, gcd_numbers, gcd_polys, gcd_powers_with_same_base, gcd_product_product, gcd_product_sum, gcd_sum, gcd_sum_product, gcd_sum_sum, gen, getSimpleRoots, getStateHash, get_binding, get_factor_from_complex_root, get_factor_from_real_root, get_innerprod_factors, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hasImaginaryCoeff, hasNegativeRationalExponent, hash_addition, hash_function, hash_multiplication, hash_power, hashcode_values, hashed_itab, hermite, hilbert, i1, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, isNumberOneOverSomething, isNumericAtom, isNumericAtomOrTensor, isSimpleRoot, isSmall, isSymbolLeftOfAssignment, isSymbolReclaimable, isZeroAtom, isZeroAtomOrTensor, isZeroLikeOrNonZeroLikeOrUndetermined, isZeroTensor, is_denominator, is_factor, is_small_integer, is_square_matrix, is_usr_symbol, isadd, isalnumorunderscore, isalpha, isalphaOrUnderscore, iscomplexnumber, iscomplexnumberdouble, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isidentitymatrix, isimaginarynumber, isimaginarynumberdouble, isimaginaryunit, isinnerordot, isinteger, isintegerfactor, isintegerorintegerfloat, isinv, iskeyword, isminusone, isminusoneoversqrttwo, isminusoneovertwo, isminussqrtthreeovertwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isone, isoneover, isoneoversqrttwo, isoneovertwo, isplusone, isplustwo, ispolyexpandedform, ispolyexpandedform_expr, ispolyexpandedform_factor, ispolyexpandedform_term, ispolyfactoredorexpandedform, ispolyfactoredorexpandedform_factor, ispolyfactoredorexpandedform_power, isposint, ispositivenumber, ispower, isquarterturn, isrational, isspace, issqrtthree, issqrtthreeovertwo, isstr, issymbol, issymbolic, istensor, istranspose, isunderscore, isunivarpolyfactoredorexpandedform, itab, italu_hashcode, j1, laguerre, laguerre2, lastFoundSymbol, latexErrorSign, lcm, leading, legendre, length, lessp, level, list, listLength, logarithm, logbuf, lookupsTotal, lu_decomp, madd, makePositive, makeSignSameAs, make_hashed_itab, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, moveTos, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_consecutive_constants, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_integer, new_string, newline_flag, nil_symbols, normaliseDots, normalisedCoeff, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, nthCadr, numerator, numericRootOfPolynomial, o, one, oneElement, one_as_double, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, parse_time_simplifications, partition, patternHasBeenFound, patternsinfo, performing_roots, polar, polarRectAMinusOneBase, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, predefinedSymbolsInGlobalScope_doNotTrackInDependencies, prime, primetab, print2dascii, printMode, print_ABS_latex, print_ARCCOS_codegen, print_ARCSIN_codegen, print_ARCTAN_codegen, print_BINOMIAL_latex, print_COS_codegen, print_DEFINT_latex, print_DOT_codegen, print_DOT_latex, print_DO_codegen, print_FOR_codegen, print_INV_codegen, print_INV_latex, print_PRODUCT_codegen, print_PRODUCT_latex, print_SETQ_codegen, print_SIN_codegen, print_SQRT_latex, print_SUM_codegen, print_SUM_latex, print_TAN_codegen, print_TESTEQ_latex, print_TESTGE_latex, print_TESTGT_latex, print_TESTLE_latex, print_TESTLT_latex, print_TEST_codegen, print_TEST_latex, print_TRANSPOSE_codegen, print_TRANSPOSE_latex, print_UNIT_codegen, print_a_over_b, print_base, print_base_of_denom, print_char, print_denom, print_double, print_expo_of_denom, print_exponent, print_expr, print_factor, print_factorial_function, print_glyphs, print_index_function, print_list, print_multiply_sign, print_number, print_power, print_str, print_subexpr, print_tensor, print_tensor_inner, print_tensor_inner_latex, print_tensor_latex, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, pushTryNotToDuplicate, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, recursionLevelNestedRadicalsRemoval, recursiveDependencies, ref, ref1, rememberPrint, remove_negative_exponents, reset_after_error, restore, restoreMetaBindings, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, runUserDefinedSimplifications, save, saveMetaBindings, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call_with_function_name, scan_function_call_without_function_name, scan_index, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_tensor, scan_term, scanned, scanningParameters, setM, setSignTo, set_binding, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, shape, show_power_debug, sign, sign_of_term, simfac, simfac_term, simpleComplexityMeasure, simplify, simplifyForCodeGeneration, simplify_1_in_products, simplify_main, simplify_nested_radicals, simplify_polar, simplify_polarRect, simplify_rational_expressions, simplify_rectToClock, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, skipRootVariableToBeSolved, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringsEmittedByUserPrintouts, subf, subst, subtract, subtract_numbers, swap, symbol, symbolsDependencies, symbolsHavingReassignments, symbolsInExpressionsWithoutAssignments, symbolsLeftOfAssignment, symbolsRightOfAssignment, symbolsinfo, symnum, symtab, take_care_of_nested_radicals, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, testApprox, test_flag, text_metric, theRandom, token, token_buf, token_str, top, top_level_eval, tos, transform, transpose, transpose_unicode, trigmode, trivial_divide, try_kth_prime, turnErrorMessageToLatex, ucmp, unfreeze, unique, unique_f, update_token_buf, userSimplificationsInListForm, userSimplificationsInStringForm, usr_symbol, verbosing, version, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, yround, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymultiply, yyouter, yypower, yyrationalize, yyround, yysgn, yysimfac, yysinh, yytangent, zero, zzfloat,\n    hasProp = {}.hasOwnProperty;\n\n  bigInt = require('big-integer');\n\n  // also change the version in the package.json file\n  version = \"1.4.0\";\n\n  SELFTEST = 1;\n\n  // size of the symbol table\n  NSYM = 1000;\n\n  DEBUG = false;\n\n  PRINTOUTRESULT = false;\n\n  // printing-related constants\n  PRINTMODE_LATEX = \"PRINTMODE_LATEX\";\n\n  PRINTMODE_2DASCII = \"PRINTMODE_2DASCII\";\n\n  PRINTMODE_COMPUTER = \"PRINTMODE_COMPUTER\";\n\n  PRINTMODE_HUMAN = \"PRINTMODE_HUMAN\";\n\n  PRINTMODE_LIST = \"PRINTMODE_LIST\";\n\n  // when the user uses the generic \"print\" statement\n  // this setting kicks-in.\n  printMode = PRINTMODE_COMPUTER;\n\n  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;\n\n  recursionLevelNestedRadicalsRemoval = 0;\n\n  do_simplify_nested_radicals = true;\n\n  avoidCalculatingPowersIntoArctans = true;\n\n  rational = (function() {\n    // Symbolic expressions are built by connecting U structs.\n\n    // For example, (a b + c) is built like this:\n\n    //           _______      _______                                _______\n    //          |CONS   |--->|CONS   |----------------------------->|CONS   |\n    //          |       |    |       |                              |       |\n    //          |_______|    |_______|                              |_______|\n    //              |            |                                      |\n    //           ___v___      ___v___      _______      _______      ___v___\n    //          |ADD    |    |CONS   |--->|CONS   |--->|CONS   |    |SYM c  |\n    //          |       |    |       |    |       |    |       |    |       |\n    //          |_______|    |_______|    |_______|    |_______|    |_______|\n    //                           |            |            |\n    //                        ___v___      ___v___      ___v___\n    //                       |MUL    |    |SYM a  |    |SYM b  |\n    //                       |       |    |       |    |       |\n    //                       |_______|    |_______|    |_______|\n    class rational {};\n\n    rational.prototype.a = null; // a bigInteger\n\n    rational.prototype.b = null; // a bigInteger\n\n    return rational;\n\n  }).call(this);\n\n  U = (function() {\n    class U {\n      toString() {\n        return print_expr(this);\n      }\n\n      toLatexString() {\n        return collectLatexStringFromReturnValue(this);\n      }\n\n      constructor() {\n        this.cons = {};\n        this.cons.car = null;\n        this.cons.cdr = null;\n        this.q = new rational();\n      }\n\n    };\n\n    U.prototype.cons = null; // will have a car and cdr\n\n    U.prototype.printname = \"\";\n\n    U.prototype.str = \"\";\n\n    U.prototype.tensor = null;\n\n    // rational number a over b\n    U.prototype.q = null; // will point to a rational\n\n    U.prototype.d = 0.0; // a double\n\n    U.prototype.k = 0;\n\n    U.prototype.tag = 0;\n\n    return U;\n\n  }).call(this);\n\n  errorMessage = \"\";\n\n  // the following enum is for struct U, member k\n  CONS = 0;\n\n  NUM = 1;\n\n  DOUBLE = 2;\n\n  STR = 3;\n\n  TENSOR = 4;\n\n  SYM = 5;\n\n  // the following enum is for indexing the symbol table\n\n  // standard functions first, then nil, then everything else\n  counter = 0;\n\n  ABS = counter++;\n\n  ADD = counter++;\n\n  ADJ = counter++;\n\n  AND = counter++;\n\n  APPROXRATIO = counter++;\n\n  ARCCOS = counter++;\n\n  ARCCOSH = counter++;\n\n  ARCSIN = counter++;\n\n  ARCSINH = counter++;\n\n  ARCTAN = counter++;\n\n  ARCTANH = counter++;\n\n  ARG = counter++;\n\n  ATOMIZE = counter++;\n\n  BESSELJ = counter++;\n\n  BESSELY = counter++;\n\n  BINDING = counter++;\n\n  BINOMIAL = counter++;\n\n  CEILING = counter++;\n\n  CHECK = counter++;\n\n  CHOOSE = counter++;\n\n  CIRCEXP = counter++;\n\n  CLEAR = counter++;\n\n  CLEARALL = counter++;\n\n  CLEARPATTERNS = counter++;\n\n  CLOCK = counter++;\n\n  COEFF = counter++;\n\n  COFACTOR = counter++;\n\n  CONDENSE = counter++;\n\n  CONJ = counter++;\n\n  CONTRACT = counter++;\n\n  COS = counter++;\n\n  COSH = counter++;\n\n  DECOMP = counter++;\n\n  DEFINT = counter++;\n\n  DEGREE = counter++;\n\n  DENOMINATOR = counter++;\n\n  DERIVATIVE = counter++;\n\n  DET = counter++;\n\n  DIM = counter++;\n\n  DIRAC = counter++;\n\n  DIVISORS = counter++;\n\n  DO = counter++;\n\n  DOT = counter++;\n\n  DRAW = counter++;\n\n  DSOLVE = counter++;\n\n  EIGEN = counter++;\n\n  EIGENVAL = counter++;\n\n  EIGENVEC = counter++;\n\n  ERF = counter++;\n\n  ERFC = counter++;\n\n  EVAL = counter++;\n\n  EXP = counter++;\n\n  EXPAND = counter++;\n\n  EXPCOS = counter++;\n\n  EXPSIN = counter++;\n\n  FACTOR = counter++;\n\n  FACTORIAL = counter++;\n\n  FACTORPOLY = counter++;\n\n  FILTER = counter++;\n\n  FLOATF = counter++;\n\n  FLOOR = counter++;\n\n  FOR = counter++;\n\n  FUNCTION = counter++;\n\n  GAMMA = counter++;\n\n  GCD = counter++;\n\n  HERMITE = counter++;\n\n  HILBERT = counter++;\n\n  IMAG = counter++;\n\n  INDEX = counter++;\n\n  INNER = counter++;\n\n  INTEGRAL = counter++;\n\n  INV = counter++;\n\n  INVG = counter++;\n\n  ISINTEGER = counter++;\n\n  ISPRIME = counter++;\n\n  LAGUERRE = counter++;\n\n  //  LAPLACE = counter++\n  LCM = counter++;\n\n  LEADING = counter++;\n\n  LEGENDRE = counter++;\n\n  LOG = counter++;\n\n  LOOKUP = counter++;\n\n  MOD = counter++;\n\n  MULTIPLY = counter++;\n\n  NOT = counter++;\n\n  NROOTS = counter++;\n\n  NUMBER = counter++;\n\n  NUMERATOR = counter++;\n\n  OPERATOR = counter++;\n\n  OR = counter++;\n\n  OUTER = counter++;\n\n  PATTERN = counter++;\n\n  PATTERNSINFO = counter++;\n\n  POLAR = counter++;\n\n  POWER = counter++;\n\n  PRIME = counter++;\n\n  PRINT_LEAVE_E_ALONE = counter++;\n\n  PRINT_LEAVE_X_ALONE = counter++;\n\n  PRINT = counter++;\n\n  PRINT2DASCII = counter++;\n\n  PRINTFULL = counter++;\n\n  PRINTLATEX = counter++;\n\n  PRINTLIST = counter++;\n\n  PRINTPLAIN = counter++;\n\n  PRODUCT = counter++;\n\n  QUOTE = counter++;\n\n  QUOTIENT = counter++;\n\n  RANK = counter++;\n\n  RATIONALIZE = counter++;\n\n  REAL = counter++;\n\n  ROUND = counter++;\n\n  YYRECT = counter++;\n\n  ROOTS = counter++;\n\n  SETQ = counter++;\n\n  SGN = counter++;\n\n  SILENTPATTERN = counter++;\n\n  SIMPLIFY = counter++;\n\n  SIN = counter++;\n\n  SINH = counter++;\n\n  SHAPE = counter++;\n\n  SQRT = counter++;\n\n  STOP = counter++;\n\n  SUBST = counter++;\n\n  SUM = counter++;\n\n  SYMBOLSINFO = counter++;\n\n  TAN = counter++;\n\n  TANH = counter++;\n\n  TAYLOR = counter++;\n\n  TEST = counter++;\n\n  TESTEQ = counter++;\n\n  TESTGE = counter++;\n\n  TESTGT = counter++;\n\n  TESTLE = counter++;\n\n  TESTLT = counter++;\n\n  TRANSPOSE = counter++;\n\n  UNIT = counter++;\n\n  ZERO = counter++;\n\n  // ALL THE SYMBOLS ABOVE NIL ARE KEYWORDS,\n  // WHICH MEANS THAT USER CANNOT REDEFINE THEM\n  NIL = counter++; // nil goes here, after standard functions\n\n  LAST = counter++;\n\n  LAST_PRINT = counter++;\n\n  LAST_2DASCII_PRINT = counter++;\n\n  LAST_FULL_PRINT = counter++;\n\n  LAST_LATEX_PRINT = counter++;\n\n  LAST_LIST_PRINT = counter++;\n\n  LAST_PLAIN_PRINT = counter++;\n\n  AUTOEXPAND = counter++;\n\n  BAKE = counter++;\n\n  ASSUME_REAL_VARIABLES = counter++;\n\n  TRACE = counter++;\n\n  FORCE_FIXED_PRINTOUT = counter++;\n\n  MAX_FIXED_PRINTOUT_DIGITS = counter++;\n\n  YYE = counter++;\n\n  DRAWX = counter++; // special purpose internal symbols\n\n  METAA = counter++;\n\n  METAB = counter++;\n\n  METAX = counter++;\n\n  SECRETX = counter++;\n\n  VERSION = counter++;\n\n  PI = counter++;\n\n  SYMBOL_A = counter++;\n\n  SYMBOL_B = counter++;\n\n  SYMBOL_C = counter++;\n\n  SYMBOL_D = counter++;\n\n  SYMBOL_I = counter++;\n\n  SYMBOL_J = counter++;\n\n  SYMBOL_N = counter++;\n\n  SYMBOL_R = counter++;\n\n  SYMBOL_S = counter++;\n\n  SYMBOL_T = counter++;\n\n  SYMBOL_X = counter++;\n\n  SYMBOL_Y = counter++;\n\n  SYMBOL_Z = counter++;\n\n  SYMBOL_IDENTITY_MATRIX = counter++;\n\n  SYMBOL_A_UNDERSCORE = counter++;\n\n  SYMBOL_B_UNDERSCORE = counter++;\n\n  SYMBOL_X_UNDERSCORE = counter++;\n\n  C1 = counter++;\n\n  C2 = counter++;\n\n  C3 = counter++;\n\n  C4 = counter++;\n\n  C5 = counter++;\n\n  C6 = counter++;\n\n  USR_SYMBOLS = counter++; // this must be last\n\n  E = YYE;\n\n  // TOS cannot be arbitrarily large because the OS seg faults on deep recursion.\n  // For example, a circular evaluation like x=x+1 can cause a seg fault.\n  // At this setting (100,000) the evaluation stack overruns before seg fault.\n  TOS = 100000;\n\n  BUF = 10000;\n\n  MAX_PROGRAM_SIZE = 100001;\n\n  MAXPRIMETAB = 10000;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;\n\n  //define _USE_MATH_DEFINES // for MS C++\n  MAXDIM = 24;\n\n  // needed for the mechanism to\n  // find all dependencies between variables\n  // in a script\n  symbolsDependencies = {};\n\n  symbolsHavingReassignments = [];\n\n  symbolsInExpressionsWithoutAssignments = [];\n\n  patternHasBeenFound = false;\n\n  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [\"rationalize\", \"abs\", \"e\", \"i\", \"pi\", \"sin\", \"ceiling\", \"cos\", \"roots\", \"integral\", \"derivative\", \"defint\", \"sqrt\", \"eig\", \"cov\", \"deig\", \"dcov\", \"float\", \"floor\", \"product\", \"root\", \"round\", \"sum\", \"test\", \"unit\"];\n\n  // you can do some little simplifications\n  // at parse time, such as calculating away\n  // immediately simple operations on\n  // constants, removing 1s from products\n  // etc.\n  parse_time_simplifications = true;\n\n  chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n\n  stringsEmittedByUserPrintouts = \"\";\n\n  // flag use to potentially switch on/off some quirks \"deep\"\n  // in the code due to call from Algebra block.\n  // Currently not used.\n  called_from_Algebra_block = false;\n\n  tensor = (function() {\n    class tensor {\n      constructor() {\n        this.dim = (function() {\n          var o, ref, results;\n          results = [];\n          for (o = 0, ref = MAXDIM; (0 <= ref ? o <= ref : o >= ref); 0 <= ref ? o++ : o--) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.elem = [];\n      }\n\n    };\n\n    tensor.prototype.ndim = 0; // number of dimensions\n\n    tensor.prototype.dim = null; // dimension length, for each dimension\n\n    tensor.prototype.nelem = 0; // total number of elements\n\n    tensor.prototype.elem = null; // an array containing all the data\n\n    return tensor;\n\n  }).call(this);\n\n  display = (function() {\n    class display {};\n\n    display.prototype.h = 0;\n\n    display.prototype.w = 0;\n\n    display.prototype.n = 0;\n\n    display.prototype.a = []; // will contain an array of c,x,y (color,x,y)\n\n    return display;\n\n  }).call(this);\n\n  text_metric = (function() {\n    class text_metric {};\n\n    text_metric.prototype.ascent = 0;\n\n    text_metric.prototype.descent = 0;\n\n    text_metric.prototype.width = 0;\n\n    return text_metric;\n\n  }).call(this);\n\n  tos = 0; // top of stack\n\n  expanding = 0;\n\n  evaluatingAsFloats = 0;\n\n  evaluatingPolar = 0;\n\n  fmt_x = 0;\n\n  fmt_index = 0;\n\n  fmt_level = 0;\n\n  verbosing = 0;\n\n  primetab = (function() {\n    var ceil, i, j, primes;\n    primes = [2];\n    i = 3;\n    while (primes.length < MAXPRIMETAB) {\n      j = 0;\n      ceil = Math.sqrt(i);\n      while (j < primes.length && primes[j] <= ceil) {\n        if (i % primes[j] === 0) {\n          j = -1;\n          break;\n        }\n        j++;\n      }\n      if (j !== -1) {\n        primes.push(i);\n      }\n      i += 2;\n    }\n    primes[MAXPRIMETAB] = 0;\n    return primes;\n  })();\n\n  esc_flag = 0;\n\n  draw_flag = 0;\n\n  mtotal = 0;\n\n  trigmode = 0;\n\n  logbuf = \"\";\n\n  program_buf = \"\";\n\n  // will contain the variable names\n  symtab = [];\n\n  // will contain the contents of the variable\n  // in the corresponding position in symtab array\n  binding = [];\n\n  isSymbolReclaimable = [];\n\n  arglist = []; // will contain U\n\n  stack = []; // will contain *U\n\n  frame = 0;\n\n  p0 = null; // will contain U\n\n  p1 = null; // will contain U\n\n  p2 = null; // will contain U\n\n  p3 = null; // will contain U\n\n  p4 = null; // will contain U\n\n  p5 = null; // will contain U\n\n  p6 = null; // will contain U\n\n  p7 = null; // will contain U\n\n  p8 = null; // will contain U\n\n  p9 = null; // will contain U\n\n  zero = null; // will contain U\n\n  one = null; // will contain U\n\n  one_as_double = null;\n\n  imaginaryunit = null; // will contain U\n\n  out_buf = \"\";\n\n  out_count = 0;\n\n  test_flag = 0;\n\n  codeGen = false;\n\n  draw_stop_return = null; // extern jmp_buf ?????\n\n  userSimplificationsInListForm = [];\n\n  userSimplificationsInStringForm = [];\n\n  transpose_unicode = 7488;\n\n  dotprod_unicode = 183;\n\n  symbol = function(x) {\n    return symtab[x];\n  };\n\n  iscons = function(p) {\n    return p.k === CONS;\n  };\n\n  isrational = function(p) {\n    return p.k === NUM;\n  };\n\n  isdouble = function(p) {\n    return p.k === DOUBLE;\n  };\n\n  isNumericAtom = function(p) {\n    return isrational(p) || isdouble(p);\n  };\n\n  isstr = function(p) {\n    return p.k === STR;\n  };\n\n  istensor = function(p) {\n    if (p == null) {\n      debugger;\n    } else {\n      return p.k === TENSOR;\n    }\n  };\n\n  // because of recursion, we consider a scalar to be\n  // a tensor, so a numeric scalar will return true\n  isNumericAtomOrTensor = function(p) {\n    var a, i, n, o, ref;\n    if (isNumericAtom(p) || p === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      return 1;\n    }\n    if (!istensor(p) && !isNumericAtom(p)) {\n      //console.log \"p not an atom nor a tensor: \" + p\n      return 0;\n    }\n    n = p.tensor.nelem;\n    a = p.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtomOrTensor(a[i])) {\n        //console.log \"non-numeric element: \" + a[i]\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  issymbol = function(p) {\n    return p.k === SYM;\n  };\n\n  iskeyword = function(p) {\n    return issymbol(p) && symnum(p) < NIL;\n  };\n\n  car = function(p) {\n    if (iscons(p)) {\n      return p.cons.car;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  cdr = function(p) {\n    if (iscons(p)) {\n      return p.cons.cdr;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  caar = function(p) {\n    return car(car(p));\n  };\n\n  cadr = function(p) {\n    return car(cdr(p));\n  };\n\n  cdar = function(p) {\n    return cdr(car(p));\n  };\n\n  cddr = function(p) {\n    return cdr(cdr(p));\n  };\n\n  caadr = function(p) {\n    return car(car(cdr(p)));\n  };\n\n  caddr = function(p) {\n    return car(cdr(cdr(p)));\n  };\n\n  cadar = function(p) {\n    return car(cdr(car(p)));\n  };\n\n  cdadr = function(p) {\n    return cdr(car(cdr(p)));\n  };\n\n  cddar = function(p) {\n    return cdr(cdr(car(p)));\n  };\n\n  cdddr = function(p) {\n    return cdr(cdr(cdr(p)));\n  };\n\n  caaddr = function(p) {\n    return car(car(cdr(cdr(p))));\n  };\n\n  cadadr = function(p) {\n    return car(cdr(car(cdr(p))));\n  };\n\n  caddar = function(p) {\n    return car(cdr(cdr(car(p))));\n  };\n\n  cdaddr = function(p) {\n    return cdr(car(cdr(cdr(p))));\n  };\n\n  cadddr = function(p) {\n    return car(cdr(cdr(cdr(p))));\n  };\n\n  cddddr = function(p) {\n    return cdr(cdr(cdr(cdr(p))));\n  };\n\n  caddddr = function(p) {\n    return car(cdr(cdr(cdr(cdr(p)))));\n  };\n\n  cadaddr = function(p) {\n    return car(cdr(car(cdr(cdr(p)))));\n  };\n\n  cddaddr = function(p) {\n    return cdr(cdr(car(cdr(cdr(p)))));\n  };\n\n  caddadr = function(p) {\n    return car(cdr(cdr(car(cdr(p)))));\n  };\n\n  cdddaddr = function(p) {\n    return cdr(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  caddaddr = function(p) {\n    return car(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  // not used yet\n  listLength = function(p) {\n    var startCount;\n    startCount = -1;\n    while (iscons(p)) {\n      p = cdr(p);\n      startCount++;\n    }\n    return startCount;\n  };\n\n  // not used yet\n  nthCadr = function(p, n) {\n    var startCount;\n    startCount = 0;\n    while (startCount <= n) {\n      p = cdr(p);\n      startCount++;\n    }\n    return car(p);\n  };\n\n  isadd = function(p) {\n    return car(p) === symbol(ADD);\n  };\n\n  ismultiply = function(p) {\n    return car(p) === symbol(MULTIPLY);\n  };\n\n  ispower = function(p) {\n    return car(p) === symbol(POWER);\n  };\n\n  isfactorial = function(p) {\n    return car(p) === symbol(FACTORIAL);\n  };\n\n  isinnerordot = function(p) {\n    return (car(p) === symbol(INNER)) || (car(p) === symbol(DOT));\n  };\n\n  istranspose = function(p) {\n    return car(p) === symbol(TRANSPOSE);\n  };\n\n  isinv = function(p) {\n    return car(p) === symbol(INV);\n  };\n\n  // TODO this is a bit of a shallow check, we should\n  // check when we are passed an actual tensor and possibly\n  // cache the test result.\n  isidentitymatrix = function(p) {\n    return p === symbol(SYMBOL_IDENTITY_MATRIX);\n  };\n\n  MSIGN = function(p) {\n    if (p.isPositive()) {\n      return 1;\n    } else if (p.isZero()) {\n      return 0;\n    } else {\n      return -1;\n    }\n  };\n\n  MLENGTH = function(p) {\n    return p.toString().length;\n  };\n\n  MZERO = function(p) {\n    return p.isZero();\n  };\n\n  MEQUAL = function(p, n) {\n    if (p == null) {\n      debugger;\n    }\n    return p.equals(n);\n  };\n\n  reset_after_error = function() {\n    moveTos(0);\n    esc_flag = 0;\n    draw_flag = 0;\n    frame = TOS;\n    evaluatingAsFloats = 0;\n    return evaluatingPolar = 0;\n  };\n\n  $ = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n\n  $.version = version;\n\n  $.isadd = isadd;\n\n  $.ismultiply = ismultiply;\n\n  $.ispower = ispower;\n\n  $.isfactorial = isfactorial;\n\n  $.car = car;\n\n  $.cdr = cdr;\n\n  $.caar = caar;\n\n  $.cadr = cadr;\n\n  $.cdar = cdar;\n\n  $.cddr = cddr;\n\n  $.caadr = caadr;\n\n  $.caddr = caddr;\n\n  $.cadar = cadar;\n\n  $.cdadr = cdadr;\n\n  $.cddar = cddar;\n\n  $.cdddr = cdddr;\n\n  $.caaddr = caaddr;\n\n  $.cadadr = cadadr;\n\n  $.caddar = caddar;\n\n  $.cdaddr = cdaddr;\n\n  $.cadddr = cadddr;\n\n  $.cddddr = cddddr;\n\n  $.caddddr = caddddr;\n\n  $.cadaddr = cadaddr;\n\n  $.cddaddr = cddaddr;\n\n  $.caddadr = caddadr;\n\n  $.cdddaddr = cdddaddr;\n\n  $.caddaddr = caddaddr;\n\n  $.symbol = symbol;\n\n  $.iscons = iscons;\n\n  $.isrational = isrational;\n\n  $.isdouble = isdouble;\n\n  $.isNumericAtom = isNumericAtom;\n\n  $.isstr = isstr;\n\n  $.istensor = istensor;\n\n  $.issymbol = issymbol;\n\n  $.iskeyword = iskeyword;\n\n  $.CONS = CONS;\n\n  $.NUM = NUM;\n\n  $.DOUBLE = DOUBLE;\n\n  $.STR = STR;\n\n  $.TENSOR = TENSOR;\n\n  $.SYM = SYM;\n\n  \n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* abs =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.\n\n  */\n  /*\n   Absolute value of a number,or magnitude of complex z, or norm of a vector\n\n    z    abs(z)\n    -    ------\n\n    a    a\n\n    -a    a\n\n    (-1)^a    1\n\n    exp(a + i b)  exp(a)\n\n    a b    abs(a) abs(b)\n\n    a + i b    sqrt(a^2 + b^2)\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      abs(numerator(z)) / abs(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  DEBUG_ABS = false;\n\n  Eval_abs = function() {\n    push(cadr(p1));\n    Eval();\n    return abs();\n  };\n\n  absValFloat = function() {\n    Eval();\n    absval();\n    Eval();\n    return zzfloat();\n  };\n\n  // zzfloat of an abs doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, these two lines come handy to highlight\n  // when that doesn't happen for those tests.\n  //if !isdouble(stack[tos-1])\n  //  stop(\"absValFloat should return a double and instead got: \" + stack[tos-1])\n  abs = function() {\n    var theArgument;\n    theArgument = top();\n    if (DEBUG_ABS) {\n      console.trace(\">>>>  ABS of \" + theArgument);\n    }\n    numerator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS numerator \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL numerator: \" + stack[tos - 1]);\n    }\n    push(theArgument);\n    denominator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS denominator: \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL denominator: \" + stack[tos - 1]);\n    }\n    divide();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL divided: \" + stack[tos - 1]);\n    }\n    if (DEBUG_ABS) {\n      return console.log(\"<<<<<<<  ABS\");\n    }\n  };\n\n  absval = function() {\n    var anyFactorsYet, input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_ABS) {\n      console.log(\"ABS of \" + p1);\n    }\n    // handle all the \"number\" cases first -----------------------------------------\n    if (isZeroAtomOrTensor(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just zero\");\n      }\n      push(zero);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a negative\");\n      }\n      push(p1);\n      negate();\n      restore();\n      return;\n    }\n    if (ispositivenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a positive\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (p1 === symbol(PI)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" of PI\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // ??? should there be a shortcut case here for the imaginary unit?\n\n    // now handle decomposition cases ----------------------------------------------\n\n    // we catch the \"add\", \"power\", \"multiply\" cases first,\n    // before falling back to the\n    // negative/positive cases because there are some\n    // simplification thay we might be able to do.\n    // Note that for this routine to give a correct result, this\n    // must be a sum where a complex number appears.\n    // If we apply this to \"a+b\", we get an incorrect result.\n    if (car(p1) === symbol(ADD) && (findPossibleClockForm(p1) || findPossibleExponentialForm(p1) || Find(p1, imaginaryunit))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a sum\");\n      }\n      if (DEBUG_ABS) {\n        console.log(\"abs of a sum\");\n      }\n      // sum\n      push(p1);\n      rect(); // convert polar terms, if any\n      p1 = pop();\n      push(p1);\n      real();\n      push_integer(2);\n      power();\n      push(p1);\n      imag();\n      push_integer(2);\n      power();\n      add();\n      push_rational(1, 2);\n      power();\n      simplify_trig();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is -1 to any power\");\n      }\n      // -1 to any power\n      if (evaluatingAsFloats) {\n        if (DEBUG_ABS) {\n          console.log(\" abs: numeric, so result is 1.0\");\n        }\n        push_double(1.0);\n      } else {\n        if (DEBUG_ABS) {\n          console.log(\" abs: symbolic, so result is 1\");\n        }\n        push_integer(1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(a^b) is equal to abs(a)^b IF b is positive\n    if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is something to the power of a positive number\");\n      }\n      push(cadr(p1));\n      abs();\n      push(caddr(p1));\n      power();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(e^something)\n    if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is an exponential\");\n      }\n      // exponential\n      push(caddr(p1));\n      real();\n      exponential();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a product\");\n      }\n      // product\n      anyFactorsYet = false;\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        absval();\n        if (anyFactorsYet) {\n          multiply();\n        }\n        anyFactorsYet = true;\n        p1 = cdr(p1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is abs of a abs\");\n      }\n      // abs of a abs\n      push_symbol(ABS);\n      push(cadr(p1));\n      list(2);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    /*\n     * Evaluation via zzfloat()\n     * ...while this is in theory a powerful mechanism, I've commented it\n     * out because I've refined this method enough to not need this.\n     * Evaling via zzfloat() is in principle more problematic because it could\n     * require further evaluations which could end up in further \"abs\" which\n     * would end up in infinite loops. Better not use it if not necessary.\n\n     * we look directly at the float evaluation of the argument\n     * to see if we end up with a number, which would mean that there\n     * is no imaginary component and we can just return the input\n     * (or its negation) as the result.\n    push p1\n    zzfloat()\n    floatEvaluation = pop()\n\n    if (isnegativenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a negative\"\n      push(p1)\n      negate()\n      restore()\n      return\n\n    if (ispositivenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a positive\"\n      push(p1)\n      if DEBUG_ABS then console.log \" --> ABS of \" + input + \" : \" + stack[tos-1]\n      restore()\n      return\n     */\n    if (istensor(p1)) {\n      absval_tensor();\n      restore();\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    if (DEBUG_ABS) {\n      console.log(\" abs: \" + p1 + \" is nothing decomposable\");\n    }\n    push_symbol(ABS);\n    push(p1);\n    list(2);\n    if (DEBUG_ABS) {\n      console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // also called the \"norm\" of a vector\n  absval_tensor = function() {\n    if (p1.tensor.ndim !== 1) {\n      stop(\"abs(tensor) with tensor rank > 1\");\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    inner();\n    push_rational(1, 2);\n    power();\n    simplify();\n    return Eval();\n  };\n\n  flag = 0;\n\n  Eval_add = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p2 = pop();\n      push_terms(p2);\n      p1 = cdr(p1);\n    }\n    return add_terms(tos - h);\n  };\n\n  // Add n terms, returns one expression on the stack.\n  stackAddsCount = 0;\n\n  add_terms = function(n) {\n    var h, i, i1, j1, o, ref, ref1, results, s, subsetOfStack;\n    stackAddsCount++;\n    i = 0;\n    h = tos - n;\n    s = h;\n    // ensure no infinite loop, use \"for\"\n    if (DEBUG) {\n      console.log(\"stack before adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 137\n    //  debugger\n    if (DEBUG) {\n      for (i = o = 0, ref = tos; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        console.log(print_list(stack[i]));\n      }\n    }\n    for (i = i1 = 0; i1 < 10; i = ++i1) {\n      if (n < 2) {\n        break;\n      }\n      flag = 0;\n      //qsort(s, n, sizeof (U *), cmp_terms)\n      subsetOfStack = stack.slice(h, h + n);\n      subsetOfStack.sort(cmp_terms);\n      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n      if (flag === 0) {\n        break;\n      }\n      n = combine_terms(h, n);\n    }\n    moveTos(h + n);\n    switch (n) {\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        break;\n      default:\n        list(n);\n        p1 = pop();\n        push_symbol(ADD);\n        push(p1);\n        cons();\n    }\n    if (DEBUG) {\n      console.log(\"stack after adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 5\n    //  debugger\n    if (DEBUG) {\n      results = [];\n      for (i = j1 = 0, ref1 = tos; (0 <= ref1 ? j1 < ref1 : j1 > ref1); i = 0 <= ref1 ? ++j1 : --j1) {\n        results.push(console.log(print_list(stack[i])));\n      }\n      return results;\n    }\n  };\n\n  // Compare terms for order, clobbers p1 and p2.\n  cmp_terms_count = 0;\n\n  cmp_terms = function(p1, p2) {\n    var i, o, ref, t;\n    cmp_terms_count++;\n    //if cmp_terms_count == 52\n    //  debugger\n    i = 0;\n    // numbers can be combined\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    // congruent tensors can be combined\n    if (istensor(p1) && istensor(p2)) {\n      if (p1.tensor.ndim < p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n        return -1;\n      }\n      if (p1.tensor.ndim > p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n        return 1;\n      }\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n          return -1;\n        }\n        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n          return 1;\n        }\n      }\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        p1 = cdr(p1);\n        if (cdr(p1) === symbol(NIL)) {\n          p1 = car(p1);\n        }\n      }\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n      if (isNumericAtom(car(p2))) {\n        p2 = cdr(p2);\n        if (cdr(p2) === symbol(NIL)) {\n          p2 = car(p2);\n        }\n      }\n    }\n    t = cmp_expr(p1, p2);\n    if (t === 0) {\n      flag = 1;\n    }\n    //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns \" + t\n    return t;\n  };\n\n  combine_terms = function(s, n) {\n    var i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;\n    //debugger\n\n    // I had to turn the coffeescript for loop into\n    // a more mundane while loop because the i\n    // variable was changed from within the body,\n    // which is something that is not supposed to\n    // happen in the coffeescript 'vector' form.\n    // Also this means I had to add a 'i++' jus before\n    // the end of the body and before the \"continue\"s\n    i = 0;\n    while (i < (n - 1)) {\n      check_esc_flag();\n      p3 = stack[s + i];\n      p4 = stack[s + i + 1];\n      if (istensor(p3) && istensor(p4)) {\n        push(p3);\n        push(p4);\n        tensor_plus_tensor();\n        p1 = pop();\n        if (p1 !== symbol(NIL)) {\n          stack[s + i] = p1;\n          for (j = o = ref = i + 1, ref1 = n - 1; (ref <= ref1 ? o < ref1 : o > ref1); j = ref <= ref1 ? ++o : --o) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n          i--;\n        }\n        i++;\n        continue;\n      }\n      if (istensor(p3) || istensor(p4)) {\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) && isNumericAtom(p4)) {\n        push(p3);\n        push(p4);\n        add_numbers();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          for (j = i1 = ref2 = i, ref3 = n - 2; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); j = ref2 <= ref3 ? ++i1 : --i1) {\n            stack[s + j] = stack[s + j + 2];\n          }\n          n -= 2;\n        } else {\n          stack[s + i] = p1;\n          for (j = j1 = ref4 = i + 1, ref5 = n - 1; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); j = ref4 <= ref5 ? ++j1 : --j1) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n        }\n        i--;\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) || isNumericAtom(p4)) {\n        i++;\n        continue;\n      }\n      if (evaluatingAsFloats) {\n        p1 = one_as_double;\n        p2 = one_as_double;\n      } else {\n        p1 = one;\n        p2 = one;\n      }\n      t = 0;\n      if (car(p3) === symbol(MULTIPLY)) {\n        p3 = cdr(p3);\n        t = 1;\n        if (isNumericAtom(car(p3))) {\n          p1 = car(p3);\n          p3 = cdr(p3);\n          if (cdr(p3) === symbol(NIL)) {\n            p3 = car(p3);\n            t = 0;\n          }\n        }\n      }\n      if (car(p4) === symbol(MULTIPLY)) {\n        p4 = cdr(p4);\n        if (isNumericAtom(car(p4))) {\n          p2 = car(p4);\n          p4 = cdr(p4);\n          if (cdr(p4) === symbol(NIL)) {\n            p4 = car(p4);\n          }\n        }\n      }\n      if (!equal(p3, p4)) {\n        i++;\n        continue;\n      }\n      push(p1);\n      push(p2);\n      add_numbers();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        for (j = l1 = ref6 = i, ref7 = n - 2; (ref6 <= ref7 ? l1 < ref7 : l1 > ref7); j = ref6 <= ref7 ? ++l1 : --l1) {\n          stack[s + j] = stack[s + j + 2];\n        }\n        n -= 2;\n        i--;\n        i++;\n        continue;\n      }\n      push(p1);\n      if (t) {\n        push(symbol(MULTIPLY));\n        push(p3);\n        cons();\n      } else {\n        push(p3);\n      }\n      multiply();\n      stack[s + i] = pop();\n      for (j = m1 = ref8 = i + 1, ref9 = n - 1; (ref8 <= ref9 ? m1 < ref9 : m1 > ref9); j = ref8 <= ref9 ? ++m1 : --m1) {\n        stack[s + j] = stack[s + j + 1];\n      }\n      n--;\n      i--;\n      // this i++ is to match the while\n      i++;\n    }\n    return n;\n  };\n\n  push_terms = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else if (!isZeroAtom(p)) {\n      return push(p);\n    }\n  };\n\n  // add two expressions\n  add = function() {\n    var h;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push_terms(p1);\n    push_terms(p2);\n    add_terms(tos - h);\n    return restore();\n  };\n\n  add_all = function(k) {\n    var h, i, o, ref, s;\n    i = 0;\n    save();\n    s = tos - k;\n    h = tos;\n    for (i = o = 0, ref = k; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push_terms(stack[s + i]);\n    }\n    add_terms(tos - h);\n    p1 = pop();\n    moveTos(tos - k);\n    push(p1);\n    return restore();\n  };\n\n  subtract = function() {\n    negate();\n    return add();\n  };\n\n  Eval_adj = function() {\n    push(cadr(p1));\n    Eval();\n    return adj();\n  };\n\n  adj = function() {\n    var doNothing, i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"adj: square matrix expected\");\n    }\n    n = p1.tensor.dim[0];\n    p2 = alloc_tensor(n * n);\n    p2.tensor.ndim = 2;\n    p2.tensor.dim[0] = n;\n    p2.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        cofactor(p1, n, i, j);\n        p2.tensor.elem[n * j + i] = pop(); // transpose\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  Eval_approxratio = function() {\n    var theArgument;\n    theArgument = cadr(p1);\n    push(theArgument);\n    return approxratioRecursive();\n  };\n\n  approxratioRecursive = function() {\n    var i, i1, o, ref, ref1;\n    i = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n        approxratioRecursive();\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n      push(p4);\n    } else if (p1.k === DOUBLE) {\n      push(p1);\n      approxOneRatioOnly();\n    } else if (iscons(p1)) {\n      push(car(p1));\n      approxratioRecursive();\n      push(cdr(p1));\n      approxratioRecursive();\n      cons();\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  approxOneRatioOnly = function() {\n    var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;\n    zzfloat();\n    supposedlyTheFloat = pop();\n    if (supposedlyTheFloat.k === DOUBLE) {\n      theFloat = supposedlyTheFloat.d;\n      splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n      if (splitBeforeAndAfterDot.length === 2) {\n        numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n        precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n        theRatio = floatToRatioRoutine(theFloat, precision);\n        push_rational(theRatio[0], theRatio[1]);\n      } else {\n        push_integer(theFloat);\n      }\n      return;\n    }\n    // we didn't manage, just leave unexpressed\n    push_symbol(APPROXRATIO);\n    push(theArgument);\n    return list(2);\n  };\n\n  // original routine by John Kennedy, see\n  // https://web.archive.org/web/20111027100847/http://homepage.smc.edu/kennedy_john/DEC2FRAC.PDF\n  // courtesy of Michael Borcherds\n  // who ported this to JavaScript under MIT licence\n  // also see\n  // https://github.com/geogebra/geogebra/blob/master/common/src/main/java/org/geogebra/common/kernel/algos/AlgoFractionText.java\n  // potential other ways to do this:\n  //   https://rosettacode.org/wiki/Convert_decimal_number_to_rational\n  //   http://www.homeschoolmath.net/teaching/rational_numbers.php\n  //   http://stackoverflow.com/questions/95727/how-to-convert-floats-to-human-readable-fractions\n  floatToRatioRoutine = function(decimal, AccuracyFactor) {\n    var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z, ret;\n    FractionNumerator = void 0;\n    FractionDenominator = void 0;\n    DecimalSign = void 0;\n    Z = void 0;\n    PreviousDenominator = void 0;\n    ScratchValue = void 0;\n    ret = [0, 0];\n    if (isNaN(decimal)) {\n      return ret;\n    }\n    // return 0/0 \n    if (decimal === 2e308) {\n      ret[0] = 1;\n      ret[1] = 0;\n      // 1/0\n      return ret;\n    }\n    if (decimal === -2e308) {\n      ret[0] = -1;\n      ret[1] = 0;\n      // -1/0\n      return ret;\n    }\n    if (decimal < 0.0) {\n      DecimalSign = -1.0;\n    } else {\n      DecimalSign = 1.0;\n    }\n    decimal = Math.abs(decimal);\n    if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {\n      // handles exact integers including 0 \n      FractionNumerator = decimal * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal < 1.0e-19) {\n      // X = 0 already taken care of \n      FractionNumerator = DecimalSign;\n      FractionDenominator = 9999999999999999999.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal > 1.0e19) {\n      FractionNumerator = 9999999999999999999.0 * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    Z = decimal;\n    PreviousDenominator = 0.0;\n    FractionDenominator = 1.0;\n    while (true) {\n      Z = 1.0 / (Z - Math.floor(Z));\n      ScratchValue = FractionDenominator;\n      FractionDenominator = FractionDenominator * Math.floor(Z) + PreviousDenominator;\n      PreviousDenominator = ScratchValue;\n      FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);\n      // Rounding Function\n      if (!(Math.abs(decimal - (FractionNumerator / FractionDenominator)) > AccuracyFactor && Z !== Math.floor(Z))) {\n        break;\n      }\n    }\n    FractionNumerator = DecimalSign * FractionNumerator;\n    ret[0] = FractionNumerator;\n    ret[1] = FractionDenominator;\n    return ret;\n  };\n\n  approx_just_an_integer = 0;\n\n  approx_sine_of_rational = 1;\n\n  approx_sine_of_pi_times_rational = 2;\n\n  approx_rationalOfPi = 3;\n\n  approx_radicalOfRatio = 4;\n\n  approx_nothingUseful = 5;\n\n  approx_ratioOfRadical = 6;\n\n  approx_rationalOfE = 7;\n\n  approx_logarithmsOfRationals = 8;\n\n  approx_rationalsOfLogarithms = 9;\n\n  approxRationalsOfRadicals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      for (j = i1 = 1; i1 <= 10; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sqrt( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicalsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, ref1, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [1, 2, 3, 5, 6, 7, 8, 10];\n    // this one catches things like Math.sqrt(3/4), but\n    // things like Math.sqrt(1/2) are caught by the paragraph\n    // above (and in a better form)\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (sqrt( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicals = function(theFloat) {\n    var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n\n    // we always prefer a rational of a radical of an integer\n    // to a radical of a rational. Radicals of rationals generate\n    // radicals at the denominator which we'd rather avoid\n    approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);\n    if (approxRationalsOfRadicalsResult != null) {\n      return approxRationalsOfRadicalsResult;\n    }\n    approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);\n    if (approxRadicalsOfRationalsResult != null) {\n      return approxRadicalsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxLogs = function(theFloat) {\n    var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a rational of a log to a log of\n    // a rational\n    approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);\n    if (approxRationalsOfLogsResult != null) {\n      return approxRationalsOfLogsResult;\n    }\n    approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);\n    if (approxLogsOfRationalsResult != null) {\n      return approxLogsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxRationalsOfLogs = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of logs\n    for (i = o = 2; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n\n        // it does happen that due to roundings \n        // a \"higher multiple\" is picked, which is obviously\n        // unintended.\n        // E.g. 1 * log(1 / 3 ) doesn't match log( 3 ) BUT\n        // it matches -5 * log( 3 ) / 5\n        // so we avoid any case where the multiplier is a multiple\n        // of the divisor.\n        if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j)) === Math.abs(likelyMultiplier / j)) {\n          continue;\n        }\n        if (error < 2.2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxLogsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple logs of rationals\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 1.96 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfE = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of e\n    for (i = o = 1; o <= 2; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.E, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (e ^ \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    // here we do somethng a little special: since\n    // the powers of pi can get quite big, there might\n    // be multiple hypothesis where more of the\n    // magnitude is shifted to the multiplier, and some\n    // where more of the magnitude is shifted towards the\n    // exponent of pi. So we prefer the hypotheses with the\n    // lower multiplier since it's likely to insert more\n    // information.\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of PI\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.PI, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (pi ^ \" + i + \" ) / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    //console.log \"approxRationalsOfPowersOfPI returning: \" + bestResultSoFar\n    return bestResultSoFar;\n  };\n\n  approxTrigonometric = function(theFloat) {\n    var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a sin of a rational without the PI\n    approxSineOfRationalsResult = approxSineOfRationals(theFloat);\n    if (approxSineOfRationalsResult != null) {\n      return approxSineOfRationalsResult;\n    }\n    approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);\n    if (approxSineOfRationalMultiplesOfPIResult != null) {\n      return approxSineOfRationalMultiplesOfPIResult;\n    }\n    return null;\n  };\n\n  approxSineOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// we only check very simple rationals because they begin to get tricky\n// quickly, also they collide often with the \"rational of pi\" hypothesis.\n// For example sin(11) is veeery close to 1 (-0.99999020655)\n// (see: http://mathworld.wolfram.com/AlmostInteger.html )\n// we stop at rationals that mention up to 10\n    for (i = o = 1; o <= 4; i = ++o) {\n      for (j = i1 = 1; i1 <= 4; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxSineOfRationalMultiplesOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// check rational multiples of pi\n    for (i = o = 1; o <= 13; i = ++o) {\n      for (j = i1 = 1; i1 <= 13; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(Math.PI * fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        // magic number 23 comes from the case sin(pi/10)\n        if (error < 23 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" * pi )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxAll = function(theFloat) {\n    var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    constantsSumMin = Number.MAX_VALUE;\n    constantsSum = 0;\n    bestApproxSoFar = null;\n    LOG_EXPLANATIONS = true;\n    approxRadicalsResult = approxRadicals(theFloat);\n    if (approxRadicalsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRadicalsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRadicalsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxLogsResult = approxLogs(theFloat);\n    if (approxLogsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxLogsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxLogsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);\n    if (approxRationalsOfPowersOfEResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfEResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);\n    if (approxRationalsOfPowersOfPIResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfPIResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxTrigonometricResult = approxTrigonometric(theFloat);\n    if (approxTrigonometricResult != null) {\n      constantsSum = simpleComplexityMeasure(approxTrigonometricResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxTrigonometricResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    return bestApproxSoFar;\n  };\n\n  simpleComplexityMeasure = function(aResult, b, c) {\n    var theSum;\n    theSum = null;\n    if (aResult instanceof Array) {\n      // we want PI and E to somewhat increase the\n      // complexity of the expression, so basically they count\n      // more than any integer lower than 3, i.e. we consider\n      // 1,2,3 to be more fundamental than PI or E.\n      switch (aResult[1]) {\n        case approx_sine_of_pi_times_rational:\n          theSum = 4;\n          break;\n        // exponents of PI and E need to be penalised as well\n        // otherwise they come to explain any big number\n        // so we count them just as much as the multiplier\n        case approx_rationalOfPi:\n          theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        case approx_rationalOfE:\n          theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        default:\n          theSum = 0;\n      }\n      theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));\n    } else {\n      theSum += Math.abs(aResult) * (Math.abs(b) + Math.abs(c));\n    }\n    \n    // heavily discount unit constants\n    if (aResult[2] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[3] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[4] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (theSum < 0) {\n      theSum = 0;\n    }\n    return theSum;\n  };\n\n  testApprox = function() {\n    var error, fraction, i, i1, i2, i3, j, j1, j2, j3, k3, l1, l2, l3, len, len1, len2, len3, len4, len5, len6, len7, m1, m2, m3, n1, n2, o, o1, o2, originalValue, q1, q2, r1, r2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s2, t1, t2, u1, u2, v1, v2, value, x1, x2, z1, z2;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.sqrt(i) / j;\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref2 = [2, 3, 5, 6, 7, 8, 10];\n    for (j1 = 0, len2 = ref2.length; j1 < len2; j1++) {\n      i = ref2[j1];\n      ref3 = [2, 3, 5, 6, 7, 8, 10];\n      for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {\n        j = ref3[l1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.sqrt(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref4 = [2, 3, 5, 6, 7, 8, 10];\n    for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {\n      i = ref4[m1];\n      ref5 = [2, 3, 5, 6, 7, 8, 10];\n      for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {\n        j = ref5[n1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.sqrt(i / j);\n        returned = approxRadicals(value);\n        if (returned != null) {\n          returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n          if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {\n            console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n          }\n        }\n      }\n    }\n    ref6 = [1, 2, 3, 5, 6, 7, 8, 10];\n    for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {\n      i = ref6[o1];\n      ref7 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {\n        j = ref7[q1];\n        if (i === 1 && j === 1) {\n          continue;\n        }\n        console.log(\"testapproxRadicals testing with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sqrt(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n        if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r1 = 1; r1 <= 5; i = ++r1) {\n      for (j = s1 = 1; s1 <= 5; j = ++s1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.log(i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t1 = 1; t1 <= 5; i = ++t1) {\n      for (j = u1 = 1; u1 <= 5; j = ++u1) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.log(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = v1 = 1; v1 <= 5; i = ++v1) {\n      for (j = x1 = 1; x1 <= 5; j = ++x1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.log(i / j);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = z1 = 1; z1 <= 5; i = ++z1) {\n      for (j = i2 = 1; i2 <= 5; j = ++i2) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.log(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = j2 = 1; j2 <= 2; i = ++j2) {\n      for (j = l2 = 1; l2 <= 12; j = ++l2) {\n        console.log(\"testApproxAll testing: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.E, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = m2 = 1; m2 <= 2; i = ++m2) {\n      for (j = n2 = 1; n2 <= 12; j = ++n2) {\n        console.log(\"approxRationalsOfPowersOfE testing with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.E, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfE(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfE with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = o2 = 1; o2 <= 2; i = ++o2) {\n      for (j = q2 = 1; q2 <= 12; j = ++q2) {\n        console.log(\"testApproxAll testing: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.PI, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r2 = 1; r2 <= 2; i = ++r2) {\n      for (j = s2 = 1; s2 <= 12; j = ++s2) {\n        console.log(\"approxRationalsOfPowersOfPI testing with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.PI, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfPI(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfPI with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t2 = 1; t2 <= 4; i = ++t2) {\n      for (j = u2 = 1; u2 <= 4; j = ++u2) {\n        console.log(\"testApproxAll testing: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        value = Math.sin(fraction);\n        returned = approxAll(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n// 5 digits create no problem\n    for (i = v2 = 1; v2 <= 4; i = ++v2) {\n      for (j = x2 = 1; x2 <= 4; j = ++x2) {\n        console.log(\"testApproxAll testing with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(5);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n// 4 digits create two collisions\n    for (i = z2 = 1; z2 <= 4; i = ++z2) {\n      for (j = i3 = 1; i3 <= 4; j = ++i3) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    value = 0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0\");\n    }\n    value = 0.0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0\");\n    }\n    value = 0.00;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.00\");\n    }\n    value = 0.000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.000\");\n    }\n    value = 0.0000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0000\");\n    }\n    value = 1;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1\");\n    }\n    value = 1.0;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0\");\n    }\n    value = 1.00;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00\");\n    }\n    value = 1.000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.000\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 1.00000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00000\");\n    }\n    value = Math.sqrt(2);\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2)\");\n    }\n    value = 1.41;\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: 1.41\");\n    }\n    // if we narrow down to a particular family then we can get\n    // an OK guess even with few digits, expecially for really \"famous\" numbers\n    value = 1.4;\n    if (approxRadicals(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail approxRadicals: 1.4\");\n    }\n    value = 0.6;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.6\");\n    }\n    value = 0.69;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.69\");\n    }\n    value = 0.7;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.7\");\n    }\n    value = 1.09;\n    if (approxLogs(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxLogs: 1.09\");\n    }\n    value = 1.09;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.09\");\n    }\n    value = 1.098;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.098\");\n    }\n    value = 1.1;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.1\");\n    }\n    value = 1.11;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.11\");\n    }\n    value = Math.sqrt(3);\n    if (approxAll(value)[0] !== \"1 * sqrt( 3 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(3)\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 3.141592;\n    if (approxAll(value)[0] !== \"1 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 3.141592\");\n    }\n    value = 31.41592;\n    if (approxAll(value)[0] !== \"10 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31.41592\");\n    }\n    value = 314.1592;\n    if (approxAll(value)[0] !== \"100 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 314.1592\");\n    }\n    value = 31415926.53589793;\n    if (approxAll(value)[0] !== \"10000000 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31415926.53589793\");\n    }\n    value = Math.sqrt(2);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/4 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(2)\");\n    }\n    value = Math.sqrt(3);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/3 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(3)\");\n    }\n    value = (Math.sqrt(6) - Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 - Math.sqrt(2)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 1/8 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2\");\n    }\n    value = (Math.sqrt(6) + Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 + Math.sqrt(3)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2\");\n    }\n    value = (Math.sqrt(5) - 1) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/10 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(5) - 1)/4\");\n    }\n    value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/5 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 7);\n    if (approxAll(value)[0] !== \"1 * sin( 1/7 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/7)\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 9);\n    if (approxAll(value)[0] !== \"1 * sin( 1/9 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/9)\");\n    }\n    value = 1836.15267;\n    if (approxRationalsOfPowersOfPI(value)[0] !== \"6 * (pi ^ 5 ) / 1 )\") {\n      console.log(\"fail approxRationalsOfPowersOfPI: 1836.15267\");\n    }\n    for (i = j3 = 1; j3 <= 13; i = ++j3) {\n      for (j = k3 = 1; k3 <= 13; j = ++k3) {\n        console.log(\"approxTrigonometric testing: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        value = Math.sin(Math.PI * fraction);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail approxTrigonometric: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = l3 = 1; l3 <= 13; i = ++l3) {\n      for (j = m3 = 1; m3 <= 13; j = ++m3) {\n        // with four digits, there are two collisions with the\n        // \"simple fraction\" argument hypotesis, which we prefer since\n        // it's a simpler expression, so let's skip those\n        // two tests\n        if (i === 5 && j === 11 || i === 6 && j === 11) {\n          continue;\n        }\n        console.log(\"approxTrigonometric testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        originalValue = Math.sin(Math.PI * fraction);\n        value = originalValue.toFixed(4);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail approxTrigonometric with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    return console.log(\"testApprox done\");\n  };\n\n  $.approxRadicals = approxRadicals;\n\n  $.approxRationalsOfLogs = approxRationalsOfLogs;\n\n  $.approxAll = approxAll;\n\n  $.testApprox = testApprox;\n\n  Eval_arccos = function() {\n    push(cadr(p1));\n    Eval();\n    return arccos();\n  };\n\n  arccos = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.acos(p1.d);\n      if (errno) {\n        stop(\"arccos function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 4.0);\n      } else {\n        push_rational(1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return 3/4*pi (135 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI * 3.0 / 4.0);\n      } else {\n        push_rational(3, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/6*pi (30 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 6.0);\n      } else {\n        push_rational(1, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return 5/6*pi (150 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(5.0 * Math.PI / 6.0);\n      } else {\n        push_rational(5, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCCOS);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push_symbol(PI);\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI * 2.0 / 3.0);\n        } else {\n          push_rational(2, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 3.0);\n        } else {\n          push_rational(1, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      default:\n        push_symbol(ARCCOS);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arccosh = function() {\n    push(cadr(p1));\n    Eval();\n    return arccosh();\n  };\n\n  arccosh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COSH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < 1.0) {\n        stop(\"arccosh function argument is less than 1.0\");\n      }\n      d = Math.log(d + Math.sqrt(d * d - 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isplusone(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCCOSH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arcsin = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsin();\n  };\n\n  arcsin = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.asin(p1.d);\n      if (errno) {\n        stop(\"arcsin function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 4);\n      push_symbol(PI);\n      multiply();\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return -1/4*pi (-45 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 4.0);\n      } else {\n        push_rational(-1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/3*pi (60 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 3.0);\n      } else {\n        push_rational(1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return -1/3*pi (-60 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 3.0);\n      } else {\n        push_rational(-1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCSIN);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 2.0);\n        } else {\n          push_rational(-1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 6.0);\n        } else {\n          push_rational(-1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 6.0);\n        } else {\n          push_rational(1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      default:\n        push_symbol(ARCSIN);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arcsinh = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsinh();\n  };\n\n  arcsinh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SINH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      d = Math.log(d + Math.sqrt(d * d + 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCSINH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctan = function() {\n    push(cadr(p1));\n    Eval();\n    return arctan();\n  };\n\n  arctan = function() {\n    var d, errno;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TAN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.atan(p1.d);\n      if (errno) {\n        stop(\"arctan function error\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      arctan();\n      negate();\n      restore();\n      return;\n    }\n    // arctan(sin(a) / cos(a)) ?\n    if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {\n      push(p1);\n      numerator();\n      p2 = pop();\n      push(p1);\n      denominator();\n      p3 = pop();\n      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {\n        push(cadr(p2));\n        restore();\n        return;\n      }\n    }\n    // arctan(1/sqrt(3)) -> pi/6\n    // second if catches the other way of saying it, sqrt(3)/3\n    if ((car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 6);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(1) -> pi/4\n    if (equaln(p1, 1)) {\n      push_rational(1, 4);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(sqrt(3)) -> pi/3\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {\n      push_rational(1, 3);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    push_symbol(ARCTAN);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctanh = function() {\n    push(cadr(p1));\n    Eval();\n    return arctanh();\n  };\n\n  arctanh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TANH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < -1.0 || d > 1.0) {\n        stop(\"arctanh function argument is not in the interval [-1,1]\");\n      }\n      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCTANH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  DEBUG_ARG = false;\n\n  Eval_arg = function() {\n    push(cadr(p1));\n    Eval();\n    return arg();\n  };\n\n  arg = function() {\n    save();\n    p1 = pop();\n    push(p1);\n    numerator();\n    yyarg();\n    push(p1);\n    denominator();\n    yyarg();\n    subtract();\n    return restore();\n  };\n\n  //define RE p2\n  //define IM p3\n  yyarg = function() {\n    save();\n    p1 = pop();\n    // case of plain number\n    if (ispositivenumber(p1) || p1 === symbol(PI)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(0);\n      } else {\n        push_integer(0);\n      }\n    } else if (isnegativenumber(p1)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      negate();\n    // you'd think that something like\n    // arg(a) is always 0 when a is real but no,\n    // arg(a) is pi when a is negative so we have\n    // to leave unexpressed\n    } else if (issymbol(p1)) {\n      push_symbol(ARG);\n      push(p1);\n      list(2);\n    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      // -1 to a power\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      // exponential\n      push(caddr(p1));\n      imag();\n    // arg(a^(1/2)) is always equal to 1/2 * arg(a)\n    // this can obviously be made more generic TODO\n    } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {\n      if (DEBUG_ARG) {\n        console.log(\"arg of a sqrt: \" + p1);\n      }\n      if (DEBUG_ARG) {\n        debugger;\n      }\n      push(cadr(p1));\n      arg();\n      if (DEBUG_ARG) {\n        console.log(\" = 1/2 * \" + stack[tos - 1]);\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      // product of factors\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        arg();\n        add();\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(ADD)) {\n      // sum of terms\n      push(p1);\n      rect();\n      p1 = pop();\n      push(p1);\n      real();\n      p2 = pop();\n      push(p1);\n      imag();\n      p3 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n        if (isnegative(p3)) {\n          negate();\n        }\n      } else {\n        push(p3);\n        push(p2);\n        divide();\n        arctan();\n        if (isnegative(p2)) {\n          if (evaluatingAsFloats) {\n            push_double(Math.PI);\n          } else {\n            push_symbol(PI);\n          }\n          if (isnegative(p3)) {\n            subtract(); // quadrant 1 -> 3\n          } else {\n            add(); // quadrant 4 -> 2\n          }\n        }\n      }\n    } else {\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        // if we assume all passed values are real\n        push_integer(0);\n      } else {\n        // if we don't assume all passed values are real, all\n        // we con do is to leave unexpressed\n        push_symbol(ARG);\n        push(p1);\n        list(2);\n      }\n    }\n    return restore();\n  };\n\n  // pretty print\n  bake = function() {\n    var h, s, t, x, y, z;\n    h = 0;\n    s = 0;\n    t = 0;\n    x = 0;\n    y = 0;\n    z = 0;\n    expanding++;\n    save();\n    p1 = pop();\n    s = ispolyexpandedform(p1, symbol(SYMBOL_S));\n    t = ispolyexpandedform(p1, symbol(SYMBOL_T));\n    x = ispolyexpandedform(p1, symbol(SYMBOL_X));\n    y = ispolyexpandedform(p1, symbol(SYMBOL_Y));\n    z = ispolyexpandedform(p1, symbol(SYMBOL_Z));\n    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_S);\n      bake_poly();\n    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_T);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_X);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {\n      p2 = symbol(SYMBOL_Y);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {\n      p2 = symbol(SYMBOL_Z);\n      bake_poly();\n    // don't bake the contents of some constructs such as \"for\"\n    // because we don't want to evaluate the body of\n    // such constructs \"statically\", i.e. without fully running\n    // the loops.\n    } else if ((iscons(p1)) && car(p1) !== symbol(FOR)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        bake();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n    return expanding--;\n  };\n\n  polyform = function() {\n    var h;\n    h = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (ispolyexpandedform(p1, p2)) {\n      bake_poly();\n    } else if (iscons(p1)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        polyform();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  bake_poly = function() {\n    var a, h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    //U **a\n    a = tos;\n    k = coeff(p2, p1);\n    h = tos;\n    for (i = o = ref = k - 1; o >= 0; i = o += -1) {\n      p1 = stack[a + i];\n      bake_poly_term(i);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(ADD));\n      swap();\n      cons();\n    }\n    p1 = pop();\n    moveTos(tos - k);\n    return push(p1);\n  };\n\n  // p1 points to coefficient of p2 ^ k\n\n  // k is an int\n  bake_poly_term = function(k) {\n    var h, n;\n    h = 0;\n    n = 0;\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    // constant term?\n    if (k === 0) {\n      if (car(p1) === symbol(ADD)) {\n        p1 = cdr(p1);\n        while (iscons(p1)) {\n          push(car(p1));\n          p1 = cdr(p1);\n        }\n      } else {\n        push(p1);\n      }\n      return;\n    }\n    h = tos;\n    // coefficient\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else if (!equaln(p1, 1)) {\n      push(p1);\n    }\n    // x ^ k\n    if (k === 1) {\n      push(p2);\n    } else {\n      push(symbol(POWER));\n      push(p2);\n      push_integer(k);\n      list(3);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(MULTIPLY));\n      swap();\n      return cons();\n    }\n  };\n\n  Eval_besselj = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return besselj();\n  };\n\n  besselj = function() {\n    save();\n    yybesselj();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  //define SGN p3\n  yybesselj = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    // numerical result\n    if (isdouble(p1) && !isNaN(n)) {\n      d = jn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    // bessej(0,0) = 1\n    if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n    // besselj(0,n) = 0\n    if (isZeroAtomOrTensor(p1) && !isNaN(n)) {\n      push_integer(0);\n      return;\n    }\n    // half arguments\n    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {\n      // n = 1/2\n      if (MEQUAL(p2.q.a, 1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        sine();\n        multiply();\n        return;\n      }\n      // n = -1/2\n      if (MEQUAL(p2.q.a, -1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        cosine();\n        multiply();\n        return;\n      }\n      // besselj(x,n) = (2/x) (n-sgn(n)) besselj(x,n-sgn(n)) - besselj(x,n-2*sgn(n))\n      push_integer(MSIGN(p2.q.a));\n      p3 = pop();\n      push_integer(2);\n      push(p1);\n      divide();\n      push(p2);\n      push(p3);\n      subtract();\n      multiply();\n      push(p1);\n      push(p2);\n      push(p3);\n      subtract();\n      besselj();\n      multiply();\n      push(p1);\n      push(p2);\n      push_integer(2);\n      push(p3);\n      multiply();\n      subtract();\n      besselj();\n      subtract();\n      return;\n    }\n    //if 0 # test cases needed\n    if (isnegativeterm(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      power();\n      push(p1);\n      push(p2);\n      negate();\n      power();\n      multiply();\n      push_symbol(BESSELJ);\n      push(p1);\n      negate();\n      push(p2);\n      list(3);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELJ);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    //endif\n    push(symbol(BESSELJ));\n    push(p1);\n    push(p2);\n    return list(3);\n  };\n\n  Eval_bessely = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return bessely();\n  };\n\n  bessely = function() {\n    save();\n    yybessely();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  yybessely = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (isdouble(p1) && !isNaN(n)) {\n      d = yn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELY);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    push_symbol(BESSELY);\n    push(p1);\n    push(p2);\n    list(3);\n  };\n\n  //double convert_rational_to_double(U *)\n  //double convert_bignum_to_double(unsigned int *)\n  //int ge(unsigned int *, unsigned int *, int)\n  mint = function(a) {\n    return bigInt(a);\n  };\n\n  isSmall = function(a) {\n    return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);\n  };\n\n  // b is +1 or -1, a is a bigint\n  setSignTo = function(a, b) {\n    if (a.isPositive()) {\n      if (b < 0) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b > 0) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makeSignSameAs = function(a, b) {\n    if (a.isPositive()) {\n      if (b.isNegative()) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b.isPositive()) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makePositive = function(a) {\n    if (a.isNegative()) {\n      return a.multiply(bigInt(-1));\n    }\n    return a;\n  };\n\n  // n is an int\n  /*\n  mtotal = 0\n  MP_MIN_SIZE = 2\n  MP_MAX_FREE  = 1000\n\n  mnew = (n) ->\n    if (n < MP_MIN_SIZE)\n      n = MP_MIN_SIZE\n    if (n == MP_MIN_SIZE && mfreecount)\n      p = free_stack[--mfreecount]\n    else\n      p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))\n      #if (p == 0)\n   *  stop(\"malloc failure\")\n    p[0] = n\n    mtotal += n\n    return p[3]\n   */\n  // p is the index of array of ints\n  // !!! array wasn't passed here\n  /*\n  free_stack = []\n\n  mfree = (array, p) ->\n    p -= 3\n    mtotal -= array[p]\n    if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)\n      free_stack[mfreecount++] = p\n    else\n      free(p)\n  */\n  // convert int to bignum\n\n  // n is an int\n  /*\n  mint = (n) ->\n    p = mnew(1)\n    if (n < 0)\n   * !!! this is FU\n   * MSIGN(p) = -1\n      fu = true\n    else\n   * !!! this is FU\n      #MSIGN(p) = 1\n      fu = true\n   * !!! this is FU\n    #MLENGTH(p) = 1\n    p[0] = Math.abs(n)\n    return p\n   */\n  // copy bignum\n\n  // a is an array of ints\n  /*\n  mcopy = (a) ->\n    #unsigned int *b\n\n    b = mnew(MLENGTH(a))\n\n   * !!! fu\n    #MSIGN(b) = MSIGN(a)\n    #MLENGTH(b) = MLENGTH(a)\n\n    for i in [0...MLENGTH(a)]\n      b[i] = a[i]\n\n    return b\n   */\n  /*\n   * \n   * ge not invoked from anywhere - is you need ge\n   * just use the bigNum's ge implementation\n   * leaving it here just in case I decide to backport to C\n   *\n   * a >= b ?\n   * and and b arrays of ints, len is an int\n  ge = (a, b, len) ->\n    i = 0\n    for i in [0...len]\n      if (a[i] == b[i])\n        continue\n      else\n        break\n    if (a[i] >= b[i])\n      return 1\n    else\n      return 0\n   */\n  add_numbers = function() {\n    var a, b, theResult;\n    a = 1.0;\n    b = 1.0;\n    //if DEBUG then console.log(\"add_numbers adding numbers: \" + print_list(stack[tos - 1]) + \" and \" + print_list(stack[tos - 2]))\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qadd();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    theResult = a + b;\n    push_double(theResult);\n    return restore();\n  };\n\n  subtract_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qsub();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a - b);\n    return restore();\n  };\n\n  multiply_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qmul();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a * b);\n    return restore();\n  };\n\n  divide_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qdiv();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a / b);\n    return restore();\n  };\n\n  invert_number = function() {\n    var a, b;\n    //unsigned int *a, *b\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      push_double(1 / p1.d);\n      restore();\n      return;\n    }\n    a = bigInt(p1.q.a);\n    b = bigInt(p1.q.b);\n    b = makeSignSameAs(b, a);\n    a = setSignTo(a, 1);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = b;\n    p1.q.b = a;\n    push(p1);\n    return restore();\n  };\n\n  // a and b are Us\n  compare_rationals = function(a, b) {\n    var ab, ba, t;\n    t = 0;\n    //unsigned int *ab, *ba\n    ab = mmul(a.q.a, b.q.b);\n    ba = mmul(a.q.b, b.q.a);\n    t = mcmp(ab, ba);\n    return t;\n  };\n\n  // a and b are Us\n  compare_numbers = function(a, b) {\n    var x, y;\n    x = 0.0;\n    y = 0.0;\n    if (isrational(a) && isrational(b)) {\n      return compare_rationals(a, b);\n    }\n    if (isdouble(a)) {\n      x = a.d;\n    } else {\n      x = convert_rational_to_double(a);\n    }\n    if (isdouble(b)) {\n      y = b.d;\n    } else {\n      y = convert_rational_to_double(b);\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n  negate_number = function() {\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    switch (p1.k) {\n      case NUM:\n        p2 = new U();\n        p2.k = NUM;\n        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));\n        p2.q.b = bigInt(p1.q.b);\n        push(p2);\n        break;\n      case DOUBLE:\n        push_double(-p1.d);\n        break;\n      default:\n        stop(\"bug caught in mp_negate_number\");\n    }\n    return restore();\n  };\n\n  bignum_truncate = function() {\n    var a;\n    //unsigned int *a\n    save();\n    p1 = pop();\n    a = mdiv(p1.q.a, p1.q.b);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  mp_numerator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.a);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  mp_denominator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.b);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  // expo is an integer\n  bignum_power_number = function(expo) {\n    var a, b, t;\n    //unsigned int *a, *b, *t\n    save();\n    p1 = pop();\n    a = mpow(p1.q.a, Math.abs(expo));\n    b = mpow(p1.q.b, Math.abs(expo));\n    if (expo < 0) {\n      // swap a and b\n      t = a;\n      a = b;\n      b = t;\n      a = makeSignSameAs(a, b);\n      b = setSignTo(b, 1);\n    }\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = b;\n    push(p1);\n    return restore();\n  };\n\n  // p an array of ints\n  convert_bignum_to_double = function(p) {\n    return p.toJSNumber();\n  };\n\n  // p is a U\n  convert_rational_to_double = function(p) {\n    var quotientAndRemainder, result;\n    if (p.q == null) {\n      debugger;\n    }\n    quotientAndRemainder = p.q.a.divmod(p.q.b);\n    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();\n    return result;\n  };\n\n  // n an integer\n  new_integer = function(n) {\n    var theNewInteger;\n    theNewInteger = new U();\n    theNewInteger.k = NUM;\n    theNewInteger.q.a = bigInt(n);\n    theNewInteger.q.b = bigInt(1);\n    return theNewInteger;\n  };\n\n  // n an integer\n  push_integer = function(n) {\n    if (DEBUG) {\n      console.log(\"pushing integer \" + n);\n    }\n    return push(new_integer(n));\n  };\n\n  // d a double\n  push_double = function(d) {\n    save();\n    p1 = new U();\n    p1.k = DOUBLE;\n    p1.d = d;\n    push(p1);\n    return restore();\n  };\n\n  // a,b parts of a rational\n  push_rational = function(a, b) {\n    /*\n    save()\n    p1 = new U()\n    p1.k = NUM\n    p1.q.a = bigInt(a)\n    p1.q.b = bigInt(b)\n    ## FIXME -- normalize ##\n    push(p1)\n    restore()\n     */\n    var p;\n    p = new U();\n    p.k = NUM;\n    p.q.a = bigInt(a);\n    p.q.b = bigInt(b);\n    return push(p);\n  };\n\n  pop_integer = function() {\n    var n;\n    n = 0/0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        if (isinteger(p1) && isSmall(p1.q.a)) {\n          n = p1.q.a.toJSNumber();\n        }\n        break;\n      case DOUBLE:\n        if (DEBUG) {\n          console.log(\"popping integer but double is found\");\n        }\n        if (Math.floor(p1.d) === p1.d) {\n          if (DEBUG) {\n            console.log(\"...altough it's an integer\");\n          }\n          n = p1.d;\n        }\n    }\n    restore();\n    return n;\n  };\n\n  // p is a U, flag is an int\n  print_double = function(p, flag) {\n    var accumulator, buf;\n    accumulator = \"\";\n    buf = doubleToReasonableString(p.d);\n    if (flag === 1 && buf === '-') {\n      accumulator += print_str(buf + 1);\n    } else {\n      accumulator += print_str(buf);\n    }\n    return accumulator;\n  };\n\n  // s is a string\n  bignum_scan_integer = function(s) {\n    var a, scounter, sign_;\n    //unsigned int *a\n    //char sign\n    save();\n    scounter = 0;\n    sign_ = s[scounter];\n    if (sign_ === '+' || sign_ === '-') {\n      scounter++;\n    }\n    // !!!! some mess in here, added an argument\n    a = bigInt(s.substring(scounter));\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    if (sign_ === '-') {\n      negate();\n    }\n    return restore();\n  };\n\n  // s a string\n  bignum_scan_float = function(s) {\n    return push_double(parseFloat(s));\n  };\n\n  // gives the capability of printing the unsigned\n  // value. This is handy because printing of the sign\n  // might be taken care of \"upstream\"\n  // e.g. when printing a base elevated to a negative exponent\n  // prints the inverse of the base powered to the unsigned\n  // exponent.\n  // p is a U\n  print_number = function(p, signed) {\n    var aAsString, accumulator, buf, denominatorString;\n    accumulator = \"\";\n    denominatorString = \"\";\n    buf = \"\";\n    switch (p.k) {\n      case NUM:\n        aAsString = p.q.a.toString();\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        if (printMode === PRINTMODE_LATEX && isfraction(p)) {\n          aAsString = \"\\\\frac{\" + aAsString + \"}{\";\n        }\n        accumulator += aAsString;\n        if (isfraction(p)) {\n          if (printMode !== PRINTMODE_LATEX) {\n            accumulator += \"/\";\n          }\n          denominatorString = p.q.b.toString();\n          if (printMode === PRINTMODE_LATEX) {\n            denominatorString += \"}\";\n          }\n          accumulator += denominatorString;\n        }\n        break;\n      case DOUBLE:\n        aAsString = doubleToReasonableString(p.d);\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        accumulator += aAsString;\n    }\n    return accumulator;\n  };\n\n  gcd_numbers = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    //  if (!isinteger(p1) || !isinteger(p2))\n    //    stop(\"integer args expected for gcd\")\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mgcd(p1.q.a, p2.q.a);\n    p3.q.b = mgcd(p1.q.b, p2.q.b);\n    p3.q.a = setSignTo(p3.q.a, 1);\n    push(p3);\n    return restore();\n  };\n\n  pop_double = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        d = convert_rational_to_double(p1);\n        break;\n      case DOUBLE:\n        d = p1.d;\n        break;\n      default:\n        d = 0.0;\n    }\n    restore();\n    return d;\n  };\n\n  bignum_float = function() {\n    var d;\n    d = 0.0;\n    d = convert_rational_to_double(pop());\n    return push_double(d);\n  };\n\n  //static unsigned int *__factorial(int)\n\n  // n is an int\n  bignum_factorial = function(n) {\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = __factorial(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  // n is an int\n  __factorial = function(n) {\n    var a, b, i, o, ref, t;\n    i = 0;\n    //unsigned int *a, *b, *t\n    if (n === 0 || n === 1) {\n      a = bigInt(1);\n      return a;\n    }\n    a = bigInt(2);\n    b = bigInt(0);\n    if (3 <= n) {\n      for (i = o = 3, ref = n; (3 <= ref ? o <= ref : o >= ref); i = 3 <= ref ? ++o : --o) {\n        b = bigInt(i);\n        t = mmul(a, b);\n        a = t;\n      }\n    }\n    return a;\n  };\n\n  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];\n\n  // unsigned int *x, unsigned int k\n  mp_set_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] |= mask[k % 32];\n  };\n\n  // unsigned int *x, unsigned int k\n  mp_clr_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] &= ~mask[k % 32];\n  };\n\n  // unsigned int *a\n  mshiftright = function(a) {\n    return a = a.shiftRight();\n  };\n\n  //  Binomial coefficient\n\n  //  Input:    tos-2    n\n\n  //      tos-1    k\n\n  //  Output:    Binomial coefficient on stack\n\n  //  binomial(n, k) = n! / k! / (n - k)!\n\n  //  The binomial coefficient vanishes for k < 0 or k > n. (A=B, p. 19)\n  Eval_binomial = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return binomial();\n  };\n\n  binomial = function() {\n    save();\n    ybinomial();\n    return restore();\n  };\n\n  //define N p1\n  //define K p2\n  ybinomial = function() {\n    p2 = pop();\n    p1 = pop();\n    if (BINOM_check_args() === 0) {\n      push(zero);\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    return divide();\n  };\n\n  BINOM_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_ceiling = function() {\n    push(cadr(p1));\n    Eval();\n    return ceiling();\n  };\n\n  ceiling = function() {\n    save();\n    yyceiling();\n    return restore();\n  };\n\n  yyceiling = function() {\n    var d, doNothing;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(CEILING);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.ceil(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      return doNothing = 1;\n    } else {\n      push_integer(1);\n      return add();\n    }\n  };\n\n  Eval_choose = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return choose();\n  };\n\n  // Result vanishes for k < 0 or k > n. (A=B, p. 19)\n\n  //define N p1\n  //define K p2\n  choose = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (choose_check_args() === 0) {\n      push_integer(0);\n      restore();\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    divide();\n    return restore();\n  };\n\n  choose_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_circexp = function() {\n    push(cadr(p1));\n    Eval();\n    circexp();\n    // normalize\n    return Eval();\n  };\n\n  circexp = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      expcos();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      expsin();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      p1 = cadr(p1);\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      exponential();\n      p2 = pop();\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      negate();\n      exponential();\n      p3 = pop();\n      push(p3);\n      push(p2);\n      subtract();\n      push(imaginaryunit);\n      multiply();\n      push(p2);\n      push(p3);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      add();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      subtract();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      p1 = cadr(p1);\n      push(p1);\n      push_integer(2);\n      multiply();\n      exponential();\n      p1 = pop();\n      push(p1);\n      push_integer(1);\n      subtract();\n      push(p1);\n      push_integer(1);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        circexp();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return;\n    }\n    if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        circexp();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n      restore();\n      return;\n    }\n    push(p1);\n    return restore();\n  };\n\n  Eval_clearall = function() {\n    do_clearall();\n    return push(symbol(NIL));\n  };\n\n  do_clearall = function() {\n    if (test_flag === 0) {\n      clear_term();\n    }\n    do_clearPatterns();\n    clear_symbols();\n    defn();\n    return codeGen = false;\n  };\n\n  // clearall from application GUI code\n  clearall = function() {\n    return run(\"clearall\");\n  };\n\n  // this transformation is done in run.coffee, see there\n  // for more info.\n  clearRenamedVariablesToAvoidBindingToExternalScope = function() {\n    var i, o, ref, results;\n    results = [];\n    for (i = o = 0, ref = symtab.length; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (symtab[i].printname.indexOf(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\") !== -1) {\n        // just clear it\n        symtab[i].k = SYM;\n        symtab[i].printname = \"\";\n        binding[i] = symtab[i];\n        results.push(isSymbolReclaimable[i] = true);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  Eval_clear = function() {\n    var indexFound, variableToBeCleared;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      variableToBeCleared = car(p2);\n      //console.log variableToBeCleared + \"\"\n      if (variableToBeCleared.k !== SYM) {\n        stop(\"symbol error\");\n      }\n      //console.log \"getting binding of \" + p.toString()\n      //if p.toString() == \"aaa\"\n      //  debugger\n      indexFound = symtab.indexOf(variableToBeCleared);\n      symtab[indexFound].k = SYM;\n      symtab[indexFound].printname = \"\";\n      binding[indexFound] = symtab[indexFound];\n      isSymbolReclaimable[indexFound] = true;\n      p2 = cdr(p2);\n    }\n    return push(symbol(NIL));\n  };\n\n  /*\n   Convert complex z to clock form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    clock(z) = abs(z) * (-1) ^ (arg(z) / pi)\n\n    For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)\n  */\n  // P.S. I couldn't find independent definition/aknowledgment\n  // of the naming \"clock form\" anywhere on the web, seems like a\n  // naming specific to eigenmath.\n  // Clock form is another way to express a complex number, and\n  // it has three advantages\n  //   1) it's uniform with how for example\n  //      i is expressed i.e. (-1)^(1/2)\n  //   2) it's very compact\n  //   3) it's a straighforward notation for roots of 1 and -1\n  DEBUG_CLOCKFORM = false;\n\n  Eval_clock = function() {\n    push(cadr(p1));\n    Eval();\n    return clockform();\n  };\n\n  clockform = function() {\n    save();\n    //if 1\n    p1 = pop();\n    push(p1);\n    abs();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: abs of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    // pushing the expression (-1)^... but note\n    // that we can't use \"power\", as \"power\" evaluates\n    // clock forms into rectangular form (see \"-1 ^ rational\"\n    // section in power)\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p1);\n    arg();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: arg of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push(symbol(PI));\n    }\n    divide();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: divide : \" + stack[tos - 1]);\n    }\n    list(3);\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: power : \" + stack[tos - 1]);\n    }\n    multiply();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: multiply : \" + stack[tos - 1]);\n    }\n    //else\n    /*\n    p1 = pop()\n    push(p1)\n    abs()\n    push(symbol(E))\n    push(p1)\n    arg()\n    push(imaginaryunit)\n    multiply()\n    power()\n    multiply()\n    */\n    //endif\n    return restore();\n  };\n\n  /* coeff =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x,n\n\n  General description\n  -------------------\n  Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.\n\n  */\n  //define P p1\n  //define X p2\n  //define N p3\n  Eval_coeff = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (p3 === symbol(NIL)) { // p3 is N  # only 2 args?\n      p3 = p2;\n      p2 = symbol(SYMBOL_X); // p2 is X\n    }\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    return filter();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Put polynomial coefficients on the stack\n\n  //  Input:  as per params\n\n  //  Output:    Returns number of coefficients on stack\n\n  //      tos-n    Coefficient of x^0\n\n  //      tos-1    Coefficient of x^(n-1)\n\n  //-----------------------------------------------------------------------------\n  coeff = function(variable, polynomial) {\n    var coeffsCount, constant, polynomialWithoutConstant, prev_expanding;\n    if (DEBUG) {\n      console.log(\"coeff: \" + variable + \" \" + polynomial);\n    }\n    // works like this:\n    //   1) find the constant (by just evaluating the pol setting the variable to zero)\n    //   2) set aside the found constant: it's one of the coefficients to return\n    //   3) take the polynomial and remove the constant\n    //   4) divide that by variable, lowering the degree by one\n    //   5) go back to 1) until degree is zero\n    coeffsCount = 0;\n    while (true) {\n      push(polynomial);\n      push(variable);\n      push(zero);\n      subst();\n      Eval();\n      constant = pop();\n      \n      // this will be a coefficient that will be returned\n      push(constant);\n      coeffsCount++;\n      push(polynomial);\n      push(constant);\n      subtract();\n      polynomialWithoutConstant = pop();\n      if (equal(polynomialWithoutConstant, zero)) {\n        if (DEBUG) {\n          console.log(\"coeff: result: \" + coeffsCount);\n        }\n        return coeffsCount;\n      }\n      push(polynomialWithoutConstant);\n      push(variable);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      //console.log(\"just divided: \" + stack[tos-1].toString())\n      // this is now the new polynomial with degree decreased by 1\n      polynomial = pop();\n    }\n  };\n\n  Eval_cofactor = function() {\n    var doNothing, i, j, n;\n    i = 0;\n    j = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"cofactor: 1st arg: square matrix expected\");\n    }\n    n = p2.tensor.dim[0];\n    push(caddr(p1));\n    Eval();\n    i = pop_integer();\n    if (i < 1 || i > n) {\n      stop(\"cofactor: 2nd arg: row index expected\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (j < 1 || j > n) {\n      stop(\"cofactor: 3rd arg: column index expected\");\n    }\n    return cofactor(p2, n, i - 1, j - 1);\n  };\n\n  cofactor = function(p, n, row, col) {\n    var i, i1, j, o, ref, ref1;\n    i = 0;\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i !== row && j !== col) {\n          push(p.tensor.elem[n * i + j]);\n        }\n      }\n    }\n    determinant(n - 1);\n    if ((row + col) % 2) {\n      return negate();\n    }\n  };\n\n  // Condense an expression by factoring common terms.\n  Eval_condense = function() {\n    push(cadr(p1));\n    Eval();\n    return Condense();\n  };\n\n  Condense = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    save();\n    yycondense();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yycondense = function() {\n    //expanding = 0\n    p1 = pop();\n    if (car(p1) !== symbol(ADD)) {\n      push(p1);\n      return;\n    }\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"calculating gcd between: \" + stack[tos - 1] + \" and \" + stack[tos - 2]);\n      }\n      gcd();\n      if (DEBUG) {\n        console.log(\"partial gcd: \" + stack[tos - 1]);\n      }\n      p3 = cdr(p3);\n    }\n    if (DEBUG) {\n      console.log(\"condense: this is the gcd of all the terms: \" + stack[tos - 1]);\n    }\n    // divide each term by gcd\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      //multiply()\n      multiply_noexpand();\n      add();\n      p3 = cdr(p3);\n    }\n    // We multiplied above w/o expanding so some factors cancelled.\n\n    // Now we expand which normalizes the result and, in some cases,\n    // simplifies it too (see test case H).\n    yyexpand();\n    // multiply result by gcd\n    push(p2);\n    return divide();\n  };\n\n  Eval_conj = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    push(p1);\n    if (!Find(p1, imaginaryunit)) { // example: (-1)^(1/3)\n      polar();\n      conjugate();\n      return clockform();\n    } else {\n      return conjugate();\n    }\n  };\n\n  // careful is you pass this one an expression with\n  // i (instead of (-1)^(1/2)) then this doesn't work!\n  conjugate = function() {\n    push(imaginaryunit);\n    push(imaginaryunit);\n    negate();\n    subst();\n    return Eval();\n  };\n\n  // Cons two things on the stack.\n  consCount = 0;\n\n  cons = function() {\n    var p;\n    consCount++;\n    if (DEBUG) {\n      console.log(\"cons tos: \" + tos + \" # \" + consCount);\n    }\n    //if consCount == 444\n    //  debugger\n    // auto var ok, no opportunity for garbage collection after p = alloc()\n    p = new U();\n    p.k = CONS;\n    p.cons.cdr = pop();\n    if (p === p.cons.cdr) {\n      debugger;\n      console.log(\"something wrong p == its cdr\");\n    }\n    p.cons.car = pop();\n    /*\n    console.log \"cons new cdr.k = \" + p.cons.cdr.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.cdr\n    console.log \"cons new car.k = \" + p.cons.car.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.car\n    */\n    return push(p);\n  };\n\n  Eval_contract = function() {\n    push(cadr(p1));\n    Eval();\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return contract();\n  };\n\n  contract = function() {\n    save();\n    yycontract();\n    return restore();\n  };\n\n  yycontract = function() {\n    var a, ai, an, b, h, i, i1, j, j1, k, l, l1, m, m1, n, n1, ndim, nelem, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    n = 0;\n    ndim = 0;\n    nelem = 0;\n    ai = [];\n    an = [];\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"contract: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    ndim = p1.tensor.ndim;\n    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {\n      stop(\"contract: index out of range\");\n    }\n    l--;\n    m--;\n    n = p1.tensor.dim[l];\n    // nelem is the number of elements in \"b\"\n    nelem = 1;\n    for (i = o = 0, ref = ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (i !== l && i !== m) {\n        nelem *= p1.tensor.dim[i];\n      }\n    }\n    //console.log \"nelem:\" + nelem\n    p2 = alloc_tensor(nelem);\n    //console.log \"p2:\" + p2\n    p2.tensor.ndim = ndim - 2;\n    j = 0;\n    for (i = i1 = 0, ref1 = ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (i !== l && i !== m) {\n        p2.tensor.dim[j++] = p1.tensor.dim[i];\n      }\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n//console.log \"a: \" + a\n//console.log \"b: \" + b\n    for (i = j1 = 0, ref2 = ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref3 = nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(zero);\n      for (j = m1 = 0, ref4 = n; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        ai[l] = j;\n        ai[m] = j;\n        h = 0;\n        for (k = n1 = 0, ref5 = ndim; (0 <= ref5 ? n1 < ref5 : n1 > ref5); k = 0 <= ref5 ? ++n1 : --n1) {\n          h = (h * an[k]) + ai[k];\n        }\n        push(a[h]);\n        //console.log \"a[h]: \" + a[h]\n        add();\n      }\n      //console.log \"tos: \" + stack[tos-1]\n      b[i] = pop();\n//console.log \"b[i]: \" + b[i]\n      for (j = o1 = ref6 = ndim - 1; (ref6 <= 0 ? o1 <= 0 : o1 >= 0); j = ref6 <= 0 ? ++o1 : --o1) {\n        if (j === l || j === m) {\n          continue;\n        }\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    if (nelem === 1) {\n      return push(b[0]);\n    } else {\n      return push(p2);\n    }\n  };\n\n  //console.log \"returning: \" + stack[tos-1]\n  /* cos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the cosine of x.\n\n  */\n  Eval_cos = function() {\n    push(cadr(p1));\n    Eval();\n    return cosine();\n  };\n\n  cosine = function() {\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      cosine_of_angle_sum();\n    } else {\n      cosine_of_angle();\n    }\n    return restore();\n  };\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n  cosine_of_angle_sum = function() {\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        cosine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        sine();\n        push(p4);\n        sine();\n        multiply();\n        subtract();\n        return;\n      }\n      p2 = cdr(p2);\n    }\n    return cosine_of_angle();\n  };\n\n  cosine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCCOS)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cos(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // cosine function is symmetric, cos(-x) = cos(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // cos(arctan(x)) = 1 / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(COS));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 90:\n      case 270:\n        return push_integer(0);\n      case 60:\n      case 300:\n        return push_rational(1, 2);\n      case 120:\n      case 240:\n        return push_rational(-1, 2);\n      case 45:\n      case 315:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 135:\n      case 225:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 30:\n      case 330:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 210:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 0:\n        return push_integer(1);\n      case 180:\n        return push_integer(-1);\n      default:\n        push(symbol(COS));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_cosh = function() {\n    push(cadr(p1));\n    Eval();\n    return ycosh();\n  };\n\n  ycosh = function() {\n    save();\n    yycosh();\n    return restore();\n  };\n\n  yycosh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCCOSH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cosh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(COSH);\n    push(p1);\n    return list(2);\n  };\n\n  // this function extract parts subtrees from a tree.\n  // It is used in two\n  // places that have to do with pattern matching.\n  // One is for integrals, where an expression or its\n  // subparts are matched against cases in an\n  // integrals table.\n  // Another one is for applyging tranformation patterns\n  // defined via PATTERN, again patterns are applied to\n  // either the whole expression or any of its parts.\n\n  // unclear to me at the moment\n  // why this is exposed as something that can\n  // be evalled. Never called.\n  Eval_decomp = function() {\n    var h;\n    save();\n    console.log(\"Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!\");\n    h = tos;\n    push(symbol(NIL));\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    decomp(false);\n    list(tos - h);\n    return restore();\n  };\n\n  pushTryNotToDuplicate = function(toBePushed) {\n    if (tos > 0) {\n      if (DEBUG) {\n        console.log(\"comparing \" + toBePushed + \" to: \" + stack[tos - 1]);\n      }\n      if (equal(toBePushed, stack[tos - 1])) {\n        if (DEBUG) {\n          console.log(\"skipping \" + toBePushed + \" because it's already on stack \");\n        }\n        return;\n      }\n    }\n    return push(toBePushed);\n  };\n\n  // returns constant expressions on the stack\n  decomp = function(generalTransform) {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"DECOMPOSING \" + p1);\n    }\n    // is the entire expression constant?\n    if (generalTransform) {\n      if (!iscons(p1)) {\n        if (DEBUG) {\n          console.log(\" ground thing: \" + p1);\n        }\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    } else {\n      if (Find(p1, p2) === 0) {\n        if (DEBUG) {\n          console.log(\" entire expression is constant\");\n        }\n        pushTryNotToDuplicate(p1);\n        //push(p1);  # may need later for pushing both +a, -a\n        //negate()\n        restore();\n        return;\n      }\n    }\n    // sum?\n    if (isadd(p1)) {\n      decomp_sum(generalTransform);\n      restore();\n      return;\n    }\n    // product?\n    if (ismultiply(p1)) {\n      decomp_product(generalTransform);\n      restore();\n      return;\n    }\n    // naive decomp if not sum or product\n    if (DEBUG) {\n      console.log(\" naive decomp\");\n    }\n    p3 = cdr(p1);\n    if (DEBUG) {\n      console.log(\"startig p3: \" + p3);\n    }\n    while (iscons(p3)) {\n      // for a general transformations,\n      // we want to match any part of the tree so\n      // we need to push the subtree as well\n      // as recurse to its parts\n      if (generalTransform) {\n        push(car(p3));\n      }\n      if (DEBUG) {\n        console.log(\"recursive decomposition\");\n      }\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"car(p3): \" + car(p3));\n      }\n      push(p2);\n      if (DEBUG) {\n        console.log(\"p2: \" + p2);\n      }\n      decomp(generalTransform);\n      p3 = cdr(p3);\n    }\n    return restore();\n  };\n\n  decomp_sum = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the sum \");\n    }\n    h = 0;\n    // decomp terms involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // add together all constant terms\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      add_all(tos - h);\n      p3 = pop();\n      pushTryNotToDuplicate(p3);\n      push(p3);\n      return negate(); // need both +a, -a for some integrals\n    }\n  };\n\n  decomp_product = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the product \");\n    }\n    h = 0;\n    // decomp factors involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // multiply together all constant factors\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      return multiply_all(tos - h);\n    }\n  };\n\n  //p3 = pop();  # may need later for pushing both +a, -a\n  //push(p3)\n  //push(p3)\n  //negate()\n  // Store a function definition\n\n  // Example:\n\n  //      f(x,y)=x^y\n\n  // For this definition, p1 points to the following structure.\n\n  //     p1\n  //      |\n  //   ___v__    ______                        ______ \n  //  |CONS  |->|CONS  |--------------------->|CONS  |\n  //  |______|  |______|                      |______|\n  //      |         |                             |\n  //   ___v__    ___v__    ______    ______    ___v__    ______    ______\n  //  |SETQ  |  |CONS  |->|CONS  |->|CONS  |  |CONS  |->|CONS  |->|CONS  |\n  //  |______|  |______|  |______|  |______|  |______|  |______|  |______|\n  //                |         |         |         |         |         |\n  //             ___v__    ___v__    ___v__    ___v__    ___v__    ___v__\n  //            |SYM f |  |SYM x |  |SYM y |  |POWER |  |SYM x |  |SYM y |\n  //            |______|  |______|  |______|  |______|  |______|  |______|\n\n  // the result (in f) is a FUNCTION node\n  // that contains both the body and the argument list.\n\n  // We have\n\n  //  caadr(p1) points to the function name i.e. f\n  //  cdadr(p1) points to the arguments i.e. the list (x y)\n  //  caddr(p1) points to the function body i.e. (power x y)\n\n  //define F p3 # F points to the function name\n  //define A p4 # A points to the argument list\n  //define B p5 # B points to the function body\n  define_user_function = function() {\n    p3 = caadr(p1);\n    p4 = cdadr(p1);\n    p5 = caddr(p1);\n    if (!issymbol(p3)) { // p3 is F\n      stop(\"function name?\");\n    }\n    // evaluate function body (maybe)\n    if (car(p5) === symbol(EVAL)) { // p5 is B\n      push(cadr(p5));\n      Eval();\n      p5 = pop(); // p5 is B\n    }\n    \n    // note how, unless explicitly forced by an eval,\n    // (handled by the if just above)\n    // we don't eval/simplify\n    // the body.\n    // Why? because it's the easiest way\n    // to solve scope problems i.e.\n    //   x = 0\n    //   f(x) = x + 1\n    //   f(4) # would reply 1\n    // which would need to otherwise\n    // be solved by some scope device\n    // somehow\n    push_symbol(FUNCTION);\n    push(p5);\n    push(p4);\n    list(3);\n    p5 = pop();\n    set_binding(p3, p5);\n    return push_symbol(NIL);\n  };\n\n  Eval_function_reference = function() {\n    return push(p1);\n  };\n\n  /* defint =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x,a,b[,y,c,d...]\n\n  General description\n  -------------------\n  Returns the definite integral of f with respect to x evaluated from \"a\" to b.\n  The argument list can be extended for multiple integrals (or \"iterated\n  integrals\"), for example a double integral (which can represent for\n  example a volume under a surface), or a triple integral, etc. For\n  example, defint(f,x,a,b,y,c,d).\n\n  */\n  //define F p2\n  //define X p3\n  //define A p4\n  //define B p5\n  Eval_defint = function() {\n    push(cadr(p1));\n    Eval();\n    p2 = pop(); // p2 is F\n    p1 = cddr(p1);\n    // defint can handle multiple\n    // integrals, so we loop over the\n    // multiple integrals here\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p3 = pop(); // p3 is X\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p4 = pop(); // p4 is A\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p5 = pop(); // p5 is B\n      \n      // obtain the primitive of F against the\n      // specified variable X\n      // note that the primitive changes over\n      // the calculation of the multiple\n      // integrals.\n      push(p2);\n      push(p3);\n      integral();\n      p2 = pop(); // contains the antiderivative of F\n      \n      // evaluate the integral in A\n      push(p2);\n      push(p3);\n      push(p5);\n      subst();\n      Eval();\n      // evaluate the integral in B\n      push(p2);\n      push(p3);\n      push(p4);\n      subst();\n      Eval();\n      // integral between B and A is the\n      // subtraction. Note that this could\n      // be a number but also a function.\n      // and we might have to integrate this\n      // number/function again doing the while\n      // loop again if this is a multiple\n      // integral.\n      subtract();\n      p2 = pop();\n    }\n    return push(p2);\n  };\n\n  Eval_degree = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return degree();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Find the degree of a polynomial\n\n  //  Input:    tos-2    p(x)\n\n  //      tos-1    x\n\n  //  Output:    Result on stack\n\n  //  Note: Finds the largest numerical power of x. Does not check for\n  //  weirdness in p(x).\n\n  //-----------------------------------------------------------------------------\n\n  //define POLY p1\n  //define X p2\n  //define DEGREE p3\n  degree = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = zero;\n    yydegree(p1);\n    push(p3);\n    return restore();\n  };\n\n  yydegree = function(p) {\n    var results;\n    if (equal(p, p2)) {\n      if (isZeroAtomOrTensor(p3)) {\n        return p3 = one;\n      }\n    } else if (car(p) === symbol(POWER)) {\n      if (equal(cadr(p), p2) && isNumericAtom(caddr(p)) && lessp(p3, caddr(p))) {\n        return p3 = caddr(p);\n      }\n    } else if (iscons(p)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        yydegree(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    }\n  };\n\n  Eval_denominator = function() {\n    push(cadr(p1));\n    Eval();\n    return denominator();\n  };\n\n  denominator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    //console.trace \"denominator of: \" + theArgument\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        denominator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_denominator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      push(theArgument);\n      return reciprocate();\n    } else {\n      return push(one);\n    }\n  };\n\n  // derivative\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_derivative = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    // evaluate 1st arg to get function F\n    i = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example  result of 2nd arg  what to do\n\n    // d(f)    nil      guess X, N = nil\n    // d(f,2)  2      guess X, N = 2\n    // d(f,x)  x      X = x, N = nil\n    // d(f,x,2)  x      X = x, N = 2\n    // d(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // p5 (N) might be a symbol instead of a number\n      if (isNumericAtom(p5)) { // p5 is N\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth derivative: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          derivative();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          integral();\n        }\n      }\n      p3 = pop();\n      if (p5 === symbol(NIL)) { // p5 is N\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) { // p5 is N\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) { // p5 is N\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) { // p5 is N\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // p5 is N  # N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // p5 is N  # N = arg1\n      }\n    }\n    return push(p3); // p3 is F # final result\n  };\n\n  derivative = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isNumericAtom(p2)) {\n      stop(\"undefined function\");\n    }\n    if (istensor(p1)) {\n      if (istensor(p2)) {\n        d_tensor_tensor();\n      } else {\n        d_tensor_scalar();\n      }\n    } else {\n      if (istensor(p2)) {\n        d_scalar_tensor();\n      } else {\n        d_scalar_scalar();\n      }\n    }\n    return restore();\n  };\n\n  d_scalar_scalar = function() {\n    if (issymbol(p2)) {\n      return d_scalar_scalar_1();\n    } else {\n      // Example: d(sin(cos(x)),cos(x))\n      // Replace cos(x) <- X, find derivative, then do X <- cos(x)\n      push(p1);\n      push(p2);\n      push(symbol(SECRETX));\n      subst();\n      push(symbol(SECRETX));\n      derivative();\n      push(symbol(SECRETX));\n      push(p2);\n      return subst(); // cos(X) -> cos(cos(x))\n    }\n  };\n\n  d_scalar_scalar_1 = function() {\n    // d(x,x)?\n    if (equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    if (!iscons(p1)) {\n      push(zero);\n      return;\n    }\n    if (isadd(p1)) {\n      dsum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      dproduct();\n      return;\n    }\n    if (car(p1) === symbol(POWER)) {\n      dpower();\n      return;\n    }\n    if (car(p1) === symbol(DERIVATIVE)) {\n      dd();\n      return;\n    }\n    if (car(p1) === symbol(LOG)) {\n      dlog();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      dsin();\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      dcos();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      dtan();\n      return;\n    }\n    if (car(p1) === symbol(ARCSIN)) {\n      darcsin();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOS)) {\n      darccos();\n      return;\n    }\n    if (car(p1) === symbol(ARCTAN)) {\n      darctan();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      dsinh();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      dcosh();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      dtanh();\n      return;\n    }\n    if (car(p1) === symbol(ARCSINH)) {\n      darcsinh();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOSH)) {\n      darccosh();\n      return;\n    }\n    if (car(p1) === symbol(ARCTANH)) {\n      darctanh();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      dabs();\n      return;\n    }\n    if (car(p1) === symbol(SGN)) {\n      dsgn();\n      return;\n    }\n    if (car(p1) === symbol(HERMITE)) {\n      dhermite();\n      return;\n    }\n    if (car(p1) === symbol(ERF)) {\n      derf();\n      return;\n    }\n    if (car(p1) === symbol(ERFC)) {\n      derfc();\n      return;\n    }\n    if (car(p1) === symbol(BESSELJ)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbesselj0();\n      } else {\n        dbesseljn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(BESSELY)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbessely0();\n      } else {\n        dbesselyn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {\n      derivative_of_integral();\n      return;\n    }\n    return dfunction();\n  };\n\n  dsum = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      derivative();\n      p1 = cdr(p1);\n    }\n    return add_all(tos - h);\n  };\n\n  dproduct = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = length(p1) - 1;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3 = cdr(p1);\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(car(p3));\n        if (i === j) {\n          push(p2);\n          derivative();\n        }\n        p3 = cdr(p3);\n      }\n      multiply_all(n);\n    }\n    return add_all(n);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //       v\n  //  y = u\n\n  //  log y = v log u\n\n  //  1 dy   v du           dv\n  //  - -- = - -- + (log u) --\n  //  y dx   u dx           dx\n\n  //  dy    v  v du           dv\n  //  -- = u  (- -- + (log u) --)\n  //  dx       u dx           dx\n\n  //-----------------------------------------------------------------------------\n  dpower = function() {\n    push(caddr(p1));\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    push(cadr(p1));\n    logarithm();\n    push(caddr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    add();\n    push(p1);\n    return multiply();\n  };\n\n  dlog = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    return divide();\n  };\n\n  //  derivative of derivative\n\n  //  example: d(d(f(x,y),y),x)\n\n  //  p1 = d(f(x,y),y)\n\n  //  p2 = x\n\n  //  cadr(p1) = f(x,y)\n\n  //  caddr(p1) = y\n  dd = function() {\n    // d(f(x,y),x)\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    p3 = pop();\n    if (car(p3) === symbol(DERIVATIVE)) {\n      // sort dx terms\n      push_symbol(DERIVATIVE);\n      push_symbol(DERIVATIVE);\n      push(cadr(p3));\n      if (lessp(caddr(p3), caddr(p1))) {\n        push(caddr(p3));\n        list(3);\n        push(caddr(p1));\n      } else {\n        push(caddr(p1));\n        list(3);\n        push(caddr(p3));\n      }\n      return list(3);\n    } else {\n      push(p3);\n      push(caddr(p1));\n      return derivative();\n    }\n  };\n\n  // derivative of a generic function\n  dfunction = function() {\n    p3 = cdr(p1);\n    if (p3 === symbol(NIL) || Find(p3, p2)) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(zero);\n    }\n  };\n\n  dsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    return multiply();\n  };\n\n  dcos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sine();\n    multiply();\n    return negate();\n  };\n\n  dtan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    multiply();\n    return negate();\n  };\n\n  //        Without simplify  With simplify\n\n  //  d(arctan(y/x),x)  -y/(x^2*(y^2/x^2+1))  -y/(x^2+y^2)\n\n  //  d(arctan(y/x),y)  1/(x*(y^2/x^2+1))  x/(x^2+y^2)\n  darctan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    add();\n    inverse();\n    multiply();\n    return simplify();\n  };\n\n  dsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    return multiply();\n  };\n\n  dcosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ysinh();\n    return multiply();\n  };\n\n  dtanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darctanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    inverse();\n    return multiply();\n  };\n\n  dabs = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sgn();\n    return multiply();\n  };\n\n  dsgn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    dirac();\n    multiply();\n    push_integer(2);\n    return multiply();\n  };\n\n  dhermite = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(2);\n    push(caddr(p1));\n    multiply();\n    multiply();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    hermite();\n    return multiply();\n  };\n\n  derf = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  derfc = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(-2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  dbesselj0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesseljn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    besselj();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    besselj();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  dbessely0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesselyn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    bessely();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    bessely();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  derivative_of_integral = function() {\n    return push(cadr(p1));\n  };\n\n  DET_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  det = function() {\n    var a, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    n = p1.tensor.nelem;\n    a = p1.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtom(a[i])) {\n        break;\n      }\n    }\n    if (i === n) {\n      yydetg();\n    } else {\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n      }\n      determinant(p1.tensor.dim[0]);\n    }\n    return restore();\n  };\n\n  // determinant of n * n matrix elements on the stack\n  determinant = function(n) {\n    var a, breakFromOutherWhile, h, i, i1, j, k, o, q, ref, ref1, s, sign_, t;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    q = 0;\n    s = 0;\n    sign_ = 0;\n    t = 0;\n    a = [];\n    //int *a, *c, *d\n    h = tos - n * n;\n//a = (int *) malloc(3 * n * sizeof (int))\n\n    //if (a == NULL)\n//  out_of_memory()\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      a[i] = i;\n      a[i + n] = 0;\n      a[i + n + n] = 1;\n    }\n    sign_ = 1;\n    push(zero);\n    while (1) {\n      if (sign_ === 1) {\n        push_integer(1);\n      } else {\n        push_integer(-1);\n      }\n      for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        k = n * a[i] + i;\n        push(stack[h + k]);\n        multiply(); // FIXME -- problem here\n      }\n      add();\n      // next permutation (Knuth's algorithm P)\n      j = n - 1;\n      s = 0;\n      breakFromOutherWhile = false;\n      while (1) {\n        q = a[n + j] + a[n + n + j];\n        if (q < 0) {\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        if (q === j + 1) {\n          if (j === 0) {\n            breakFromOutherWhile = true;\n            break;\n          }\n          s++;\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        break;\n      }\n      if (breakFromOutherWhile) {\n        break;\n      }\n      t = a[j - a[n + j] + s];\n      a[j - a[n + j] + s] = a[j - q + s];\n      a[j - q + s] = t;\n      a[n + j] = q;\n      sign_ = -sign_;\n    }\n    stack[h] = stack[tos - 1];\n    return moveTos(h + 1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack\n\n  //  Output:    Determinant on stack\n\n  //  Note:\n\n  //  Uses Gaussian elimination which is faster for numerical matrices.\n\n  //  Gaussian Elimination works by walking down the diagonal and clearing\n  //  out the columns below it.\n\n  //-----------------------------------------------------------------------------\n  detg = function() {\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yydetg();\n    return restore();\n  };\n\n  yydetg = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    for (i = o = 0, ref = n * n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p1.tensor.elem[i]);\n    }\n    lu_decomp(n);\n    moveTos(tos - n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n matrix elements on stack\n\n  //  Output:    p1  determinant\n\n  //      p2  mangled\n\n  //      upper diagonal matrix on stack\n\n  //-----------------------------------------------------------------------------\n  M = function(h, n, i, j) {\n    return stack[h + n * i + j];\n  };\n\n  setM = function(h, n, i, j, value) {\n    return stack[h + n * i + j] = value;\n  };\n\n  lu_decomp = function(n) {\n    var d, h, i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;\n    d = 0;\n    h = 0;\n    i = 0;\n    j = 0;\n    h = tos - n * n;\n    p1 = one;\n    for (d = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(M(h, n, d, d), zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(M(h, n, i, d), zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          p1 = zero;\n          break;\n        }\n// exchange rows\n        for (j = j1 = ref3 = d, ref4 = n; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); j = ref3 <= ref4 ? ++j1 : --j1) {\n          p2 = M(h, n, d, j);\n          setM(h, n, d, j, M(h, n, i, j));\n          setM(h, n, i, j, p2);\n        }\n        // negate det\n        push(p1);\n        negate();\n        p1 = pop();\n      }\n      // update det\n      push(p1);\n      push(M(h, n, d, d));\n      multiply();\n      p1 = pop();\n// update lower diagonal matrix\n      for (i = l1 = ref5 = d + 1, ref6 = n; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n        // multiplier\n        push(M(h, n, i, d));\n        push(M(h, n, d, d));\n        divide();\n        negate();\n        p2 = pop();\n        // update one row\n        setM(h, n, i, d, zero);\n        for (j = m1 = ref7 = d + 1, ref8 = n; (ref7 <= ref8 ? m1 < ref8 : m1 > ref8); j = ref7 <= ref8 ? ++m1 : --m1) {\n          push(M(h, n, d, j));\n          push(p2);\n          multiply();\n          push(M(h, n, i, j));\n          add();\n          setM(h, n, i, j, pop());\n        }\n      }\n    }\n    // last diagonal element\n    push(p1);\n    push(M(h, n, n - 1, n - 1));\n    multiply();\n    return p1 = pop();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Dirac function dirac(x)\n  //  dirac(-x)=dirac(x)\n  //  dirac(b-a)=dirac(a-b)\n  //-----------------------------------------------------------------------------\n  Eval_dirac = function() {\n    push(cadr(p1));\n    Eval();\n    return dirac();\n  };\n\n  dirac = function() {\n    save();\n    ydirac();\n    return restore();\n  };\n\n  //define p1 p1\n  ydirac = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d === 0) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (isrational(p1)) {\n      if (MZERO(mmul(p1.q.a, p1.q.b))) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (car(p1) === symbol(POWER)) {\n      push_symbol(DIRAC);\n      push(cadr(p1));\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(DIRAC);\n      push(p1);\n      negate();\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    push_symbol(DIRAC);\n    push(p1);\n    return list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate all divisors of a term\n\n  //  Input:    Term on stack (factor * factor * ...)\n\n  //  Output:    Divisors on stack\n\n  //-----------------------------------------------------------------------------\n  divisors = function() {\n    var h, i, n, o, ref, subsetOfStack;\n    i = 0;\n    h = 0;\n    n = 0;\n    save();\n    h = tos - 1;\n    divisors_onstack();\n    n = tos - h;\n    //qsort(stack + h, n, sizeof (U *), __cmp)\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  divisors_onstack = function() {\n    var h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    h = tos;\n    // push all of the term's factors\n    if (isNumericAtom(p1)) {\n      push(p1);\n      factor_small_number();\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n      __factor_add();\n    //printf(\">>>\\n\")\n    //for (i = h; i < tos; i++)\n    //print(stdout, stack[i])\n    //printf(\"<<<\\n\")\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        push(car(p1));\n        factor_small_number();\n        p1 = cdr(p1);\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (car(p2) === symbol(POWER)) {\n          push(cadr(p2));\n          push(caddr(p2));\n        } else {\n          push(p2);\n          push(one);\n        }\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(POWER)) {\n      push(cadr(p1));\n      push(caddr(p1));\n    } else {\n      push(p1);\n      push(one);\n    }\n    k = tos;\n    // contruct divisors by recursive descent\n    push(one);\n    gen(h, k);\n    // move\n    n = tos - k;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[h + i] = stack[k + i];\n    }\n    moveTos(h + n);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate divisors\n\n  //  Input:    Base-exponent pairs on stack\n\n  //      h  first pair\n\n  //      k  just past last pair\n\n  //  Output:    Divisors on stack\n\n  //  For example, factor list 2 2 3 1 results in 6 divisors,\n\n  //    1\n  //    3\n  //    2\n  //    6\n  //    4\n  //    12\n\n  //-----------------------------------------------------------------------------\n\n  //define ACCUM p1\n  //define BASE p2\n  //define EXPO p3\n  gen = function(h, k) {\n    var expo, i, o, ref;\n    expo = 0;\n    i = 0;\n    save();\n    p1 = pop();\n    if (h === k) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = stack[h + 0];\n    p3 = stack[h + 1];\n    push(p3);\n    expo = pop_integer();\n    if (!isNaN(expo)) {\n      for (i = o = 0, ref = Math.abs(expo); (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(p1);\n        push(p2);\n        push_integer(sign(expo) * i);\n        power();\n        multiply();\n        gen(h + 2, k);\n      }\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor ADD expression\n\n  //  Input:    Expression on stack\n\n  //  Output:    Factors on stack\n\n  //  Each factor consists of two expressions, the factor itself followed\n  //  by the exponent.\n\n  //-----------------------------------------------------------------------------\n  __factor_add = function() {\n    save();\n    p1 = pop();\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    // check gcd\n    p2 = pop();\n    if (isplusone(p2)) {\n      push(p1);\n      push(one);\n      restore();\n      return;\n    }\n    // push factored gcd\n    if (isNumericAtom(p2)) {\n      push(p2);\n      factor_small_number();\n    } else if (car(p2) === symbol(MULTIPLY)) {\n      p3 = cdr(p2);\n      if (isNumericAtom(car(p3))) {\n        push(car(p3));\n        factor_small_number();\n      } else {\n        push(car(p3));\n        push(one);\n      }\n      p3 = cdr(p3);\n      while (iscons(p3)) {\n        push(car(p3));\n        push(one);\n        p3 = cdr(p3);\n      }\n    } else {\n      push(p2);\n      push(one);\n    }\n    // divide each term by gcd\n    push(p2);\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply();\n      add();\n      p3 = cdr(p3);\n    }\n    push(one);\n    return restore();\n  };\n\n  // power function for double precision floating point\n  dpow = function() {\n    var a, b, base, expo, result, theta;\n    a = 0.0;\n    b = 0.0;\n    base = 0.0;\n    expo = 0.0;\n    result = 0.0;\n    theta = 0.0;\n    expo = pop_double();\n    base = pop_double();\n    // divide by zero?\n    if (base === 0.0 && expo < 0.0) {\n      stop(\"divide by zero\");\n    }\n    // nonnegative base or integer power?\n    if (base >= 0.0 || (expo % 1.0) === 0.0) {\n      result = Math.pow(base, expo);\n      push_double(result);\n      return;\n    }\n    result = Math.pow(Math.abs(base), expo);\n    theta = Math.PI * expo;\n    // this ensures the real part is 0.0 instead of a tiny fraction\n    if ((expo % 0.5) === 0.0) {\n      a = 0.0;\n      b = Math.sin(theta);\n    } else {\n      a = Math.cos(theta);\n      b = Math.sin(theta);\n    }\n    push_double(a * result);\n    push_double(b * result);\n    push(imaginaryunit);\n    multiply();\n    return add();\n  };\n\n  /* eigen =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.\n  The eigenval function returns a matrix with the eigenvalues along the diagonal.\n  The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.\n  The eigen function does not return anything but stores the eigenvalue matrix in D\n  and the eigenvector matrix in Q.\n\n  Input:    stack[tos - 1]    symmetric matrix\n\n  Output:    D      diagnonal matrix\n        Q      eigenvector matrix\n\n  D and Q have the property that\n\n    A == dot(transpose(Q),D,Q)\n\n  where A is the original matrix.\n\n  The eigenvalues are on the diagonal of D.\n  The eigenvectors are row vectors in Q.\n\n  The eigenvalue relation:\n\n    A X = lambda X\n\n  can be checked as follows:\n\n    lambda = D[1,1]\n    X = Q[1]\n    dot(A,X) - lambda X\n\n  Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.\n\n  Enter:\n\n       A = hilbert(3)\n\n       eigen(A)\n\n       lambda = D[1,1]\n\n       X = Q[1]\n\n       dot(A,X) - lambda X\n\n  Result:\n\n       -1.16435e-14\n\n       -6.46705e-15\n\n       -4.55191e-15\n\n  Example 2: Check the relation A = QTDQ.\n\n  Enter:\n\n    A - dot(transpose(Q),D,Q)\n\n  Result: \n\n    6.27365e-12    -1.58236e-11   1.81902e-11\n\n    -1.58236e-11   -1.95365e-11   2.56514e-12\n\n    1.81902e-11    2.56514e-12    1.32627e-11\n\n  */\n  //define D(i, j) yydd[EIG_N * (i) + (j)]\n  //define Q(i, j) yyqq[EIG_N * (i) + (j)]\n  EIG_N = 0;\n\n  EIG_yydd = [];\n\n  EIG_yyqq = [];\n\n  Eval_eigen = function() {\n    if (EIG_check_arg() === 0) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    eigen(EIGEN);\n    p1 = usr_symbol(\"D\");\n    set_binding(p1, p2);\n    p1 = usr_symbol(\"Q\");\n    set_binding(p1, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_eigenval = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVAL);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVAL);\n    return push(p2);\n  };\n\n  Eval_eigenvec = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVEC);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVEC);\n    return push(p3);\n  };\n\n  EIG_check_arg = function() {\n    var i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    p1 = pop();\n    if (!istensor(p1)) {\n      return 0;\n    }\n    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    EIG_N = p1.tensor.dim[0];\n    for (i = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {\n          stop(\"eigen: matrix is not numerical\");\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = EIG_N - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {\n          stop(\"eigen: matrix is not symmetrical\");\n        }\n      }\n    }\n    return 1;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    p1    matrix\n\n  //  Output:    p2    eigenvalues\n\n  //      p3    eigenvectors\n\n  //-----------------------------------------------------------------------------\n  eigen = function(op) {\n    var i, i1, j, j1, l1, m1, n1, o, o1, q1, r1, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;\n    i = 0;\n    j = 0;\n// malloc working vars\n\n    //EIG_yydd = (double *) malloc(n * n * sizeof (double))\n    for (i = o = 0, ref = EIG_N * EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      EIG_yydd[i] = 0.0;\n    }\n//if (EIG_yydd == NULL)\n//  stop(\"malloc failure\")\n\n    //EIG_yyqq = (double *) malloc(n * n * sizeof (double))\n    for (i = i1 = 0, ref1 = EIG_N * EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      EIG_yyqq[i] = 0.0;\n    }\n//if (EIG_yyqq == NULL)\n//  stop(\"malloc failure\")\n\n    // initialize D\n    for (i = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;\n        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;\n      }\n    }\n// initialize Q\n    for (i = m1 = 0, ref5 = EIG_N; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      EIG_yyqq[EIG_N * i + i] = 1.0;\n      for (j = n1 = ref6 = i + 1, ref7 = EIG_N; (ref6 <= ref7 ? n1 < ref7 : n1 > ref7); j = ref6 <= ref7 ? ++n1 : --n1) {\n        EIG_yyqq[EIG_N * i + j] = 0.0;\n        EIG_yyqq[EIG_N * j + i] = 0.0;\n      }\n    }\n// step up to 100 times\n    for (i = o1 = 0; o1 < 100; i = ++o1) {\n      if (step() === 0) {\n        break;\n      }\n    }\n    if (i === 100) {\n      printstr(\"\\nnote: eigen did not converge\\n\");\n    }\n    // p2 = D\n    if (op === EIGEN || op === EIGENVAL) {\n      push(p1);\n      copy_tensor();\n      p2 = pop();\n      for (i = q1 = 0, ref8 = EIG_N; (0 <= ref8 ? q1 < ref8 : q1 > ref8); i = 0 <= ref8 ? ++q1 : --q1) {\n        for (j = r1 = 0, ref9 = EIG_N; (0 <= ref9 ? r1 < ref9 : r1 > ref9); j = 0 <= ref9 ? ++r1 : --r1) {\n          push_double(EIG_yydd[EIG_N * i + j]);\n          p2.tensor.elem[EIG_N * i + j] = pop();\n        }\n      }\n    }\n    // p3 = Q\n    if (op === EIGEN || op === EIGENVEC) {\n      push(p1);\n      copy_tensor();\n      p3 = pop();\n      results = [];\n      for (i = s1 = 0, ref10 = EIG_N; (0 <= ref10 ? s1 < ref10 : s1 > ref10); i = 0 <= ref10 ? ++s1 : --s1) {\n        results.push((function() {\n          var ref11, results1, t1;\n          results1 = [];\n          for (j = t1 = 0, ref11 = EIG_N; (0 <= ref11 ? t1 < ref11 : t1 > ref11); j = 0 <= ref11 ? ++t1 : --t1) {\n            push_double(EIG_yyqq[EIG_N * i + j]);\n            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());\n          }\n          return results1;\n        })());\n      }\n      return results;\n    }\n  };\n\n  // free working vars\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 1, q = 3\n\n  //    c  0  s  0\n\n  //    0  1  0  0\n  //  G =\n  //    -s  0  c  0\n\n  //    0  0  0  1\n\n  //  The effect of multiplying G times A is...\n\n  //  row 1 of A    = c (row 1 of A ) + s (row 3 of A )\n  //            n+1                n                 n\n\n  //  row 3 of A    = c (row 3 of A ) - s (row 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  row 1 = c row 1 + s row 3\n\n  //    A[1,1] = c A[1,1] + s A[3,1]\n\n  //    A[1,2] = c A[1,2] + s A[3,2]\n\n  //    A[1,3] = c A[1,3] + s A[3,3]\n\n  //    A[1,4] = c A[1,4] + s A[3,4]\n\n  //  row 3 = c row 3 - s row 1\n\n  //    A[3,1] = c A[3,1] - s A[1,1]\n\n  //    A[3,2] = c A[3,2] - s A[1,2]\n\n  //    A[3,3] = c A[3,3] - s A[1,3]\n\n  //    A[3,4] = c A[3,4] - s A[1,4]\n\n  //                                     T\n  //  The effect of multiplying A times G  is...\n\n  //  col 1 of A    = c (col 1 of A ) + s (col 3 of A )\n  //            n+1                n                 n\n\n  //  col 3 of A    = c (col 3 of A ) - s (col 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  col 1 = c col 1 + s col 3\n\n  //    A[1,1] = c A[1,1] + s A[1,3]\n\n  //    A[2,1] = c A[2,1] + s A[2,3]\n\n  //    A[3,1] = c A[3,1] + s A[3,3]\n\n  //    A[4,1] = c A[4,1] + s A[4,3]\n\n  //  col 3 = c col 3 - s col 1\n\n  //    A[1,3] = c A[1,3] - s A[1,1]\n\n  //    A[2,3] = c A[2,3] - s A[2,1]\n\n  //    A[3,3] = c A[3,3] - s A[3,1]\n\n  //    A[4,3] = c A[4,3] - s A[4,1]\n\n  //  What we want to do is just compute the upper triangle of A since we\n  //  know the lower triangle is identical.\n\n  //  In other words, we just want to update components A[i,j] where i < j.\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 2, q = 5\n\n  //        p      q\n\n  //      j=1  j=2  j=3  j=4  j=5  j=6\n\n  //    i=1  .  A[1,2]  .  .  A[1,5]  .\n\n  //  p  i=2  A[2,1]  A[2,2]  A[2,3]  A[2,4]  A[2,5]  A[2,6]\n\n  //    i=3  .  A[3,2]  .  .  A[3,5]  .\n\n  //    i=4  .  A[4,2]  .  .  A[4,5]  .\n\n  //  q  i=5  A[5,1]  A[5,2]  A[5,3]  A[5,4]  A[5,5]  A[5,6]\n\n  //    i=6  .  A[6,2]  .  .  A[6,5]  .\n\n  //-----------------------------------------------------------------------------\n\n  //  This is what B = GA does:\n\n  //  row 2 = c row 2 + s row 5\n\n  //    B[2,1] = c * A[2,1] + s * A[5,1]\n  //    B[2,2] = c * A[2,2] + s * A[5,2]\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,5] = c * A[2,5] + s * A[5,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //  row 5 = c row 5 - s row 2\n\n  //    B[5,1] = c * A[5,1] + s * A[2,1]\n  //    B[5,2] = c * A[5,2] + s * A[2,2]\n  //    B[5,3] = c * A[5,3] + s * A[2,3]\n  //    B[5,4] = c * A[5,4] + s * A[2,4]\n  //    B[5,5] = c * A[5,5] + s * A[2,5]\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //                 T\n  //  This is what BG  does:\n\n  //  col 2 = c col 2 + s col 5\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n  //    B[2,2] = c * A[2,2] + s * A[2,5]\n  //    B[3,2] = c * A[3,2] + s * A[3,5]\n  //    B[4,2] = c * A[4,2] + s * A[4,5]\n  //    B[5,2] = c * A[5,2] + s * A[5,5]\n  //    B[6,2] = c * A[6,2] + s * A[6,5]\n\n  //  col 5 = c col 5 - s col 2\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[2,5] = c * A[2,5] - s * A[2,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n  //    B[5,5] = c * A[5,5] - s * A[5,2]\n  //    B[6,5] = c * A[6,5] - s * A[6,2]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 1: Just do upper triangle (i < j), B[2,5] = 0\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 2: Transpose where i > j since A[i,j] == A[j,i]\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[3,5]\n  //    B[2,4] = c * A[2,4] + s * A[4,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[2,3]\n  //    B[4,5] = c * A[4,5] - s * A[2,4]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 3: Same as above except reorder\n\n  //  k < p    (k = 1)\n\n  //    A[1,2] = c * A[1,2] + s * A[1,5]\n  //    A[1,5] = c * A[1,5] - s * A[1,2]\n\n  //  p < k < q  (k = 3..4)\n\n  //    A[2,3] = c * A[2,3] + s * A[3,5]\n  //    A[3,5] = c * A[3,5] - s * A[2,3]\n\n  //    A[2,4] = c * A[2,4] + s * A[4,5]\n  //    A[4,5] = c * A[4,5] - s * A[2,4]\n\n  //  q < k    (k = 6)\n\n  //    A[2,6] = c * A[2,6] + s * A[5,6]\n  //    A[5,6] = c * A[5,6] - s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n  step = function() {\n    var count, i, i1, j, o, ref, ref1, ref2;\n    i = 0;\n    j = 0;\n    count = 0;\n// for each upper triangle \"off-diagonal\" component do step2\n    for (i = o = 0, ref = EIG_N - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = ref1 = i + 1, ref2 = EIG_N; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (EIG_yydd[EIG_N * i + j] !== 0.0) {\n          step2(i, j);\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  step2 = function(p, q) {\n    var c, cc, i1, j1, k, o, ref, ref1, ref2, s, ss, t, theta;\n    k = 0;\n    t = 0.0;\n    theta = 0.0;\n    c = 0.0;\n    cc = 0.0;\n    s = 0.0;\n    ss = 0.0;\n    // compute c and s\n\n    // from Numerical Recipes (except they have a_qq - a_pp)\n    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];\n    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));\n    if (theta < 0.0) {\n      t = -t;\n    }\n    c = 1.0 / Math.sqrt(t * t + 1.0);\n    s = t * c;\n// D = GD\n\n    // which means \"add rows\"\n    for (k = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); k = 0 <= ref ? ++o : --o) {\n      cc = EIG_yydd[EIG_N * p + k];\n      ss = EIG_yydd[EIG_N * q + k];\n      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;\n    }\n// D = D transpose(G)\n\n    // which means \"add columns\"\n    for (k = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      cc = EIG_yydd[EIG_N * k + p];\n      ss = EIG_yydd[EIG_N * k + q];\n      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;\n      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;\n    }\n// Q = GQ\n\n    // which means \"add rows\"\n    for (k = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      cc = EIG_yyqq[EIG_N * p + k];\n      ss = EIG_yyqq[EIG_N * q + k];\n      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;\n    }\n    EIG_yydd[EIG_N * p + q] = 0.0;\n    return EIG_yydd[EIG_N * q + p] = 0.0;\n  };\n\n  Eval_erf = function() {\n    push(cadr(p1));\n    Eval();\n    return yerf();\n  };\n\n  yerf = function() {\n    save();\n    yyerf();\n    return restore();\n  };\n\n  yyerf = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = 1.0 - erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(ERF);\n      push(p1);\n      negate();\n      list(2);\n      negate();\n      return;\n    }\n    push_symbol(ERF);\n    push(p1);\n    list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  erfc(x)\n\n  //  GW  Added erfc() from Numerical Recipes in C\n\n  //-----------------------------------------------------------------------------\n  Eval_erfc = function() {\n    push(cadr(p1));\n    Eval();\n    return yerfc();\n  };\n\n  yerfc = function() {\n    save();\n    yyerfc();\n    return restore();\n  };\n\n  yyerfc = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(ERFC);\n    push(p1);\n    list(2);\n  };\n\n  // from Numerical Recipes in C\n  erfc = function(x) {\n    var ans, t, z;\n    if (x === 0) {\n      return 1.0;\n    }\n    t = 0.0;\n    z = 0.0;\n    ans = 0.0;\n    z = Math.abs(x);\n    t = 1.0 / (1.0 + 0.5 * z);\n    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));\n    if (x >= 0.0) {\n      return ans;\n    } else {\n      return 2.0 - ans;\n    }\n  };\n\n  // Evaluate an expression, for example...\n\n  //  push(p1)\n  //  Eval()\n  //  p2 = pop()\n  Eval = function() {\n    var willEvaluateAsFloats;\n    check_esc_flag();\n    save();\n    p1 = pop();\n    if (p1 == null) {\n      debugger;\n    }\n    if (!evaluatingAsFloats && isfloating(p1)) {\n      willEvaluateAsFloats = true;\n      evaluatingAsFloats++;\n    }\n    switch (p1.k) {\n      case CONS:\n        Eval_cons();\n        break;\n      case NUM:\n        if (evaluatingAsFloats) {\n          push_double(convert_rational_to_double(p1));\n        } else {\n          push(p1);\n        }\n        break;\n      case DOUBLE:\n      case STR:\n        push(p1);\n        break;\n      case TENSOR:\n        Eval_tensor();\n        break;\n      case SYM:\n        Eval_sym();\n        break;\n      default:\n        stop(\"atom?\");\n    }\n    if (willEvaluateAsFloats) {\n      evaluatingAsFloats--;\n    }\n    return restore();\n  };\n\n  Eval_sym = function() {\n    var cycleString, i, o, positionIfSymbolAlreadyBeingEvaluated, ref, ref1;\n    // note that function calls are not processed here\n    // because, since they have an argument (at least an empty one)\n    // they are actually CONs, which is a branch of the\n    // switch before the one that calls this function\n\n    // bare keyword?\n    // If it's a keyword, then we don't look\n    // at the binding array, because keywords\n    // are not redefinable. \n    if (iskeyword(p1)) {\n      push(p1);\n      push(symbol(LAST));\n      list(2);\n      Eval();\n      return;\n    } else if (p1 === symbol(PI) && evaluatingAsFloats) {\n      push_double(Math.PI);\n      return;\n    }\n    // Evaluate symbol's binding\n    p2 = get_binding(p1);\n    if (DEBUG) {\n      console.log(\"looked up: \" + p1 + \" which contains: \" + p2);\n    }\n    push(p2);\n    // differently from standard Lisp,\n    // here the evaluation is not\n    // one-step only, rather it keeps evaluating\n    // \"all the way\" until a symbol is\n    // defined as itself.\n    // Uncomment these two lines to get Lisp\n    // behaviour (and break most tests)\n    if (p1 !== p2) {\n      // detect recursive lookup of symbols, which would otherwise\n      // cause a stack overflow.\n      // Note that recursive functions will still work because\n      // as mentioned at the top, this method doesn't look\n      // up and evaluate function calls.\n      positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);\n      if (positionIfSymbolAlreadyBeingEvaluated !== -1) {\n        cycleString = \"\";\n        for (i = o = ref = positionIfSymbolAlreadyBeingEvaluated, ref1 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n          cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i].printname + \" -> \";\n        }\n        cycleString += p1.printname;\n        stop(\"recursive evaluation of symbols: \" + cycleString);\n        return;\n      }\n      chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);\n      Eval();\n      return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();\n    }\n  };\n\n  Eval_cons = function() {\n    var cons_head;\n    cons_head = car(p1);\n    // normally the cons_head is a symbol,\n    // but sometimes in the case of\n    // functions we don't have a symbol,\n    // we have to evaluate something to get to the\n    // symbol. For example if a function is inside\n    // a tensor, then we need to evaluate an index\n    // access first to get to the function.\n    // In those cases, we find an EVAL here,\n    // so we proceed to EVAL\n    if (car(cons_head) === symbol(EVAL)) {\n      Eval_user_function();\n      return;\n    }\n    if (!issymbol(cons_head)) {\n      stop(\"cons?\");\n    }\n    switch (symnum(cons_head)) {\n      case ABS:\n        return Eval_abs();\n      case ADD:\n        return Eval_add();\n      case ADJ:\n        return Eval_adj();\n      case AND:\n        return Eval_and();\n      case ARCCOS:\n        return Eval_arccos();\n      case ARCCOSH:\n        return Eval_arccosh();\n      case ARCSIN:\n        return Eval_arcsin();\n      case ARCSINH:\n        return Eval_arcsinh();\n      case ARCTAN:\n        return Eval_arctan();\n      case ARCTANH:\n        return Eval_arctanh();\n      case ARG:\n        return Eval_arg();\n      case ATOMIZE:\n        return Eval_atomize();\n      case BESSELJ:\n        return Eval_besselj();\n      case BESSELY:\n        return Eval_bessely();\n      case BINDING:\n        return Eval_binding();\n      case BINOMIAL:\n        return Eval_binomial();\n      case CEILING:\n        return Eval_ceiling();\n      case CHECK:\n        return Eval_check();\n      case CHOOSE:\n        return Eval_choose();\n      case CIRCEXP:\n        return Eval_circexp();\n      case CLEAR:\n        return Eval_clear();\n      case CLEARALL:\n        return Eval_clearall();\n      case CLEARPATTERNS:\n        return Eval_clearpatterns();\n      case CLOCK:\n        return Eval_clock();\n      case COEFF:\n        return Eval_coeff();\n      case COFACTOR:\n        return Eval_cofactor();\n      case CONDENSE:\n        return Eval_condense();\n      case CONJ:\n        return Eval_conj();\n      case CONTRACT:\n        return Eval_contract();\n      case COS:\n        return Eval_cos();\n      case COSH:\n        return Eval_cosh();\n      case DECOMP:\n        return Eval_decomp();\n      case DEGREE:\n        return Eval_degree();\n      case DEFINT:\n        return Eval_defint();\n      case DENOMINATOR:\n        return Eval_denominator();\n      case DERIVATIVE:\n        return Eval_derivative();\n      case DET:\n        return Eval_det();\n      case DIM:\n        return Eval_dim();\n      case DIRAC:\n        return Eval_dirac();\n      case DIVISORS:\n        return Eval_divisors();\n      case DO:\n        return Eval_do();\n      case DOT:\n        return Eval_inner();\n      case DRAW:\n        return Eval_draw();\n      case DSOLVE:\n        return Eval_dsolve();\n      case EIGEN:\n        return Eval_eigen();\n      case EIGENVAL:\n        return Eval_eigenval();\n      case EIGENVEC:\n        return Eval_eigenvec();\n      case ERF:\n        return Eval_erf();\n      case ERFC:\n        return Eval_erfc();\n      case EVAL:\n        return Eval_Eval();\n      case EXP:\n        return Eval_exp();\n      case EXPAND:\n        return Eval_expand();\n      case EXPCOS:\n        return Eval_expcos();\n      case EXPSIN:\n        return Eval_expsin();\n      case FACTOR:\n        return Eval_factor();\n      case FACTORIAL:\n        return Eval_factorial();\n      case FACTORPOLY:\n        return Eval_factorpoly();\n      case FILTER:\n        return Eval_filter();\n      case FLOATF:\n        return Eval_float();\n      case APPROXRATIO:\n        return Eval_approxratio();\n      case FLOOR:\n        return Eval_floor();\n      case FOR:\n        return Eval_for();\n      // this is invoked only when we\n      // evaluate a function that is NOT being called\n      // e.g. when f is a function as we do\n      //  g = f\n      case FUNCTION:\n        return Eval_function_reference();\n      case GAMMA:\n        return Eval_gamma();\n      case GCD:\n        return Eval_gcd();\n      case HERMITE:\n        return Eval_hermite();\n      case HILBERT:\n        return Eval_hilbert();\n      case IMAG:\n        return Eval_imag();\n      case INDEX:\n        return Eval_index();\n      case INNER:\n        return Eval_inner();\n      case INTEGRAL:\n        return Eval_integral();\n      case INV:\n        return Eval_inv();\n      case INVG:\n        return Eval_invg();\n      case ISINTEGER:\n        return Eval_isinteger();\n      case ISPRIME:\n        return Eval_isprime();\n      case LAGUERRE:\n        return Eval_laguerre();\n      //  when LAPLACE then Eval_laplace()\n      case LCM:\n        return Eval_lcm();\n      case LEADING:\n        return Eval_leading();\n      case LEGENDRE:\n        return Eval_legendre();\n      case LOG:\n        return Eval_log();\n      case LOOKUP:\n        return Eval_lookup();\n      case MOD:\n        return Eval_mod();\n      case MULTIPLY:\n        return Eval_multiply();\n      case NOT:\n        return Eval_not();\n      case NROOTS:\n        return Eval_nroots();\n      case NUMBER:\n        return Eval_number();\n      case NUMERATOR:\n        return Eval_numerator();\n      case OPERATOR:\n        return Eval_operator();\n      case OR:\n        return Eval_or();\n      case OUTER:\n        return Eval_outer();\n      case PATTERN:\n        return Eval_pattern();\n      case PATTERNSINFO:\n        return Eval_patternsinfo();\n      case POLAR:\n        return Eval_polar();\n      case POWER:\n        return Eval_power();\n      case PRIME:\n        return Eval_prime();\n      case PRINT:\n        return Eval_print();\n      case PRINT2DASCII:\n        return Eval_print2dascii();\n      case PRINTFULL:\n        return Eval_printcomputer();\n      case PRINTLATEX:\n        return Eval_printlatex();\n      case PRINTLIST:\n        return Eval_printlist();\n      case PRINTPLAIN:\n        return Eval_printhuman();\n      case PRODUCT:\n        return Eval_product();\n      case QUOTE:\n        return Eval_quote();\n      case QUOTIENT:\n        return Eval_quotient();\n      case RANK:\n        return Eval_rank();\n      case RATIONALIZE:\n        return Eval_rationalize();\n      case REAL:\n        return Eval_real();\n      case ROUND:\n        return Eval_round();\n      case YYRECT:\n        return Eval_rect();\n      case ROOTS:\n        return Eval_roots();\n      case SETQ:\n        return Eval_setq();\n      case SGN:\n        return Eval_sgn();\n      case SILENTPATTERN:\n        return Eval_silentpattern();\n      case SIMPLIFY:\n        return Eval_simplify();\n      case SIN:\n        return Eval_sin();\n      case SINH:\n        return Eval_sinh();\n      case SHAPE:\n        return Eval_shape();\n      case SQRT:\n        return Eval_sqrt();\n      case STOP:\n        return Eval_stop();\n      case SUBST:\n        return Eval_subst();\n      case SUM:\n        return Eval_sum();\n      case SYMBOLSINFO:\n        return Eval_symbolsinfo();\n      case TAN:\n        return Eval_tan();\n      case TANH:\n        return Eval_tanh();\n      case TAYLOR:\n        return Eval_taylor();\n      case TEST:\n        return Eval_test();\n      case TESTEQ:\n        return Eval_testeq();\n      case TESTGE:\n        return Eval_testge();\n      case TESTGT:\n        return Eval_testgt();\n      case TESTLE:\n        return Eval_testle();\n      case TESTLT:\n        return Eval_testlt();\n      case TRANSPOSE:\n        return Eval_transpose();\n      case UNIT:\n        return Eval_unit();\n      case ZERO:\n        return Eval_zero();\n      default:\n        return Eval_user_function();\n    }\n  };\n\n  Eval_binding = function() {\n    return push(get_binding(cadr(p1)));\n  };\n\n  Eval_check = function() {\n    var checkResult;\n    // check the argument\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // returned null: unknown result\n      // leave the whole check unevalled\n      return push(p1);\n    } else {\n      // returned 1 or 0\n      return push_integer(checkResult);\n    }\n  };\n\n  Eval_det = function() {\n    push(cadr(p1));\n    Eval();\n    return det();\n  };\n\n  Eval_dim = function() {\n    var n;\n    //int n\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (iscons(cddr(p1))) {\n      push(caddr(p1));\n      Eval();\n      n = pop_integer();\n    } else {\n      n = 1;\n    }\n    if (!istensor(p2)) {\n      return push_integer(1); // dim of scalar is 1\n    } else if (n < 1 || n > p2.tensor.ndim) {\n      return push(p1);\n    } else {\n      return push_integer(p2.tensor.dim[n - 1]);\n    }\n  };\n\n  Eval_divisors = function() {\n    push(cadr(p1));\n    Eval();\n    return divisors();\n  };\n\n  Eval_do = function() {\n    var results;\n    push(car(p1));\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      pop();\n      push(car(p1));\n      Eval();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_dsolve = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    return dsolve();\n  };\n\n  // for example, Eval(f,x,2)\n  Eval_Eval = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      push(cadr(p1));\n      Eval();\n      subst();\n      p1 = cddr(p1);\n    }\n    return Eval();\n  };\n\n  // exp evaluation: it replaces itself with\n  // a POWER(E,something) node and evals that one\n  Eval_exp = function() {\n    push(cadr(p1));\n    Eval();\n    return exponential();\n  };\n\n  Eval_factorial = function() {\n    push(cadr(p1));\n    Eval();\n    return factorial();\n  };\n\n  Eval_factorpoly = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    factorpoly();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factorpoly();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_hermite = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return hermite();\n  };\n\n  Eval_hilbert = function() {\n    push(cadr(p1));\n    Eval();\n    return hilbert();\n  };\n\n  Eval_index = function() {\n    var h, orig, theTensor;\n    h = tos;\n    orig = p1;\n    \n    // look into the head of the list,\n    // when evaluated it should be a tensor\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    theTensor = stack[tos - 1];\n    if (isNumericAtom(theTensor)) {\n      stop(\"trying to access a scalar as a tensor\");\n    }\n    if (!istensor(theTensor)) {\n      // the tensor is not allocated yet, so\n      // leaving the expression unevalled\n      moveTos(h);\n      push(orig);\n      return;\n    }\n    // we examined the head of the list which\n    // was the tensor, now look into\n    // the indexes\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      if (!isintegerorintegerfloat(stack[tos - 1])) {\n        // index with something other than\n        // an integer\n        moveTos(h);\n        push(orig);\n        return;\n      }\n      p1 = cdr(p1);\n    }\n    return index_function(tos - h);\n  };\n\n  Eval_inv = function() {\n    push(cadr(p1));\n    Eval();\n    return inv();\n  };\n\n  Eval_invg = function() {\n    push(cadr(p1));\n    Eval();\n    return invg();\n  };\n\n  Eval_isinteger = function() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isrational(p1)) {\n      if (isinteger(p1)) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    if (isdouble(p1)) {\n      n = Math.floor(p1.d);\n      if (n === p1.d) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    push_symbol(ISINTEGER);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_number = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (p1.k === NUM || p1.k === DOUBLE) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_operator = function() {\n    var h;\n    h = tos;\n    push_symbol(OPERATOR);\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p1 = cdr(p1);\n    }\n    return list(tos - h);\n  };\n\n  // quote definition\n  Eval_quote = function() {\n    return push(cadr(p1));\n  };\n\n  // rank definition\n  Eval_rank = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (istensor(p1)) {\n      return push_integer(p1.tensor.ndim);\n    } else {\n      return push(zero);\n    }\n  };\n\n  // Evaluates the right side and assigns the\n  // result of the evaluation to the left side.\n  // It's called setq because it stands for \"set quoted\" from Lisp,\n  // see:\n  //   http://stackoverflow.com/questions/869529/difference-between-set-setq-and-setf-in-common-lisp\n  // Note that this also takes case of assigning to a tensor\n  // element, which is something that setq wouldn't do\n  // in list, see comments further down below.\n\n  // Example:\n  //   f = x\n  //   // f evaluates to x, so x is assigned to g really\n  //   // rather than actually f being assigned to g\n  //   g = f\n  //   f = y\n  //   g\n  //   > x\n  Eval_setq = function() {\n    // case of tensor\n    if (caadr(p1) === symbol(INDEX)) {\n      setq_indexed();\n      return;\n    }\n    // case of function definition\n    if (iscons(cadr(p1))) {\n      define_user_function();\n      return;\n    }\n    if (!issymbol(cadr(p1))) {\n      stop(\"symbol assignment: error in symbol\");\n    }\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    set_binding(cadr(p1), p2);\n    // An assignment returns nothing.\n    // This is unlike most programming languages\n    // where an assignment does return the\n    // assigned value.\n    // TODO Could be changed.\n    return push(symbol(NIL));\n  };\n\n  // Here \"setq\" is a misnomer because\n  // setq wouldn't work in Lisp to set array elements\n  // since setq stands for \"set quoted\" and you wouldn't\n  // quote an array element access.\n  // You'd rather use setf, which is a macro that can\n  // assign a value to anything.\n  //   (setf (aref YourArray 2) \"blue\")\n  // see\n  //   http://stackoverflow.com/questions/18062016/common-lisp-how-to-set-an-element-in-a-2d-array\n  //-----------------------------------------------------------------------------\n\n  //  Example: a[1] = b\n\n  //  p1  *-------*-----------------------*\n  //    |  |      |\n  //    setq  *-------*-------*  b\n  //      |  |  |\n  //      index  a  1\n\n  //  cadadr(p1) -> a\n\n  //-----------------------------------------------------------------------------\n  setq_indexed = function() {\n    var h;\n    p4 = cadadr(p1);\n    if (!issymbol(p4)) {\n      // this is likely to happen when one tries to\n      // do assignments like these\n      //   1[2] = 3\n      // or\n      //   f(x)[1] = 2\n      // or\n      //   [[1,2],[3,4]][5] = 6\n\n      // In other words, one can only do\n      // a straight assignment like\n      //   existingMatrix[index] = something\n      stop(\"indexed assignment: expected a symbol name\");\n    }\n    h = tos;\n    push(caddr(p1));\n    Eval();\n    p2 = cdadr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      p2 = cdr(p2);\n    }\n    set_component(tos - h);\n    p3 = pop();\n    set_binding(p4, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_sqrt = function() {\n    push(cadr(p1));\n    Eval();\n    push_rational(1, 2);\n    return power();\n  };\n\n  Eval_stop = function() {\n    return stop(\"user stop\");\n  };\n\n  Eval_subst = function() {\n    push(cadddr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadr(p1));\n    Eval();\n    subst();\n    return Eval(); // normalize\n  };\n\n  \n  // always returns a matrix with rank 2\n  // i.e. two dimensions,\n  // the passed parameter is the size\n  Eval_unit = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    n = pop_integer();\n    if (isNaN(n)) {\n      push(p1);\n      return;\n    }\n    if (n < 1) {\n      push(p1);\n      return;\n    }\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[n * i + i] = one;\n    }\n    check_tensor_dimensions(p1);\n    return push(p1);\n  };\n\n  Eval_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  // like Eval() except \"=\" (assignment) is treated\n  // as \"==\" (equality test)\n  // This is because\n  //  * this allows users to be lazy and just\n  //    use \"=\" instead of \"==\" as per more common\n  //    mathematical notation\n  //  * in many places we don't expect an assignment\n  //    e.g. we don't expect to test the zero-ness\n  //    of an assignment or the truth value of\n  //    an assignment\n  // Note that these are questionable assumptions\n  // as for example in most programming languages one\n  // can indeed test the value of an assignment (the\n  // value is just the evaluation of the right side)\n  Eval_predicate = function() {\n    save();\n    p1 = top();\n    if (car(p1) === symbol(SETQ)) {\n      // replace the assignment in the\n      // head with an equality test\n      pop();\n      push_symbol(TESTEQ);\n      push(cadr(p1));\n      push(caddr(p1));\n      list(3);\n    }\n    Eval();\n    return restore();\n  };\n\n  // Partial fraction expansion\n\n  // Example\n\n  //      expand(1/(x^3+x^2),x)\n\n  //        1      1       1\n  //      ---- - --- + -------\n  //        2     x     x + 1\n  //       x\n  Eval_expand = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    return expand();\n  };\n\n  //define A p2\n  //define B p3\n  //define C p4\n  //define F p5\n  //define P p6\n  //define Q p7\n  //define T p8\n  //define X p9\n  expand = function() {\n    var prev_expanding;\n    save();\n    p9 = pop();\n    p5 = pop();\n    if (istensor(p5)) {\n      expand_tensor();\n      restore();\n      return;\n    }\n    // if sum of terms then sum over the expansion of each term\n    if (car(p5) === symbol(ADD)) {\n      push_integer(0);\n      p1 = cdr(p5);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p9);\n        expand();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // B = numerator\n    push(p5);\n    numerator();\n    p3 = pop();\n    // A = denominator\n    push(p5);\n    denominator();\n    p2 = pop();\n    remove_negative_exponents();\n    // Q = quotient\n    push(p3);\n    push(p2);\n    push(p9);\n    // if the denominator is one then always bail out\n    // also bail out if the denominator is not one but\n    // it's not anything recognizable as a polynomial.\n    if (isone(p3) || isone(p2)) {\n      if (!ispolyexpandedform(p2, p9) || isone(p2)) {\n        pop();\n        pop();\n        pop();\n        push(p5);\n        // p5 is the original input, leave unchanged\n        restore();\n        return;\n      }\n    }\n    divpoly();\n    p7 = pop();\n    // remainder B = B - A * Q\n    push(p3);\n    push(p2);\n    push(p7);\n    multiply();\n    subtract();\n    p3 = pop();\n    // if the remainder is zero then we're done\n    if (isZeroAtomOrTensor(p3)) {\n      push(p7);\n      restore();\n      return;\n    }\n    // A = factor(A)\n\n    //console.log(\"expand - to be factored: \" + p2)\n    push(p2);\n    push(p9);\n    factorpoly();\n    p2 = pop();\n    //console.log(\"expand - factored to: \" + p2)\n    expand_get_C();\n    expand_get_B();\n    expand_get_A();\n    if (istensor(p4)) {\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      inv();\n      expanding = prev_expanding;\n      push(p3);\n      inner();\n      push(p2);\n      inner();\n    } else {\n      push(p3);\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p2);\n      multiply();\n    }\n    push(p7);\n    add();\n    return restore();\n  };\n\n  expand_tensor = function() {\n    var i, o, ref;\n    i = 0;\n    push(p5);\n    copy_tensor();\n    p5 = pop();\n    for (i = o = 0, ref = p5.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p5.tensor.elem[i]);\n      push(p9);\n      expand();\n      p5.tensor.elem[i] = pop();\n    }\n    return push(p5);\n  };\n\n  remove_negative_exponents = function() {\n    var h, i, j, k, n, o, ref;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    n = 0;\n    h = tos;\n    factors(p2);\n    factors(p3);\n    n = tos - h;\n    // find the smallest exponent\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1 = stack[h + i];\n      if (car(p1) !== symbol(POWER)) {\n        continue;\n      }\n      if (cadr(p1) !== p9) {\n        continue;\n      }\n      push(caddr(p1));\n      k = pop_integer();\n      if (isNaN(k)) {\n        continue;\n      }\n      if (k < j) {\n        j = k;\n      }\n    }\n    moveTos(h);\n    if (j === 0) {\n      return;\n    }\n    // A = A / X^j\n    push(p2);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    p2 = pop();\n    // B = B / X^j\n    push(p3);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    return p3 = pop();\n  };\n\n  // Returns the expansion coefficient matrix C.\n\n  // Example:\n\n  //       B         1\n  //      --- = -----------\n  //       A      2 \n  //             x (x + 1)\n\n  // We have\n\n  //       B     Y1     Y2      Y3\n  //      --- = ---- + ---- + -------\n  //       A      2     x      x + 1\n  //             x\n\n  // Our task is to solve for the unknowns Y1, Y2, and Y3.\n\n  // Multiplying both sides by A yields\n\n  //           AY1     AY2      AY3\n  //      B = ----- + ----- + -------\n  //            2      x       x + 1\n  //           x\n\n  // Let\n\n  //            A               A                 A\n  //      W1 = ----       W2 = ---        W3 = -------\n  //             2              x               x + 1\n  //            x\n\n  // Then the coefficient matrix C is\n\n  //              coeff(W1,x,0)   coeff(W2,x,0)   coeff(W3,x,0)\n\n  //       C =    coeff(W1,x,1)   coeff(W2,x,1)   coeff(W3,x,1)\n\n  //              coeff(W1,x,2)   coeff(W2,x,2)   coeff(W3,x,2)\n\n  // It follows that\n\n  //       coeff(B,x,0)     Y1\n\n  //       coeff(B,x,1) = C Y2\n\n  //       coeff(B,x,2) =   Y3\n\n  // Hence\n\n  //       Y1       coeff(B,x,0)\n  //             -1\n  //       Y2 = C   coeff(B,x,1)\n\n  //       Y3       coeff(B,x,2)\n  expand_get_C = function() {\n    var a, h, i, i1, j, n, o, prev_expanding, ref, ref1;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    //U **a\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p1 = cdr(p2);\n      while (iscons(p1)) {\n        p5 = car(p1);\n        expand_get_CF();\n        p1 = cdr(p1);\n      }\n    } else {\n      p5 = p2;\n      expand_get_CF();\n    }\n    n = tos - h;\n    if (n === 1) {\n      p4 = pop();\n      return;\n    }\n    p4 = alloc_tensor(n * n);\n    p4.tensor.ndim = 2;\n    p4.tensor.dim[0] = n;\n    p4.tensor.dim[1] = n;\n    a = h;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(stack[a + j]);\n        push(p9);\n        push_integer(i);\n        power();\n        prev_expanding = expanding;\n        expanding = 1;\n        divide();\n        expanding = prev_expanding;\n        push(p9);\n        filter();\n        p4.tensor.elem[n * i + j] = pop();\n      }\n    }\n    return moveTos(tos - n);\n  };\n\n  // The following table shows the push order for simple roots, repeated roots,\n  // and inrreducible factors.\n\n  //  Factor F        Push 1st        Push 2nd         Push 3rd      Push 4th\n\n  //                   A\n  //  x               ---\n  //                   x\n\n  //   2               A               A\n  //  x               ----            ---\n  //                    2              x\n  //                   x\n\n  //                     A\n  //  x + 1           -------\n  //                   x + 1\n\n  //         2            A              A\n  //  (x + 1)         ----------      -------\n  //                          2        x + 1\n  //                   (x + 1)\n\n  //   2                   A               Ax\n  //  x  + x + 1      ------------    ------------\n  //                    2               2\n  //                   x  + x + 1      x  + x + 1\n\n  //    2         2          A              Ax              A             Ax\n  //  (x  + x + 1)    --------------- ---------------  ------------  ------------\n  //                     2         2     2         2     2             2\n  //                   (x  + x + 1)    (x  + x + 1)     x  + x + 1    x  + x + 1\n\n  // For T = A/F and F = P^N we have\n\n  //      Factor F          Push 1st    Push 2nd    Push 3rd    Push 4th\n\n  //      x                 T\n\n  //       2\n  //      x                 T           TP\n\n  //      x + 1             T\n\n  //             2\n  //      (x + 1)           T           TP\n\n  //       2\n  //      x  + x + 1        T           TX\n\n  //        2         2\n  //      (x  + x + 1)      T           TX          TP          TPX\n\n  // Hence we want to push in the order\n\n  //      T * (P ^ i) * (X ^ j)\n\n  // for all i, j such that\n\n  //      i = 0, 1, ..., N - 1\n\n  //      j = 0, 1, ..., deg(P) - 1\n\n  // where index j runs first.\n  expand_get_CF = function() {\n    var d, i, j, n, o, prev_expanding, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    prev_expanding = expanding;\n    expanding = 1;\n    trivial_divide();\n    expanding = prev_expanding;\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p6 = cadr(p5);\n    } else {\n      n = 1;\n      p6 = p5;\n    }\n    push(p6);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p8);\n          push(p6);\n          push_integer(i);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          expanding = prev_expanding;\n          push(p9);\n          push_integer(j);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          results1.push(expanding = prev_expanding);\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Returns T = A/F where F is a factor of A.\n  trivial_divide = function() {\n    var h;\n    h = 0;\n    if (car(p2) === symbol(MULTIPLY)) {\n      h = tos;\n      p0 = cdr(p2);\n      while (iscons(p0)) {\n        if (!equal(car(p0), p5)) {\n          push(car(p0));\n          Eval(); // force expansion of (x+1)^2, f.e.\n        }\n        p0 = cdr(p0);\n      }\n      multiply_all(tos - h);\n    } else {\n      push_integer(1);\n    }\n    return p8 = pop();\n  };\n\n  // Returns the expansion coefficient vector B.\n  expand_get_B = function() {\n    var i, n, o, prev_expanding, ref;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      return;\n    }\n    n = p4.tensor.dim[0];\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p3);\n      push(p9);\n      push_integer(i);\n      power();\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p9);\n      filter();\n      p8.tensor.elem[i] = pop();\n    }\n    return p3 = p8;\n  };\n\n  // Returns the expansion fractions in A.\n  expand_get_A = function() {\n    var h, i, n, o, ref;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      push(p2);\n      reciprocate();\n      p2 = pop();\n      return;\n    }\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p8 = cdr(p2);\n      while (iscons(p8)) {\n        p5 = car(p8);\n        expand_get_AF();\n        p8 = cdr(p8);\n      }\n    } else {\n      p5 = p2;\n      expand_get_AF();\n    }\n    n = tos - h;\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p8.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    return p2 = p8;\n  };\n\n  expand_get_AF = function() {\n    var d, i, j, n, o, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 1;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p5 = cadr(p5);\n    }\n    push(p5);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = ref = n; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p5);\n          push_integer(i);\n          power();\n          reciprocate();\n          push(p9);\n          push_integer(j);\n          power();\n          results1.push(multiply());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Do the exponential cosine function.\n  Eval_expcos = function() {\n    push(cadr(p1));\n    Eval();\n    return expcos();\n  };\n\n  expcos = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    add();\n    return restore();\n  };\n\n  // Do the exponential sine function.\n  Eval_expsin = function() {\n    push(cadr(p1));\n    Eval();\n    return expsin();\n  };\n\n  expsin = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    subtract();\n    return restore();\n  };\n\n  // factor a polynomial or integer\n  Eval_factor = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    factor();\n    // more factoring?\n    p1 = cdddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factor_again();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  factor_again = function() {\n    var h, n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        factor_term();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      factor_term();\n    }\n    n = tos - h;\n    if (n > 1) {\n      multiply_all_noexpand(n);\n    }\n    return restore();\n  };\n\n  factor_term = function() {\n    save();\n    factorpoly();\n    p1 = pop();\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  factor = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isinteger(p1)) {\n      push(p1);\n      factor_number(); // see pollard.cpp\n    } else {\n      push(p1);\n      push(p2);\n      factorpoly();\n    }\n    return restore();\n  };\n\n  // for factoring small integers (2^32 or less)\n  factor_small_number = function() {\n    var d, expo, i, n, o, ref;\n    i = 0;\n    save();\n    n = pop_integer();\n    if (isNaN(n)) {\n      stop(\"number too big to factor\");\n    }\n    if (n < 0) {\n      n = -n;\n    }\n    for (i = o = 0, ref = MAXPRIMETAB; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      d = primetab[i];\n      if (d > n / d) {\n        break;\n      }\n      expo = 0;\n      while (n % d === 0) {\n        n /= d;\n        expo++;\n      }\n      if (expo) {\n        push_integer(d);\n        push_integer(expo);\n      }\n    }\n    if (n > 1) {\n      push_integer(n);\n      push_integer(1);\n    }\n    return restore();\n  };\n\n  factorial = function() {\n    var n;\n    n = 0;\n    save();\n    p1 = pop();\n    push(p1);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(FACTORIAL);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    bignum_factorial(n);\n    return restore();\n  };\n\n  // simplification rules for factorials (m < n)\n\n  //  (e + 1) * factorial(e)  ->  factorial(e + 1)\n\n  //  factorial(e) / e  ->  factorial(e - 1)\n\n  //  e / factorial(e)  ->  1 / factorial(e - 1)\n\n  //  factorial(e + n)\n  //  ----------------  ->  (e + m + 1)(e + m + 2)...(e + n)\n  //  factorial(e + m)\n\n  //  factorial(e + m)                               1\n  //  ----------------  ->  --------------------------------\n  //  factorial(e + n)    (e + m + 1)(e + m + 2)...(e + n)\n\n  // this function is not actually used, but\n  // all these simplifications\n  // do happen automatically via simplify\n  simplifyfactorials = function() {\n    var x;\n    x = 0;\n    save();\n    x = expanding;\n    expanding = 0;\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      push(zero);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        simplifyfactorials();\n        add();\n        p1 = cdr(p1);\n      }\n      expanding = x;\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      sfac_product();\n      expanding = x;\n      restore();\n      return;\n    }\n    push(p1);\n    expanding = x;\n    return restore();\n  };\n\n  sfac_product = function() {\n    var i, i1, j, j1, n, o, ref, ref1, ref2, ref3, s;\n    i = 0;\n    j = 0;\n    n = 0;\n    s = tos;\n    p1 = cdr(p1);\n    n = 0;\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      n++;\n    }\n    for (i = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      for (j = i1 = ref1 = i + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (stack[s + j] === symbol(NIL)) {\n          continue;\n        }\n        sfac_product_f(s, i, j);\n      }\n    }\n    push(one);\n    for (i = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      push(stack[s + i]);\n      multiply();\n    }\n    p1 = pop();\n    moveTos(tos - n);\n    return push(p1);\n  };\n\n  sfac_product_f = function(s, a, b) {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    p1 = stack[s + a];\n    p2 = stack[s + b];\n    if (ispower(p1)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n    if (ispower(p2)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n    if (isfactorial(p1) && isfactorial(p2)) {\n      // Determine if the powers cancel.\n      push(p3);\n      push(p4);\n      add();\n      yyexpand();\n      n = pop_integer();\n      if (n !== 0) {\n        return;\n      }\n      // Find the difference between the two factorial args.\n\n      // For example, the difference between (a + 2)! and a! is 2.\n      push(cadr(p1));\n      push(cadr(p2));\n      subtract();\n      yyexpand();\n      n = pop_integer();\n      if (n === 0 || isNaN(n)) {\n        return;\n      }\n      if (n < 0) {\n        n = -n;\n        p5 = p1;\n        p1 = p2;\n        p2 = p5;\n        p5 = p3;\n        p3 = p4;\n        p4 = p5;\n      }\n      push(one);\n      for (i = o = 1, ref = n; (1 <= ref ? o <= ref : o >= ref); i = 1 <= ref ? ++o : --o) {\n        push(cadr(p2));\n        push_integer(i);\n        add();\n        push(p3);\n        power();\n        multiply();\n      }\n      stack[s + a] = pop();\n      return stack[s + b] = symbol(NIL);\n    }\n  };\n\n  // Factor a polynomial\n  factorpoly = function() {\n    var polynomial, variable;\n    if (DEBUG) {\n      console.log(\"factorpoly: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    variable = pop();\n    polynomial = pop();\n    if (!Find(polynomial, variable) || !ispolyexpandedform(polynomial, variable) || !issymbol(variable)) {\n      push(polynomial);\n    } else {\n      yyfactorpoly(variable, polynomial);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    tos-2    true polynomial\n\n  //      tos-1    free variable\n\n  //  Output:    factored polynomial on stack\n\n  //-----------------------------------------------------------------------------\n  yyfactorpoly = function(variable, polynomial) {\n    var A, AxPlusB, B, checkingTheDivision, dividend, factpoly_expo, firstParam, foundComplexRoot, foundRealRoot, h, i, i1, j1, l1, o, partOfPolynomialFactoredSoFar, polycoeff, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, secondDegreePloly, secondParam, whichRootsAreWeFinding;\n    if (DEBUG) {\n      firstParam = variable;\n      secondParam = polynomial;\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam);\n    }\n    save();\n    h = tos;\n    if (isfloating(polynomial)) {\n      stop(\"floating point numbers in polynomial\");\n    }\n    polycoeff = tos;\n    factpoly_expo = coeff(variable, polynomial) - 1;\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo before rationalize_coefficients: \" + factpoly_expo);\n    }\n    partOfPolynomialFactoredSoFar = rationalize_coefficients(h);\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo  after rationalize_coefficients: \" + factpoly_expo);\n    }\n    // for univariate polynomials we could do factpoly_expo > 1\n    whichRootsAreWeFinding = \"real\";\n    remainingPoly = null;\n    while (factpoly_expo > 0) {\n      if (DEBUG) {\n        console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo inside while loop: \" + factpoly_expo);\n      }\n      if (isZeroAtomOrTensor(stack[polycoeff + 0])) {\n        if (DEBUG) {\n          console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" isZeroAtomOrTensor\");\n        }\n        A = one;\n        B = zero;\n      } else {\n        //console.log(\"trying to find a \" + whichRootsAreWeFinding + \" root\")\n        if (whichRootsAreWeFinding === \"real\") {\n          [foundRealRoot, A, B] = get_factor_from_real_root(variable, factpoly_expo, polycoeff);\n        } else if (whichRootsAreWeFinding === \"complex\") {\n          [foundComplexRoot, A] = get_factor_from_complex_root(remainingPoly, factpoly_expo, polycoeff);\n        }\n      }\n      if (whichRootsAreWeFinding === \"real\") {\n        if (foundRealRoot === 0) {\n          whichRootsAreWeFinding = \"complex\";\n          continue;\n        } else {\n          // build the 1-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          multiply();\n          push(B); // B\n          add();\n          AxPlusB = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + AxPlusB);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(AxPlusB)\n            negate()\n            AxPlusB = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          push(AxPlusB);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          // ok now on stack we have the coefficients of the\n          // remaining part of the polynomial still to factor.\n          // Divide it by the newly-found factor so that\n          // the stack then contains the coefficients of the\n          // polynomial part still left to factor.\n          yydivpoly(factpoly_expo, polycoeff, A, B);\n          while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {\n            factpoly_expo--;\n          }\n          push(zero);\n          for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n            push(stack[polycoeff + i]);\n            push(variable); // the free variable\n            push_integer(i);\n            power();\n            multiply();\n            add();\n          }\n          remainingPoly = pop();\n        }\n      //console.log(\"real branch remainingPoly: \" + remainingPoly)\n      } else if (whichRootsAreWeFinding === \"complex\") {\n        if (foundComplexRoot === 0) {\n          break;\n        } else {\n          // build the 2-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          subtract();\n          //console.log(\"first factor: \" + stack[tos-1].toString())\n          push(A); // A\n          conjugate();\n          push(variable); // x\n          subtract();\n          //console.log(\"second factor: \" + stack[tos-1].toString())\n          multiply();\n          //if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff+factpoly_expo]))\n          //  negate()\n          //  negate_noexpand()\n          secondDegreePloly = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + secondDegreePloly);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(secondDegreePloly)\n            negate()\n            secondDegreePloly = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          previousFactorisation = pop();\n          //console.log(\"previousFactorisation: \" + previousFactorisation)\n          push(partOfPolynomialFactoredSoFar);\n          push(secondDegreePloly);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          if (remainingPoly == null) {\n            push(zero);\n            for (i = i1 = 0, ref1 = factpoly_expo; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n              push(stack[polycoeff + i]);\n              push(variable); // the free variable\n              push_integer(i);\n              power();\n              multiply();\n              add();\n            }\n            remainingPoly = pop();\n          }\n          //console.log(\"original polynomial (dividend): \" + remainingPoly)\n          dividend = remainingPoly;\n          //push(dividend)\n          //degree()\n          //startingDegree = pop()\n          push(dividend);\n          //console.log(\"dividing \" + stack[tos-1].toString() + \" by \" + secondDegreePloly)\n          push(secondDegreePloly); // divisor\n          push(variable); // X\n          divpoly();\n          remainingPoly = pop();\n          push(remainingPoly);\n          push(secondDegreePloly); // divisor\n          multiply();\n          checkingTheDivision = pop();\n          if (!equal(checkingTheDivision, dividend)) {\n            //push(dividend)\n            //gcd_sum()\n            //console.log(\"gcd top of stack: \" + stack[tos-1].toString())\n            if (DEBUG) {\n              console.log(\"we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting\");\n            }\n            if (DEBUG) {\n              console.log(\"so just returning previousFactorisation times dividend: \" + previousFactorisation + \" * \" + dividend);\n            }\n            push(previousFactorisation);\n            push(dividend);\n            prev_expanding = expanding;\n            expanding = 0;\n            yycondense();\n            expanding = prev_expanding;\n            multiply_noexpand();\n            partOfPolynomialFactoredSoFar = pop();\n            stack[h] = partOfPolynomialFactoredSoFar;\n            moveTos(h + 1);\n            restore();\n            return;\n          }\n//console.log(\"result: (still to be factored) \" + remainingPoly)\n\n          //push(remainingPoly)\n//degree()\n//remainingDegree = pop()\n/*\nif compare_numbers(startingDegree, remainingDegree)\n * ok even if we found a complex root that\n * together with the conjugate generates a poly in Z,\n * that doesn't mean that the division would end up in Z.\n * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots\n * so a factor is 1+x^2 ( = (x+i)*(x-i))\n * BUT \n */\n          for (i = j1 = 0, ref2 = factpoly_expo; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n            pop();\n          }\n          coeff(variable, remainingPoly);\n          factpoly_expo -= 2;\n        }\n      }\n    }\n    //console.log(\"factpoly_expo: \" + factpoly_expo)\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" building the remaining unfactored part of the polynomial\");\n    }\n    push(zero);\n    for (i = l1 = 0, ref3 = factpoly_expo; (0 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[polycoeff + i]);\n      push(variable); // the free variable\n      push_integer(i);\n      power();\n      multiply();\n      add();\n    }\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" remaining unfactored part of the polynomial: \" + polynomial.toString());\n    }\n    push(polynomial);\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" new poly with extracted common factor: \" + polynomial.toString());\n    }\n    //debugger\n\n    // factor out negative sign\n    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {\n      push(polynomial);\n      //prev_expanding = expanding\n      //expanding = 1\n      negate();\n      //expanding = prev_expanding\n      polynomial = pop();\n      push(partOfPolynomialFactoredSoFar);\n      negate_noexpand();\n      partOfPolynomialFactoredSoFar = pop();\n    }\n    push(partOfPolynomialFactoredSoFar);\n    push(polynomial);\n    multiply_noexpand();\n    partOfPolynomialFactoredSoFar = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" result: \" + partOfPolynomialFactoredSoFar);\n    }\n    stack[h] = partOfPolynomialFactoredSoFar;\n    moveTos(h + 1);\n    return restore();\n  };\n\n  rationalize_coefficients = function(h) {\n    var i, i1, o, ratio, ratioInverse, ref, ref1, ref2, ref3;\n    // LCM of all polynomial coefficients\n    ratio = one;\n    for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      push(stack[i]);\n      denominator();\n      push(ratio);\n      lcm();\n      ratio = pop();\n    }\n// multiply each coefficient by RESULT\n    for (i = i1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      push(ratio);\n      push(stack[i]);\n      multiply();\n      stack[i] = pop();\n    }\n    // reciprocate RESULT\n    push(ratio);\n    reciprocate();\n    ratioInverse = pop();\n    if (DEBUG) {\n      console.log(\"rationalize_coefficients result: \" + ratioInverse.toString());\n    }\n    return ratioInverse;\n  };\n\n  get_factor_from_real_root = function(variable, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, j1, l1, m1, na0, nan, o, polynomial, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j, testDenominator, testNumerator, testValue;\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root\");\n    }\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (DEBUG) {\n      push(zero);\n      for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(stack[polycoeff + i]);\n        push(variable);\n        push_integer(i);\n        power();\n        multiply();\n        add();\n      }\n      polynomial = pop();\n      console.log(\"POLY=\" + polynomial);\n    }\n    h = tos;\n    an = tos;\n    push(stack[polycoeff + factpoly_expo]);\n    divisors_onstack();\n    nan = tos - an;\n    a0 = tos;\n    push(stack[polycoeff + 0]);\n    divisors_onstack();\n    na0 = tos - a0;\n    if (DEBUG) {\n      console.log(\"divisors of base term\");\n      for (i = i1 = 0, ref1 = na0; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        console.log(\", \" + stack[a0 + i]);\n      }\n      console.log(\"divisors of leading term\");\n      for (i = j1 = 0, ref2 = nan; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        console.log(\", \" + stack[an + i]);\n      }\n    }\n// try roots\n    for (rootsTries_i = l1 = 0, ref3 = nan; (0 <= ref3 ? l1 < ref3 : l1 > ref3); rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {\n      for (rootsTries_j = m1 = 0, ref4 = na0; (0 <= ref4 ? m1 < ref4 : m1 > ref4); rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {\n        //if DEBUG then console.log \"nan: \" + nan + \" na0: \" + na0 + \" i: \" + rootsTries_i + \" j: \" + rootsTries_j\n        testNumerator = stack[an + rootsTries_i];\n        testDenominator = stack[a0 + rootsTries_j];\n        push(testDenominator);\n        push(testNumerator);\n        divide();\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n        push(testDenominator);\n        negate();\n        testDenominator = pop();\n        push(testValue);\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root returning\");\n    }\n    return [0, null, null];\n  };\n\n  get_factor_from_complex_root = function(remainingPoly, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, na0, nan, o, rootsTries_i, rootsTries_j, testValue;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (factpoly_expo <= 2) {\n      if (DEBUG) {\n        console.log(\"no more factoring via complex roots to be found in polynomial of degree <= 2\");\n      }\n      return [0, null];\n    }\n    if (DEBUG) {\n      console.log(\"complex root finding for POLY=\" + remainingPoly);\n    }\n    h = tos;\n    an = tos;\n    // trying -1^(2/3) which generates a polynomial in Z\n    // generates x^2 + 2x + 1\n    push_integer(-1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n    // trying 1^(2/3) which generates a polynomial in Z\n    // http://www.wolframalpha.com/input/?i=(1)%5E(2%2F3)\n    // generates x^2 - 2x + 1\n    push_integer(1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n// trying some simple complex numbers. All of these\n// generate polynomials in Z\n    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {\n      for (rootsTries_j = i1 = 1; i1 <= 5; rootsTries_j = ++i1) {\n        push_integer(rootsTries_i);\n        push_integer(rootsTries_j);\n        push(imaginaryunit);\n        multiply();\n        add();\n        rect();\n        testValue = pop();\n        if (DEBUG) {\n          console.log(\"complex root finding: trying simple complex combination \" + testValue);\n        }\n        push(testValue);\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        //console.log(\"complex root finding result: \" + evalPolyResult)\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"found complex root: \" + evalPolyResult);\n          }\n          return [1, testValue];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_complex_root returning 0\");\n    }\n    return [0, null];\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide a polynomial by Ax+B\n\n  //  Input:  on stack:  polycoeff  Dividend coefficients\n\n  //      factpoly_expo   as parameter\n\n  //      A    as parameter\n\n  //      B    as parameter\n\n  //  Output:   on stack: polycoeff  Contains quotient coefficients\n\n  //-----------------------------------------------------------------------------\n  yydivpoly = function(factpoly_expo, polycoeff, A, B) {\n    var Q, i, o, ref;\n    Q = zero;\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      push(stack[polycoeff + i]);\n      stack[polycoeff + i] = Q;\n      push(A);\n      divide();\n      Q = pop();\n      push(stack[polycoeff + i - 1]);\n      push(Q);\n      push(B);\n      multiply();\n      subtract();\n      stack[polycoeff + i - 1] = pop();\n    }\n    stack[polycoeff + 0] = Q;\n    if (DEBUG) {\n      return console.log(\"yydivpoly Q: \" + Q.toString());\n    }\n  };\n\n  Evalpoly = function(factpoly_expo, polycoeff, evaluateAt) {\n    var i, o, ref;\n    push(zero);\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o <= 0 : o >= 0); i = ref <= 0 ? ++o : --o) {\n      push(evaluateAt);\n      multiply();\n      push(stack[polycoeff + i]);\n      //if DEBUG\n      //  console.log(\"Evalpoly top of stack:\")\n      //  console.log stack[tos-i].toString()\n      add();\n    }\n    return pop();\n  };\n\n  // Push expression factors onto the stack. For example...\n\n  // Input\n\n  //       2\n  //     3x  + 2x + 1\n\n  // Output on stack\n\n  //     [  3  ]\n  //     [ x^2 ]\n  //     [  2  ]\n  //     [  x  ]\n  //     [  1  ]\n\n  // but not necessarily in that order. Returns the number of factors.\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  factors = function(p) {\n    var h;\n    h = tos;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        push_term_factors(car(p));\n        p = cdr(p);\n      }\n    } else {\n      push_term_factors(p);\n    }\n    return tos - h;\n  };\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  push_term_factors = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return push(p);\n    }\n  };\n\n  Eval_filter = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      filter();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    filter_main();\n    return restore();\n  };\n\n  filter_main = function() {\n    if (car(p1) === symbol(ADD)) {\n      return filter_sum();\n    } else if (istensor(p1)) {\n      return filter_tensor();\n    } else if (Find(p1, p2)) {\n      return push_integer(0);\n    } else {\n      return push(p1);\n    }\n  };\n\n  filter_sum = function() {\n    var results;\n    push_integer(0);\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      filter();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter_tensor = function() {\n    var i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    n = p1.tensor.nelem;\n    p3 = alloc_tensor(n);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      filter();\n      p3.tensor.elem[i] = pop();\n    }\n    return push(p3);\n  };\n\n  Eval_float = function() {\n    evaluatingAsFloats++;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    return evaluatingAsFloats--;\n  };\n\n  checkFloatHasWorkedOutCompletely = function(nodeToCheck) {\n    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;\n    numberOfPowers = countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);\n    numberOfPIs = countOccurrencesOfSymbol(symbol(PI), nodeToCheck);\n    numberOfEs = countOccurrencesOfSymbol(symbol(E), nodeToCheck);\n    numberOfMults = countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);\n    numberOfSums = countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);\n    if (DEBUG) {\n      console.log(\"     ... numberOfPowers: \" + numberOfPowers);\n      console.log(\"     ... numberOfPIs: \" + numberOfPIs);\n      console.log(\"     ... numberOfEs: \" + numberOfEs);\n      console.log(\"     ... numberOfMults: \" + numberOfMults);\n      console.log(\"     ... numberOfSums: \" + numberOfSums);\n    }\n    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {\n      return stop(\"float: some unevalued parts in \" + nodeToCheck);\n    }\n  };\n\n  zzfloat = function() {\n    save();\n    evaluatingAsFloats++;\n    //p1 = pop()\n    //push(cadr(p1))\n    //push(p1)\n    Eval();\n    yyfloat();\n    Eval();\n    evaluatingAsFloats--;\n    return restore();\n  };\n\n  // zzfloat doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, this line comes handy to highlight\n  // when that doesn't happen for those tests.\n  //checkFloatHasWorkedOutCompletely(stack[tos-1])\n  yyfloat = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    evaluatingAsFloats++;\n    save();\n    p1 = pop();\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        yyfloat();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        yyfloat();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n    } else if (p1.k === NUM) {\n      push(p1);\n      bignum_float();\n    } else if (p1 === symbol(PI)) {\n      push_double(Math.PI);\n    } else if (p1 === symbol(E)) {\n      push_double(Math.E);\n    } else {\n      push(p1);\n    }\n    restore();\n    return evaluatingAsFloats--;\n  };\n\n  Eval_floor = function() {\n    push(cadr(p1));\n    Eval();\n    return yfloor();\n  };\n\n  yfloor = function() {\n    save();\n    yyfloor();\n    return restore();\n  };\n\n  yyfloor = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(FLOOR);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.floor(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      push_integer(-1);\n      return add();\n    }\n  };\n\n  // 'for' function\n  /*\n  x=0\n  y=2\n  for(do(x=sqrt(2+x),y=2*y/x),k,1,9)\n  float(y)\n\n  X: k\n  B: 1...9\n\n  1st parameter is the body\n  2nd parameter is the variable to loop with\n  3rd and 4th are the limits\n\n  */\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n  Eval_for = function() {\n    var i, j, k, loopingVariable, o, ref, ref1;\n    i = 0;\n    j = 0;\n    k = 0;\n    loopingVariable = caddr(p1);\n    if (!issymbol(loopingVariable)) {\n      stop(\"for: 2nd arg should be the variable to loop over\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(loopingVariable);\n    for (i = o = ref = j, ref1 = k; (ref <= ref1 ? o <= ref1 : o >= ref1); i = ref <= ref1 ? ++o : --o) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(loopingVariable, p5);\n      push(cadr(p1));\n      Eval();\n      pop();\n    }\n    // put back the index variable to original content\n    set_binding(loopingVariable, p4);\n    // return value\n    return push_symbol(NIL);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Gamma function gamma(x)\n\n  //-----------------------------------------------------------------------------\n  Eval_gamma = function() {\n    push(cadr(p1));\n    Eval();\n    return gamma();\n  };\n\n  gamma = function() {\n    save();\n    gammaf();\n    return restore();\n  };\n\n  gammaf = function() {\n    //  double d\n    p1 = pop();\n    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      return;\n    }\n    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      push_rational(1, 2);\n      multiply();\n      return;\n    }\n    \n    //  if (p1->k == DOUBLE) {\n    //    d = exp(lgamma(p1.d))\n    //    push_double(d)\n    //    return\n    //  }\n    if (isnegativeterm(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_integer(-1);\n      multiply();\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push(p1);\n      multiply();\n      sine();\n      push(p1);\n      multiply();\n      push(p1);\n      negate();\n      gamma();\n      multiply();\n      divide();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gamma_of_sum();\n      return;\n    }\n    push_symbol(GAMMA);\n    push(p1);\n    list(2);\n  };\n\n  gamma_of_sum = function() {\n    p3 = cdr(p1);\n    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {\n      push(cadr(p3));\n      push(cadr(p3));\n      gamma();\n      return multiply();\n    } else {\n      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {\n        push(cadr(p3));\n        gamma();\n        push(cadr(p3));\n        push_integer(-1);\n        add();\n        return divide();\n      } else {\n        push_symbol(GAMMA);\n        push(p1);\n        list(2);\n      }\n    }\n  };\n\n  // Greatest common denominator\n  // can also be run on polynomials, however\n  // it works only on the integers and it works\n  // by factoring the polynomials (not Euclidean algorithm)\n  Eval_gcd = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      gcd();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  gcd = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    gcd_main();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  gcd_main = function() {\n    var polyVar;\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"gcd_main: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (equal(p1, p2)) {\n      push(p1);\n      return;\n    }\n    if (isrational(p1) && isrational(p2)) {\n      push(p1);\n      push(p2);\n      gcd_numbers();\n      return;\n    }\n    if ((polyVar = areunivarpolysfactoredorexpandedform(p1, p2))) {\n      gcd_polys(polyVar);\n      return;\n    }\n    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {\n      gcd_sum_sum();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gcd_sum(p1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(ADD)) {\n      gcd_sum(p2);\n      p2 = pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      gcd_sum_product();\n      return;\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      gcd_product_sum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    return gcd_powers_with_same_base();\n  };\n\n  areunivarpolysfactoredorexpandedform = function(p1, p2) {\n    var polyVar;\n    if (DEBUG) {\n      console.log(\"areunivarpolysfactoredorexpandedform: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (polyVar = isunivarpolyfactoredorexpandedform(p1)) {\n      if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {\n        return polyVar;\n      }\n    }\n    return false;\n  };\n\n  gcd_polys = function(polyVar) {\n    if (DEBUG) {\n      console.log(\"gcd_polys: p1: \" + p1 + \" polyVar: \" + polyVar);\n    }\n    // gcd of factors\n    push(p1);\n    push(polyVar);\n    factorpoly();\n    p1 = pop();\n    push(p2);\n    push(polyVar);\n    factorpoly();\n    p2 = pop();\n    if (DEBUG) {\n      console.log(\"GCD: factored polys:\");\n    }\n    if (DEBUG) {\n      console.log(\"  p1:\" + p1.toString());\n    }\n    if (DEBUG) {\n      console.log(\"  p2:\" + p2.toString());\n    }\n    // In case one of two polynomials can be factored,\n    // (and only in that case), then\n    // we'll need to run gcd_factors on the two polynomials.\n    // (In case neither of them can be factored there is no gcd).\n    // However, gcd_factors expects two _products_ , and\n    // in case _one_ of the polynomials can't be factored it will look\n    // like a sum instead of a product.\n    // So, we'll have to make that sum to look like a factor:\n    // let's just turn it into a product with 1.\n\n    // in case one of the two polys has been factored...\n    if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {\n      // then make sure that if one of them is a single\n      // factor, we take the sum and wrap it into a\n      // multiplication by 1\n      if (car(p1) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push(one);\n        list(3);\n        p1 = pop();\n      }\n      if (car(p2) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p2);\n        push(one);\n        list(3);\n        p2 = pop();\n      }\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    gcd_powers_with_same_base();\n    return true;\n  };\n\n  gcd_product_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      p4 = cdr(p2);\n      while (iscons(p4)) {\n        push(car(p3));\n        push(car(p4));\n        gcd();\n        multiply();\n        p4 = cdr(p4);\n      }\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_powers_with_same_base = function() {\n    if (car(p1) === symbol(POWER)) {\n      p3 = caddr(p1); // exponent\n      p1 = cadr(p1); // base\n    } else {\n      p3 = one;\n    }\n    if (car(p2) === symbol(POWER)) {\n      p4 = caddr(p2); // exponent\n      p2 = cadr(p2); // base\n    } else {\n      p4 = one;\n    }\n    if (!equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    // are both exponents numerical?\n    if (isNumericAtom(p3) && isNumericAtom(p4)) {\n      push(p1);\n      if (lessp(p3, p4)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    // are the exponents multiples of eah other?\n    push(p3);\n    push(p4);\n    divide();\n    p5 = pop();\n    if (isNumericAtom(p5)) {\n      push(p1);\n      // choose the smallest exponent\n      if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {\n        p5 = cadr(p3);\n      } else {\n        p5 = one;\n      }\n      if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {\n        p6 = cadr(p4);\n      } else {\n        p6 = one;\n      }\n      if (lessp(p5, p6)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    push(p3);\n    push(p4);\n    subtract();\n    p5 = pop();\n    if (!isNumericAtom(p5)) {\n      push(one);\n      return;\n    }\n    // can't be equal because of test near beginning\n    push(p1);\n    if (isnegativenumber(p5)) {\n      push(p3);\n    } else {\n      push(p4);\n    }\n    return power();\n  };\n\n  // in this case gcd is used as a composite function, i.e. gcd(gcd(gcd...\n  gcd_sum_sum = function() {\n    if (length(p1) !== length(p2)) {\n      push(one);\n      return;\n    }\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    p3 = pop();\n    p4 = cdr(p2);\n    push(car(p4));\n    p4 = cdr(p4);\n    while (iscons(p4)) {\n      push(car(p4));\n      gcd();\n      p4 = cdr(p4);\n    }\n    p4 = pop();\n    push(p1);\n    push(p3);\n    divide();\n    p5 = pop();\n    push(p2);\n    push(p4);\n    divide();\n    p6 = pop();\n    if (equal(p5, p6)) {\n      push(p5);\n      push(p3);\n      push(p4);\n      gcd();\n      return multiply();\n    } else {\n      return push(one);\n    }\n  };\n\n  gcd_sum = function(p) {\n    var results;\n    p = cdr(p);\n    push(car(p));\n    p = cdr(p);\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      gcd();\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  gcd_sum_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      push(car(p3));\n      push(p2);\n      gcd();\n      multiply();\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_product_sum = function() {\n    var results;\n    push(one);\n    p4 = cdr(p2);\n    results = [];\n    while (iscons(p4)) {\n      push(p1);\n      push(car(p4));\n      gcd();\n      multiply();\n      results.push(p4 = cdr(p4));\n    }\n    return results;\n  };\n\n  // Guess which symbol to use for derivative, integral, etc.\n  guess = function() {\n    var p;\n    p = pop();\n    push(p);\n    if (Find(p, symbol(SYMBOL_X))) {\n      return push_symbol(SYMBOL_X);\n    } else if (Find(p, symbol(SYMBOL_Y))) {\n      return push_symbol(SYMBOL_Y);\n    } else if (Find(p, symbol(SYMBOL_Z))) {\n      return push_symbol(SYMBOL_Z);\n    } else if (Find(p, symbol(SYMBOL_T))) {\n      return push_symbol(SYMBOL_T);\n    } else if (Find(p, symbol(SYMBOL_S))) {\n      return push_symbol(SYMBOL_S);\n    } else {\n      return push_symbol(SYMBOL_X);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Hermite polynomial\n\n  //  Input:    tos-2    x  (can be a symbol or expr)\n\n  //      tos-1    n\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  hermite = function() {\n    save();\n    yyhermite();\n    return restore();\n  };\n\n  // uses the recurrence relation H(x,n+1)=2*x*H(x,n)-2*n*H(x,n-1)\n\n  //define X p1\n  //define N p2\n  //define Y p3\n  //define Y1 p4\n  //define Y0 p5\n  yyhermite = function() {\n    var n;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(HERMITE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (issymbol(p1)) {\n      return yyhermite2(n);\n    } else {\n      p3 = p1;\n      p1 = symbol(SECRETX);\n      yyhermite2(n);\n      p1 = p3;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      return Eval();\n    }\n  };\n\n  yyhermite2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p4 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p4;\n      p4 = pop();\n      push(p1);\n      push(p4);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(2);\n      results.push(multiply());\n    }\n    return results;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Create a Hilbert matrix\n\n  //  Input:    Dimension on stack\n\n  //  Output:    Hilbert matrix on stack\n\n  //  Example:\n\n  //  > hilbert(5)\n  //  ((1,1/2,1/3,1/4),(1/2,1/3,1/4,1/5),(1/3,1/4,1/5,1/6),(1/4,1/5,1/6,1/7))\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define N p2\n\n  //define AELEM(i, j) A->u.tensor->elem[i * n + j]\n  hilbert = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p2 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 2) {\n      push_symbol(HILBERT);\n      push(p2);\n      list(2);\n      restore();\n      return;\n    }\n    push_zero_matrix(n, n);\n    p1 = pop();\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push_integer(i + j + 1);\n        inverse();\n        p1.tensor.elem[i * n + j] = pop();\n      }\n    }\n    push(p1);\n    return restore();\n  };\n\n  DEBUG_IMAG = false;\n\n  Eval_imag = function() {\n    push(cadr(p1));\n    Eval();\n    return imag();\n  };\n\n  imag = function() {\n    save();\n    rect();\n    p1 = pop();\n    if (DEBUG_IMAG) {\n      console.log(\"IMAGE of \" + p1);\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    if (DEBUG_IMAG) {\n      console.log(\" image: conjugate result: \" + stack[tos - 1]);\n    }\n    subtract();\n    push_integer(2);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 1st divide result: \" + stack[tos - 1]);\n    }\n    push(imaginaryunit);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 2nd divide result: \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // n is the total number of things on the stack. The first thing on the stack\n  // is the object to be indexed, followed by the indices themselves.\n\n  // called by Eval_index\n  index_function = function(n) {\n    var i, i1, j1, k, l1, m, m1, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    save();\n    s = tos - n;\n    p1 = stack[s];\n    ndim = p1.tensor.ndim;\n    m = n - 1;\n    if (m > ndim) {\n      stop(\"too many indices for tensor\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 1]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"index out of range\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    if (ndim === m) {\n      moveTos(tos - n);\n      push(p1.tensor.elem[k]);\n      restore();\n      return;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    nelem = 1;\n    for (i = j1 = ref3 = m, ref4 = ndim; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); i = ref3 <= ref4 ? ++j1 : --j1) {\n      nelem *= p1.tensor.dim[i];\n    }\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - m;\n    for (i = l1 = ref5 = m, ref6 = ndim; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n      p2.tensor.dim[i - m] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref7 = nelem; (0 <= ref7 ? m1 < ref7 : m1 > ref7); i = 0 <= ref7 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[k + i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n    Number of args on stack\n\n  //      tos-n    Right-hand value\n\n  //      tos-n+1    Left-hand value\n\n  //      tos-n+2    First index\n\n  //      .\n  //      .\n  //      .\n\n  //      tos-1    Last index\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define LVALUE p1\n  //define RVALUE p2\n  //define TMP p3\n  set_component = function(n) {\n    var i, i1, j1, k, l1, m, m1, n1, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    t = 0;\n    save();\n    if (n < 3) {\n      stop(\"error in indexed assign\");\n    }\n    s = tos - n;\n    p2 = stack[s];\n    p1 = stack[s + 1];\n    if (!istensor(p1)) { // p1 is LVALUE\n      stop(\"error in indexed assign: assigning to something that is not a tensor\");\n    }\n    ndim = p1.tensor.ndim;\n    m = n - 2;\n    if (m > ndim) {\n      stop(\"error in indexed assign\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 2]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"error in indexed assign\\n\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    // copy\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = j1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref4 = p1.tensor.nelem; (0 <= ref4 ? l1 < ref4 : l1 > ref4); i = 0 <= ref4 ? ++l1 : --l1) {\n      p3.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p3);\n    p1 = p3;\n    if (ndim === m) {\n      if (istensor(p2)) { // p2 is RVALUE\n        stop(\"error in indexed assign\");\n      }\n      p1.tensor.elem[k] = p2;\n      check_tensor_dimensions(p1);\n      moveTos(tos - n);\n      push(p1);\n      restore();\n      return;\n    }\n    if (!istensor(p2)) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n    if (ndim - m !== p2.tensor.ndim) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n// p2 is RVALUE\n    for (i = m1 = 0, ref5 = p2.tensor.ndim; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {\n        stop(\"error in indexed assign\");\n      }\n    }\n// p2 is RVALUE\n// copy rvalue\n    for (i = n1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? n1 < ref6 : n1 > ref6); i = 0 <= ref6 ? ++n1 : --n1) {\n      p1.tensor.elem[k + i] = p2.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p1);\n    return restore();\n  };\n\n  Eval_inner = function() {\n    var difference, i, i1, j1, l1, moretheArguments, o, operands, ref, ref1, ref2, ref3, refinedOperands, results, secondArgument, shift, theArguments;\n    \n    // if there are more than two arguments then\n    // reduce it to a more standard version\n    // of two arguments, which means we need to\n    // transform the arguments into a tree of\n    // inner products e.g.\n    // inner(a,b,c) becomes inner(a,inner(b,c))\n    // this is so we can get to a standard binary-tree\n    // version that is simpler to manipulate.\n    theArguments = [];\n    theArguments.push(car(cdr(p1)));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    moretheArguments = cdr(cdr(p1));\n    while (moretheArguments !== symbol(NIL)) {\n      theArguments.push(car(moretheArguments));\n      moretheArguments = cdr(moretheArguments);\n    }\n    // make it so e.g. inner(a,b,c) becomes inner(a,inner(b,c))\n    if (theArguments.length > 2) {\n      push_symbol(INNER);\n      push(theArguments[theArguments.length - 2]);\n      push(theArguments[theArguments.length - 1]);\n      list(3);\n      for (i = o = 2, ref = theArguments.length; (2 <= ref ? o < ref : o > ref); i = 2 <= ref ? ++o : --o) {\n        push_symbol(INNER);\n        swap();\n        push(theArguments[theArguments.length - i - 1]);\n        swap();\n        list(3);\n      }\n      p1 = pop();\n      Eval_inner();\n      return;\n    }\n    // TODO we have to take a look at the whole\n    // sequence of operands and make simplifications\n    // on that...\n    operands = [];\n    get_innerprod_factors(p1, operands);\n    //console.log \"printing operands --------\"\n    //for i in [0...operands.length]\n    //  console.log \"operand \" + i + \" : \" + operands[i]\n    refinedOperands = [];\n// removing all identity matrices\n    for (i = i1 = 0, ref1 = operands.length; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (operands[i] === symbol(SYMBOL_IDENTITY_MATRIX)) {\n        continue;\n      } else {\n        refinedOperands.push(operands[i]);\n      }\n    }\n    operands = refinedOperands;\n    refinedOperands = [];\n    if (operands.length > 1) {\n      // removing all consecutive pairs of inverses\n      // so we can answer that inv(a)·a results in the\n      // identity matrix. We want to catch symbolic inverses\n      // not numeric inverses, those will just take care\n      // of themselves when multiplied\n      shift = 0;\n      for (i = j1 = 0, ref2 = operands.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        //console.log \"comparing if \" + operands[i+shift] + \" and \" + operands[i+shift+1] + \" are inverses of each other\"\n        if ((i + shift + 1) <= (operands.length - 1)) {\n          if (!(isNumericAtomOrTensor(operands[i + shift]) || isNumericAtomOrTensor(operands[i + shift + 1]))) {\n            push(operands[i + shift]);\n            Eval();\n            inv();\n            push(operands[i + shift + 1]);\n            Eval();\n            subtract();\n            difference = pop();\n            //console.log \"result: \" + difference\n            if (isZeroAtomOrTensor(difference)) {\n              shift += 1;\n            } else {\n              refinedOperands.push(operands[i + shift]);\n            }\n          } else {\n            refinedOperands.push(operands[i + shift]);\n          }\n        } else {\n          break;\n        }\n        //console.log \"i: \" + i + \" shift: \" + shift + \" operands.length: \" + operands.length\n        if (i + shift === operands.length - 2) {\n          //console.log \"adding last operand 2 \"\n          refinedOperands.push(operands[operands.length - 1]);\n        }\n        if (i + shift >= operands.length - 1) {\n          break;\n        }\n      }\n      operands = refinedOperands;\n    }\n    //console.log \"refined operands --------\"\n    //for i in [0...refinedOperands.length]\n    //  console.log \"refined operand \" + i + \" : \" + refinedOperands[i]\n\n    //console.log \"stack[tos-1]: \" + stack[tos-1]\n\n    // now rebuild the arguments, just using the\n    // refined operands\n    push(symbol(INNER));\n    //console.log \"rebuilding the argument ----\"\n    if (operands.length > 0) {\n      for (i = l1 = 0, ref3 = operands.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        //console.log \"pushing \" + operands[i]\n        push(operands[i]);\n      }\n    } else {\n      pop();\n      push(symbol(SYMBOL_IDENTITY_MATRIX));\n      return;\n    }\n    //console.log \"list(operands.length): \" + (operands.length+1)\n    list(operands.length + 1);\n    p1 = pop();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      inner();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // inner definition\n  inner = function() {\n    var arg1, arg2, arg3, subtractionResult;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // more in general, when a and b are scalars,\n    // inner(a*M1, b*M2) is equal to\n    // a*b*inner(M1,M2), but of course we can only\n    // \"bring out\" in a and b the scalars, because\n    // it's the only commutative part.\n    // that's going to be trickier to do in general\n    // but let's start with just the signs.\n    if (isnegativeterm(p2) && isnegativeterm(p1)) {\n      push(p2);\n      negate();\n      p2 = pop();\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // since inner is associative,\n    // put it in a canonical form i.e.\n    // inner(inner(a,b),c) ->\n    // inner(a,inner(b,c))\n    // so that we can recognise when they\n    // are equal.\n    if (isinnerordot(p1)) {\n      arg1 = car(cdr(p1)); //a\n      arg2 = car(cdr(cdr(p1))); //b\n      arg3 = p2;\n      p1 = arg1;\n      push(arg2);\n      push(arg3);\n      inner();\n      p2 = pop();\n    }\n    // Check if one of the operands is the identity matrix\n    // we could maybe use Eval_testeq here but\n    // this seems to suffice?\n    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p2);\n      restore();\n      return;\n    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      inner_f();\n    } else {\n      if (!(isNumericAtomOrTensor(p1) || isNumericAtomOrTensor(p2))) {\n        push(p1);\n        push(p2);\n        inv();\n        subtract();\n        subtractionResult = pop();\n        if (isZeroAtomOrTensor(subtractionResult)) {\n          push_symbol(SYMBOL_IDENTITY_MATRIX);\n          restore();\n          return;\n        }\n      }\n      // if either operand is a sum then distribute\n      // (if we are in expanding mode)\n      if (expanding && isadd(p1)) {\n        p1 = cdr(p1);\n        push(zero);\n        while (iscons(p1)) {\n          push(car(p1));\n          push(p2);\n          inner();\n          add();\n          p1 = cdr(p1);\n        }\n        restore();\n        return;\n      }\n      if (expanding && isadd(p2)) {\n        p2 = cdr(p2);\n        push(zero);\n        while (iscons(p2)) {\n          push(p1);\n          push(car(p2));\n          inner();\n          add();\n          p2 = cdr(p2);\n        }\n        restore();\n        return;\n      }\n      push(p1);\n      push(p2);\n      // there are 8 remaining cases here, since each of the\n      // two arguments can only be a scalar/tensor/unknown\n      // and the tensor - tensor case was caught\n      // upper in the code\n      if (istensor(p1) && isNumericAtom(p2)) {\n        // one case covered by this branch:\n        //   tensor - scalar\n        tensor_times_scalar();\n      } else if (isNumericAtom(p1) && istensor(p2)) {\n        // one case covered by this branch:\n        //   scalar - tensor\n        scalar_times_tensor();\n      } else {\n        if (isNumericAtom(p1) || isNumericAtom(p2)) {\n          // three cases covered by this branch:\n          //   unknown - scalar\n          //   scalar - unknown\n          //   scalar  - scalar\n          // in these cases a normal multiplication\n          // will be OK\n          multiply();\n        } else {\n          // three cases covered by this branch:\n          //   unknown - unknown\n          //   unknown - tensor\n          //   tensor  - unknown\n          // in this case we can't use normal\n          // multiplication.\n          pop();\n          pop();\n          push_symbol(INNER);\n          push(p1);\n          push(p2);\n          list(3);\n          restore();\n          return;\n        }\n      }\n    }\n    return restore();\n  };\n\n  // inner product of tensors p1 and p2\n  inner_f = function() {\n    var a, ak, b, bk, c, i, i1, j, j1, k, l1, m1, n, n1, ndim, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    n = p1.tensor.dim[p1.tensor.ndim - 1];\n    if (n !== p2.tensor.dim[0]) {\n      debugger;\n      stop(\"inner: tensor dimension check\");\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;\n    if (ndim > MAXDIM) {\n      stop(\"inner: rank of result exceeds maximum\");\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    //---------------------------------------------------------------------\n\n    //  ak is the number of rows in tensor A\n\n    //  bk is the number of columns in tensor B\n\n    //  Example:\n\n    //  A[3][3][4] B[4][4][3]\n\n    //    3  3        ak = 3 * 3 = 9\n\n    //                  4  3    bk = 4 * 3 = 12\n\n    //---------------------------------------------------------------------\n    ak = 1;\n    for (i = o = 0, ref = p1.tensor.ndim - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      ak *= p1.tensor.dim[i];\n    }\n    bk = 1;\n    for (i = i1 = 1, ref1 = p2.tensor.ndim; (1 <= ref1 ? i1 < ref1 : i1 > ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      bk *= p2.tensor.dim[i];\n    }\n    p3 = alloc_tensor(ak * bk);\n    c = p3.tensor.elem;\n// new method copied from ginac http://www.ginac.de/\n    for (i = j1 = 0, ref2 = ak; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n        if (isZeroAtomOrTensor(a[i * n + j])) {\n          continue;\n        }\n        for (k = m1 = 0, ref4 = bk; (0 <= ref4 ? m1 < ref4 : m1 > ref4); k = 0 <= ref4 ? ++m1 : --m1) {\n          push(a[i * n + j]);\n          push(b[j * bk + k]);\n          multiply();\n          push(c[i * bk + k]);\n          add();\n          c[i * bk + k] = pop();\n        }\n      }\n    }\n    //---------------------------------------------------------------------\n\n    //  Note on understanding \"k * bk + j\"\n\n    //  k * bk because each element of a column is bk locations apart\n\n    //  + j because the beginnings of all columns are in the first bk \n    //  locations\n\n    //  Example: n = 2, bk = 6\n\n    //  b111  <- 1st element of 1st column\n    //  b112  <- 1st element of 2nd column\n    //  b113  <- 1st element of 3rd column\n    //  b121  <- 1st element of 4th column\n    //  b122  <- 1st element of 5th column\n    //  b123  <- 1st element of 6th column\n\n    //  b211  <- 2nd element of 1st column\n    //  b212  <- 2nd element of 2nd column\n    //  b213  <- 2nd element of 3rd column\n    //  b221  <- 2nd element of 4th column\n    //  b222  <- 2nd element of 5th column\n    //  b223  <- 2nd element of 6th column\n\n    //---------------------------------------------------------------------\n    if (ndim === 0) {\n      return push(p3.tensor.elem[0]);\n    } else {\n      p3.tensor.ndim = ndim;\n      j = 0;\n      for (i = n1 = 0, ref5 = p1.tensor.ndim - 1; (0 <= ref5 ? n1 < ref5 : n1 > ref5); i = 0 <= ref5 ? ++n1 : --n1) {\n        p3.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      j = p1.tensor.ndim - 1;\n      for (i = o1 = 0, ref6 = p2.tensor.ndim - 1; (0 <= ref6 ? o1 < ref6 : o1 > ref6); i = 0 <= ref6 ? ++o1 : --o1) {\n        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];\n      }\n      return push(p3);\n    }\n  };\n\n  // Algebrite.run('c·(b+a)ᵀ·inv((a+b)ᵀ)·d').toString();\n  // Algebrite.run('c*(b+a)ᵀ·inv((a+b)ᵀ)·d').toString();\n  // Algebrite.run('(c·(b+a)ᵀ)·(inv((a+b)ᵀ)·d)').toString();\n  get_innerprod_factors = function(tree, factors_accumulator) {\n    if (!iscons(tree)) {\n      add_factor_to_accumulator(tree, factors_accumulator);\n      return;\n    }\n    if (cdr(tree) === symbol(NIL)) {\n      tree = get_innerprod_factors(car(tree), factors_accumulator);\n      return;\n    }\n    if (isinnerordot(tree)) {\n      // console.log \"there is inner at top, recursing on the operands\"\n      get_innerprod_factors(car(cdr(tree)), factors_accumulator);\n      get_innerprod_factors(cdr(cdr(tree)), factors_accumulator);\n      return;\n    }\n    return add_factor_to_accumulator(tree, factors_accumulator);\n  };\n\n  add_factor_to_accumulator = function(tree, factors_accumulator) {\n    if (tree !== symbol(NIL)) {\n      // console.log \">> adding to factors_accumulator: \" + tree\n      return factors_accumulator.push(tree);\n    }\n  };\n\n  itab = [\n    // 1\n    \"f(a,a*x)\",\n    // 9 (need a caveat for 7 so we can put 9 after 7)\n    \"f(1/x,log(x))\",\n    // 7\n    \"f(x^a,x^(a+1)/(a+1))\",\n    // five specialisations of case 7 for speed.\n    // Covers often-occurring exponents: each of\n    // these case ends up in a dedicated entry, so we\n    // only have to do one sure-shot match.\n    \"f(x^(-2),-x^(-1))\",\n    \"f(x^(-1/2),2*x^(1/2))\",\n    \"f(x^(1/2),2/3*x^(3/2))\",\n    \"f(x,x^2/2)\",\n    \"f(x^2,x^3/3)\",\n    // 12\n    \"f(exp(a*x),1/a*exp(a*x))\",\n    \"f(exp(a*x+b),1/a*exp(a*x+b))\",\n    \"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\",\n    \"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\",\n    // 14\n    \"f(log(a*x),x*log(a*x)-x)\",\n    // 15\n    \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\",\n    // 16\n    \"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\",\n    // 17\n    \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\",\n    // 19\n    \"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\",\n    // 20\n    \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\",\n    // 27\n    \"f(1/(a+b*x),1/b*log(a+b*x))\",\n    // 28\n    \"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\",\n    // 29\n    \"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\",\n    // 30\n    \"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\",\n    // 31\n    \"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\",\n    // 33\n    \"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\",\n    // 34\n    \"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\",\n    // 35\n    \"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\",\n    // 37\n    \"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\",\n    // 38\n    \"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\",\n    // 39\n    \"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\",\n    // 40\n    \"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\",\n    // 41\n    \"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\",\n    // 42\n    \"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\",\n    // 60\n    \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\",\n    // 61\n    \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\",\n    // 62 is the same as 60\n    // 63\n    \"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\",\n    //64\n    \"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\",\n    //65\n    \"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\",\n    //66 is covered by 61\n    //70\n    \"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\",\n    //71\n    \"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\",\n    //74\n    \"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\",\n    //76\n    \"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\",\n    // float(defint(1/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //77\n    //\"f(1/(a+b*x^4),1/2*1/a*(a/b/4)^(1/4)*(1/2*log((x^2+2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2))/(x^2-2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2)))+arctan(2*(a/b/4)^(1/4)*x/(2*(a/b/4)^(1/2)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //78\n    //\"f(1/(a+b*x^4),1/2*(-a/b)^(1/4)/a*(1/2*log((x+(-a/b)^(1/4))/(x-(-a/b)^(1/4)))+arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //79\n    \"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\",\n    //80\n    \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\",\n    // float(defint(X^2/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //81\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(a/b/4)^(-1/4)*(1/2*log((x^2-2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4))/(x^2+2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4)))+arctan(2*(a/b/4)^(1/4)*x/(2*sqrt(a/b/4)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //82\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(-a/b)^(-1/4)*(log((x-(-a/b)^(1/4))/(x+(-a/b)^(1/4)))+2*arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //83\n    \"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\",\n    //124\n    \"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\",\n    //125\n    \"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\",\n    //126\n    \"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\",\n    //128\n    \"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //129\n    \"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\",\n    //131\n    \"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\",\n    //132\n    \"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\",\n    //133\n    \"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\",\n    //135\n    \"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\",\n    //136\n    \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\",\n    //137\n    \"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //156\n    \"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\",\n    //157\n    \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\",\n    //158\n    \"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\",\n    //159\n    \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //160\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //161\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\",\n    //162\n    \"f(x/sqrt(x^2+a),sqrt(x^2+a))\",\n    //163\n    \"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\",\n    //164 need an unexpanded version?\n    \"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\",\n    // match doesn't work for the following\n    \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\",\n    //165\n    \"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\",\n    //166\n    \"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\",\n    //167\n    \"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\",\n    //168\n    \"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\",\n    //169\n    \"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\",\n    //170\n    \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\",\n    //171\n    \"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\",\n    //172\n    \"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\",\n    //173\n    \"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\",\n    //174\n    \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\",\n    //175\n    \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\",\n    //176+\n    \"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\",\n    //176-\n    \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\",\n    //177+\n    \"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\",\n    //177-\n    \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\",\n    //196\n    \"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\",\n    //197\n    \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\",\n    //200+\n    \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\",\n    //201    (seems to be handled somewhere else)\n    //202\n    \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //203\n    \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //204\n    \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\",\n    //205\n    \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\",\n    //210\n    \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\",\n    //211\n    \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\",\n    //214\n    \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //215\n    \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\",\n    //216\n    \"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //217\n    \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\",\n    //218\n    \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\",\n    // 273\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\",\n    // 274\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\",\n    // 290\n    \"f(sin(a*x),-cos(a*x)/a)\",\n    // 291\n    \"f(cos(a*x),sin(a*x)/a)\",\n    // 292\n    \"f(tan(a*x),-log(cos(a*x))/a)\",\n    // 293\n    \"f(1/tan(a*x),log(sin(a*x))/a)\",\n    // 294\n    \"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\",\n    // 295\n    \"f(1/sin(a*x),log(tan(a*x/2))/a)\",\n    // 296\n    \"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\",\n    // 297\n    \"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\",\n    // 298\n    \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 302\n    \"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\",\n    // 303\n    \"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\",\n    // 304\n    \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 308\n    \"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\",\n    // 312\n    \"f(1/cos(a*x)^2,tan(a*x)/a)\",\n    // 318\n    \"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\",\n    // 320\n    \"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\",\n    // 326\n    \"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\",\n    // 327\n    \"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\",\n    // 328\n    \"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\",\n    // 329\n    \"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\",\n    // 330\n    \"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\",\n    // 331\n    \"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\",\n    // 333\n    \"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\",\n    // 335\n    \"f(sin(a+b*x),-cos(a+b*x)/b)\",\n    // 336\n    \"f(cos(a+b*x),sin(a+b*x)/b)\",\n    // 337+ (with the addition of b)\n    \"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\",\n    // 337- (with the addition of b)\n    \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\",\n    // 338 (with the addition of b)\n    \"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\",\n    // 339 (with the addition of b)\n    \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\",\n    // 340\n    \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 341\n    \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 389\n    \"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\",\n    // 390\n    \"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\",\n    // 393\n    \"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\",\n    // 394\n    \"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\",\n    // 441\n    \"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\",\n    // 442\n    \"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\",\n    // 443\n    \"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\",\n    // 485 (with addition of a)\n    // however commenting out since it's a duplicate of 14\n    // \"f(log(a*x),x*log(a*x)-x)\",\n    // 486 (with addition of a)\n    \"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\",\n    // 487 (with addition of a)\n    \"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\",\n    // 489\n    \"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\",\n    // 493 (with addition of a)\n    \"f(1/x*1/(a+log(x)),log(a+log(x)))\",\n    // 499\n    \"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\",\n    // 500\n    \"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\",\n    // 554\n    \"f(sinh(x),cosh(x))\",\n    // 555\n    \"f(cosh(x),sinh(x))\",\n    // 556\n    \"f(tanh(x),log(cosh(x)))\",\n    // 560\n    \"f(x*sinh(x),x*cosh(x)-sinh(x))\",\n    // 562\n    \"f(x*cosh(x),x*sinh(x)-cosh(x))\",\n    // 566\n    \"f(sinh(x)^2,sinh(2*x)/4-x/2)\",\n    // 569\n    \"f(tanh(x)^2,x-tanh(x))\",\n    // 572\n    \"f(cosh(x)^2,sinh(2*x)/4+x/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\",\n    // ?\n    \"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\",\n    // these are needed for the surface integral in the manual\n    \"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\",\n    \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\",\n    \"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\",\n    \"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\",\n    \"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\",\n    \"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\",\n    \"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\",\n    0\n  ];\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_integral = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    // evaluate 1st arg to get function F\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example    result of 2nd arg  what to do\n\n    // integral(f)    nil      guess X, N = nil\n    // integral(f,2)  2      guess X, N = 2\n    // integral(f,x)  x      X = x, N = nil\n    // integral(f,x,2)  x      X = x, N = 2\n    // integral(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // N might be a symbol instead of a number\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth integral: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          integral();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          derivative();\n        }\n      }\n      p3 = pop();\n      // if N is nil then arglist is exhausted\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) {\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) {\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // N = arg1\n      }\n    }\n    return push(p3); // final result\n  };\n\n  integral = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      integral_of_sum();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      integral_of_product();\n    } else {\n      integral_of_form();\n    }\n    p1 = pop();\n    if (Find(p1, symbol(INTEGRAL))) {\n      stop(\"integral: sorry, could not find a solution\");\n    }\n    push(p1);\n    simplify();\n    Eval();\n    return restore();\n  };\n\n  integral_of_sum = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    push(p2);\n    integral();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      integral();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  integral_of_product = function() {\n    push(p1);\n    push(p2);\n    partition();\n    p1 = pop();\n    integral_of_form();\n    return multiply(); // multiply constant part\n  };\n\n  integral_of_form = function() {\n    var hc, tab;\n    hc = italu_hashcode(p1, p2).toFixed(6);\n    tab = hashed_itab[hc];\n    if (!tab) {\n      // debugger\n      // italu_hashcode(p1, p2)\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p1); // free variable\n    push(p2); // input expression\n    transform(tab, false);\n    p3 = pop();\n    if (p3 === symbol(NIL)) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(p3);\n    }\n  };\n\n  // Implementation of hash codes based on ITALU (An Integral Table Look-Up)\n  // https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680004891.pdf\n  // see Appendix A, page 153\n\n  // The first two values are from the ITALU paper.\n  // The others are just arbitrary constants.\n  hashcode_values = {\n    'x': 0.95532,\n    'constexp': 1.43762,\n    'constant': 1.14416593629414332,\n    'constbase': 1.20364122304218824,\n    'sin': 1.73305482518303221,\n    'arcsin': 1.6483368529465804,\n    'cos': 1.058672123686340116,\n    'arccos': 1.8405225918106694,\n    'tan': 1.12249437762925064,\n    'arctan': 1.1297397925394962,\n    'sinh': 1.8176164926060078,\n    'cosh': 1.9404934661708022,\n    'tanh': 1.6421307715103121,\n    'log': 1.47744370135492387,\n    'erf': 1.0825269225702916\n  };\n\n  italu_hashcode = function(u, x) {\n    var half;\n    if (issymbol(u)) {\n      if (equal(u, x)) {\n        return hashcode_values.x;\n      } else {\n        return hashcode_values.constant;\n      }\n    } else if (iscons(u)) {\n      switch (symnum(car(u))) {\n        case ADD:\n          return hash_addition(cdr(u), x);\n        case MULTIPLY:\n          return hash_multiplication(cdr(u), x);\n        case POWER:\n          return hash_power(cadr(u), caddr(u), x);\n        case EXP:\n          return hash_power(symbol(E), cadr(u), x);\n        case SQRT:\n          push_double(0.5);\n          half = pop();\n          return hash_power(cadr(u), half, x);\n        default:\n          return hash_function(u, x);\n      }\n    }\n    return hashcode_values.constant;\n  };\n\n  hash_function = function(u, x) {\n    var arg_hash, base, name;\n    if (!Find(cadr(u), x)) {\n      return hashcode_values.constant;\n    }\n    name = car(u);\n    arg_hash = italu_hashcode(cadr(u), x);\n    base = hashcode_values[name.printname];\n    if (!base) {\n      throw new Error('Unsupported function ' + name.printname);\n    }\n    return Math.pow(base, arg_hash);\n  };\n\n  hash_addition = function(terms, x) {\n    var k, sum, term, term_hash, term_set, v;\n    term_set = {};\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      term_hash = 0;\n      if (Find(term, x)) {\n        term_hash = italu_hashcode(term, x);\n      } else {\n        // The original algorithm would skip this,\n        // but recording that it was present helps\n        // prevent collisions.\n        term_hash = hashcode_values.constant;\n      }\n      term_set[term_hash.toFixed(6)] = true;\n    }\n    sum = 0;\n    for (k in term_set) {\n      if (!hasProp.call(term_set, k)) continue;\n      v = term_set[k];\n      sum = sum + parseFloat(k, 10);\n    }\n    return sum;\n  };\n\n  hash_multiplication = function(terms, x) {\n    var product, term;\n    product = 1;\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      if (Find(term, x)) {\n        product = product * italu_hashcode(term, x);\n      }\n    }\n    return product;\n  };\n\n  hash_power = function(base, power, x) {\n    var base_hash, exp_hash;\n    base_hash = hashcode_values.constant;\n    exp_hash = hashcode_values.constexp;\n    if (Find(base, x)) {\n      base_hash = italu_hashcode(base, x);\n    }\n    if (Find(power, x)) {\n      exp_hash = italu_hashcode(power, x);\n    } else {\n      // constant to constant = constant\n      if (base_hash === hashcode_values.constant) {\n        return hashcode_values.constant;\n      }\n      if (isminusone(power)) {\n        exp_hash = -1;\n      } else if (isoneovertwo(power)) {\n        exp_hash = 0.5;\n      } else if (isminusoneovertwo(power)) {\n        exp_hash = -0.5;\n      } else if (equalq(power, 2, 1)) {\n        exp_hash = 2;\n      } else if (equalq(power, -2, 1)) {\n        exp_hash = -2;\n      }\n    }\n    return Math.pow(base_hash, exp_hash);\n  };\n\n  make_hashed_itab = function() {\n    var f, h, key, len, o, s, tab, u;\n    tab = {};\n    for (o = 0, len = itab.length; o < len; o++) {\n      s = itab[o];\n      if (!s) {\n        break;\n      }\n      scan_meta(s);\n      f = pop();\n      u = cadr(f);\n      h = italu_hashcode(u, symbol(METAX));\n      key = h.toFixed(6);\n      if (!tab[key]) {\n        tab[key] = [];\n      }\n      tab[key].push(s);\n    }\n    console.log('hashed_itab = ' + JSON.stringify(tab, null, 2));\n    return tab;\n  };\n\n  $.make_hashed_itab = make_hashed_itab;\n\n  // pre-calculated hashed integral table.\n  // in case the integral table is changed, use this\n  //   Algebrite.make_hashed_itab()\n  // and copy the resulting JSON in here.\n  hashed_itab = {\n    \"1.144166\": [\"f(a,a*x)\"],\n    \"1.046770\": [\"f(1/x,log(x))\"],\n    \"0.936400\": [\"f(x^a,x^(a+1)/(a+1))\"],\n    \"1.095727\": [\"f(x^(-2),-x^(-1))\"],\n    \"1.023118\": [\"f(x^(-1/2),2*x^(1/2))\"],\n    \"0.977405\": [\"f(x^(1/2),2/3*x^(3/2))\"],\n    \"0.955320\": [\"f(x,x^2/2)\"],\n    \"0.912636\": [\"f(x^2,x^3/3)\"],\n    \"1.137302\": [\"f(exp(a*x),1/a*exp(a*x))\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\"],\n    \"1.326774\": [\"f(exp(a*x+b),1/a*exp(a*x+b))\"],\n    \"1.080259\": [\"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\"],\n    \"1.260228\": [\"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\"],\n    \"1.451902\": [\"f(log(a*x),x*log(a*x)-x)\"],\n    \"0.486192\": [\"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.697274\": [\"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\"],\n    \"0.476307\": [\"f(1/(a+b*x),1/b*log(a+b*x))\"],\n    \"0.226868\": [\"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\"],\n    \"2.904531\": [\"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\"],\n    \"0.455026\": [\"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\"],\n    \"0.216732\": [\"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\"],\n    \"0.434695\": [\"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\"],\n    \"0.207048\": [\"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\"],\n    \"2.650781\": [\"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\"],\n    \"0.498584\": [\"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\"],\n    \"0.237479\": [\"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\"],\n    \"3.040375\": [\"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\"],\n    \"0.521902\": [\"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\"],\n    \"0.446014\": [\"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\"],\n    \"0.248586\": [\"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\"],\n    \"0.464469\": [\"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\"],\n    \"0.443716\": [\"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\"],\n    \"0.236382\": [\"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\"],\n    \"0.508931\": [\"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\"],\n    \"0.532733\": [\"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\"],\n    \"0.480638\": [\"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\"],\n    \"0.438648\": [\"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\"],\n    \"0.459164\": [\"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.450070\": [\"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\"],\n    \"1.448960\": [\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\"],\n    \"1.384221\": [\"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\"],\n    \"1.322374\": [\"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\"],\n    \"1.516728\": [\"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.587665\": [\"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"0.690150\": [\"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\"],\n    \"0.659314\": [\"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\"],\n    \"0.629856\": [\"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\"],\n    \"0.722428\": [\"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\"],\n    \"0.756216\": [\"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.434156\": [\"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\"],\n    \"0.729886\": [\"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"1.501230\": [\"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"0.666120\": [\"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\"],\n    \"1.370077\": [\"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\"],\n    \"1.730087\": [\"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\"],\n    \"0.578006\": [\"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\"],\n    \"0.552180\": [\"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\"],\n    \"1.652787\": [\"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\"],\n    \"1.308862\": [\"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\"],\n    \"1.342944\": [\"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\"],\n    \"0.636358\": [\"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"0.652928\": [\"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\"],\n    \"0.764022\": [\"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\"],\n    \"1.578940\": [\"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\"],\n    \"1.620055\": [\"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\"],\n    \"0.332117\": [\"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\"],\n    \"1.571443\": [\"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"1.690994\": [\"f(sin(a*x),-cos(a*x)/a)\"],\n    \"1.055979\": [\"f(cos(a*x),sin(a*x)/a)\"],\n    \"1.116714\": [\"f(tan(a*x),-log(cos(a*x))/a)\"],\n    \"0.895484\": [\"f(1/tan(a*x),log(sin(a*x))/a)\"],\n    \"0.946989\": [\"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\"],\n    \"0.591368\": [\"f(1/sin(a*x),log(tan(a*x/2))/a)\"],\n    \"2.859462\": [\"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\"],\n    \"2.128050\": [\"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"1.115091\": [\"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\"],\n    \"1.081452\": [\"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"0.349716\": [\"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\"],\n    \"0.896788\": [\"f(1/cos(a*x)^2,tan(a*x)/a)\"],\n    \"1.785654\": [\"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\"],\n    \"3.188560\": [\"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\"],\n    \"1.516463\": [\"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\"],\n    \"2.707879\": [\"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\"],\n    \"0.369293\": [\"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\"],\n    \"0.560019\": [\"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\"],\n    \"0.530332\": [\"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\"],\n    \"0.331177\": [\"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\"],\n    \"0.313621\": [\"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\"],\n    \"3.172365\": [\"f(sin(a+b*x),-cos(a+b*x)/b)\"],\n    \"1.127162\": [\"f(cos(a+b*x),sin(a+b*x)/b)\"],\n    \"0.352714\": [\"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\"],\n    \"0.454515\": [\"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\"],\n    \"1.615441\": [\"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\"],\n    \"1.543263\": [\"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\"],\n    \"1.008798\": [\"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\"],\n    \"0.963724\": [\"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\"],\n    \"1.611938\": [\"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\"],\n    \"1.791033\": [\"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\"],\n    \"1.123599\": [\"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\"],\n    \"1.387031\": [\"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\"],\n    \"1.325058\": [\"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\"],\n    \"2.108018\": [\"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\"],\n    \"0.403214\": [\"f(1/x*1/(a+log(x)),log(a+log(x)))\"],\n    \"2.269268\": [\"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\"],\n    \"2.486498\": [\"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\"],\n    \"1.769733\": [\"f(sinh(x),cosh(x))\"],\n    \"1.883858\": [\"f(cosh(x),sinh(x))\"],\n    \"1.606140\": [\"f(tanh(x),log(cosh(x)))\"],\n    \"1.690661\": [\"f(x*sinh(x),x*cosh(x)-sinh(x))\"],\n    \"1.799688\": [\"f(x*cosh(x),x*sinh(x)-cosh(x))\"],\n    \"3.131954\": [\"f(sinh(x)^2,sinh(2*x)/4-x/2)\"],\n    \"2.579685\": [\"f(tanh(x)^2,x-tanh(x))\"],\n    \"3.548923\": [\"f(cosh(x)^2,sinh(2*x)/4+x/2)\"],\n    \"1.058866\": [\"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\"],\n    \"1.235270\": [\"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\"],\n    \"1.130783\": [\"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\"],\n    \"1.078698\": [\"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\"],\n    \"2.573650\": [\"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\"],\n    \"2.640666\": [\"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\"],\n    \"1.086487\": [\"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\"],\n    \"1.267493\": [\"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\"],\n    \"1.037943\": [\"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.210862\": [\"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.064970\": [\"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\"],\n    \"1.242392\": [\"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\"]\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack (must have two dimensions but\n  //        it can be non-numerical)\n\n  //  Output:    Inverse on stack\n\n  //  Example:\n\n  //  > inv(((1,2),(3,4))\n  //  ((-2,1),(3/2,-1/2))\n\n  //  > inv(((a,b),(c,d))\n  //  ((d / (a d - b c),-b / (a d - b c)),(-c / (a d - b c),a / (a d - b c)))\n\n  //  Note:\n\n  //  THIS IS DIFFERENT FROM INVERSE OF AN EXPRESSION (inv)\n  //   Uses Gaussian elimination for numerical matrices.\n\n  //-----------------------------------------------------------------------------\n  INV_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  inv = function() {\n    var accumulator, eachEntry, i, n, o, ref;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    // an inv just goes away when\n    // applied to another inv\n    if (isinv(p1)) {\n      push(car(cdr(p1)));\n      restore();\n      return;\n    }\n    // inverse goes away in case\n    // of identity matrix\n    if (isidentitymatrix(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // distribute the inverse of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push(car(p1));\n        p1 = cdr(p1);\n      }\n      for (eachEntry = o = ref = accumulator.length - 1; (ref <= 0 ? o <= 0 : o >= 0); eachEntry = ref <= 0 ? ++o : --o) {\n        push(accumulator[eachEntry]);\n        inv();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (INV_check_arg() === 0) {\n      push_symbol(INV);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    if (isNumericAtomOrTensor(p1)) {\n      yyinvg();\n    } else {\n      push(p1);\n      adj();\n      push(p1);\n      det();\n      p2 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        stop(\"inverse of singular matrix\");\n      }\n      push(p2);\n      divide();\n    }\n    return restore();\n  };\n\n  invg = function() {\n    save();\n    p1 = pop();\n    if (INV_check_arg() === 0) {\n      push_symbol(INVG);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yyinvg();\n    return restore();\n  };\n\n  // inverse using gaussian elimination\n  yyinvg = function() {\n    var h, i, i1, j, j1, l1, n, o, ref, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    h = tos;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i === j) {\n          push(one);\n        } else {\n          push(zero);\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = n * n; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      push(p1.tensor.elem[i]);\n    }\n    INV_decomp(n);\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = l1 = 0, ref3 = n * n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(tos - 2 * n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n unit matrix on stack\n\n  //      n * n operand on stack\n\n  //  Output:    n * n inverse matrix on stack\n\n  //      n * n garbage on stack\n\n  //      p2 mangled\n\n  //-----------------------------------------------------------------------------\n\n  //define A(i, j) stack[a + n * (i) + (j)]\n  //define U(i, j) stack[u + n * (i) + (j)]\n  INV_decomp = function(n) {\n    var a, d, i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4, results, u;\n    a = 0;\n    d = 0;\n    i = 0;\n    j = 0;\n    u = 0;\n    a = tos - n * n;\n    u = a - n * n;\n    results = [];\n    for (d = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(stack[a + n * d + d], zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(stack[a + n * i + d], zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          stop(\"inverse of singular matrix\");\n        }\n// exchange rows\n        for (j = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); j = 0 <= ref3 ? ++j1 : --j1) {\n          p2 = stack[a + n * d + j];\n          stack[a + n * d + j] = stack[a + n * i + j];\n          stack[a + n * i + j] = p2;\n          p2 = stack[u + n * d + j];\n          stack[u + n * d + j] = stack[u + n * i + j];\n          stack[u + n * i + j] = p2;\n        }\n      }\n      // multiply the pivot row by 1 / pivot\n      p2 = stack[a + n * d + d];\n      for (j = l1 = 0, ref4 = n; (0 <= ref4 ? l1 < ref4 : l1 > ref4); j = 0 <= ref4 ? ++l1 : --l1) {\n        if (j > d) {\n          push(stack[a + n * d + j]);\n          push(p2);\n          divide();\n          stack[a + n * d + j] = pop();\n        }\n        push(stack[u + n * d + j]);\n        push(p2);\n        divide();\n        stack[u + n * d + j] = pop();\n      }\n      results.push((function() {\n        var m1, ref5, results1;\n// clear out the column above and below the pivot\n        results1 = [];\n        for (i = m1 = 0, ref5 = n; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n          if (i === d) {\n            continue;\n          }\n          // multiplier\n          p2 = stack[a + n * i + d];\n          results1.push((function() {\n            var n1, ref6, results2;\n// add pivot row to i-th row\n            results2 = [];\n            for (j = n1 = 0, ref6 = n; (0 <= ref6 ? n1 < ref6 : n1 > ref6); j = 0 <= ref6 ? ++n1 : --n1) {\n              if (j > d) {\n                push(stack[a + n * i + j]);\n                push(stack[a + n * d + j]);\n                push(p2);\n                multiply();\n                subtract();\n                stack[a + n * i + j] = pop();\n              }\n              push(stack[u + n * i + j]);\n              push(stack[u + n * d + j]);\n              push(p2);\n              multiply();\n              subtract();\n              results2.push(stack[u + n * i + j] = pop());\n            }\n            return results2;\n          })());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  DEBUG_IS = false;\n\n  // jsBoolToToInt = (p) ->\n  //   if p then 1 else 0\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtom = function(p) {\n    switch (p.k) {\n      case NUM:\n        return MZERO(p.q.a);\n      case DOUBLE:\n        return p.d === 0.0;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroTensor = function(p) {\n    var i, o, ref;\n    if (p.k !== TENSOR) {\n      return 0;\n    }\n    for (i = o = 0, ref = p.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isZeroAtomOrTensor(p.tensor.elem[i])) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtomOrTensor = function(p) {\n    return isZeroAtom(p) || isZeroTensor(p);\n  };\n\n  // This is a key routine to try to determine whether\n  // the argument looks like zero/false, or non-zero/true,\n  // or undetermined.\n  // This is useful in two instances:\n  //  * to determine if a predicate is true/false\n  //  * to determine if particular quantity is zero\n  // Note that if one wants to check if we have a simple\n  // zero atom or tensor in our hands, then the isZeroAtomOrTensor\n  // routine is sufficient.\n  isZeroLikeOrNonZeroLikeOrUndetermined = function(valueOrPredicate) {\n    var evalledArgument;\n    // push the argument\n    push(valueOrPredicate);\n    // just like Eval but turns assignments into\n    // equality checks\n    Eval_predicate();\n    evalledArgument = pop();\n    // OK first check if we already have\n    // a simple zero (or simple zero tensor)\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    // also check if we have a simple numeric value, or a tensor\n    // full of simple numeric values (i.e. straight doubles or fractions).\n    // In such cases, since we\n    // just excluded they are zero, then we take it as\n    // a \"true\"\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // if we are here we are in the case of value that\n    // is not a zero and not a simple numeric value.\n    // e.g. stuff like\n    // 'sqrt(2)', or 'sin(45)' or '1+i', or 'a'\n    // so in such cases let's try to do a float()\n    // so we might get down to a simple numeric value\n    // in some of those cases\n    push(evalledArgument);\n    zzfloat();\n    evalledArgument = pop();\n    // anything that could be calculated down to a simple\n    // numeric value is now indeed either a \n    // double OR a double with an imaginary component\n    // e.g. 2.0 or 2.4 + i*5.6\n    // (Everything else are things that don't have a numeric\n    // value e.g. 'a+b')\n\n    // So, let's take care of the case where we have\n    // a simple numeric value with NO imaginary component,\n    // things like sqrt(2) or sin(PI)\n    // by doing the simple numeric\n    // values checks again\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // here we still have cases of simple numeric values\n    // WITH an imaginary component e.g. '1+i',\n    // or things that don't have a numeric value e.g. 'a'\n\n    // so now let's take care of the imaginary numbers:\n    // since we JUST have to spot \"zeros\" we can just\n    // calculate the absolute value and re-do all the checks\n    // we just did\n    if (Find(evalledArgument, imaginaryunit)) {\n      push(evalledArgument);\n      absValFloat();\n      Eval_predicate();\n      evalledArgument = pop();\n      // re-do the simple-number checks...\n      if (isZeroAtomOrTensor(evalledArgument)) {\n        return 0;\n      }\n      if (isNumericAtomOrTensor(evalledArgument)) {\n        return 1;\n      }\n    }\n    // here we have stuff that is not reconducible to any\n    // numeric value (or tensor with numeric values) e.g.\n    // 'a+b', so it just means that we just don't know the\n    // truth value, so we have\n    // to leave the whole thing unevalled\n    return null;\n  };\n\n  // p is a U\n  isnegativenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === -1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d < 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  ispositivenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === 1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d > 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplustwo = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 2.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isminusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === -1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isone = function(p) {\n    return isplusone(p) || isminusone(p);\n  };\n\n  isinteger = function(p) {\n    if (p.k === NUM && MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isintegerorintegerfloat = function(p) {\n    if (p.k === DOUBLE) {\n      if (p.d === Math.round(p.d)) {\n        return 1;\n      }\n      return 0;\n    }\n    return isinteger(p);\n  };\n\n  isnonnegativeinteger = function(p) {\n    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isposint = function(p) {\n    if (isinteger(p) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  isunivarpolyfactoredorexpandedform = function(p, x) {\n    if (DEBUG) {\n      console.log(\"isunivarpolyfactoredorexpandedform: p: \" + p + \" x: \" + x);\n    }\n    if (x == null) {\n      push(p);\n      guess();\n      x = pop();\n      pop();\n    }\n    if (ispolyfactoredorexpandedform(p, x) && (Find(p, symbol(SYMBOL_X)) + Find(p, symbol(SYMBOL_Y)) + Find(p, symbol(SYMBOL_Z)) === 1)) {\n      return x;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  // sometimes we want to check if we have a poly in our\n  // hands, however it's in factored form and we don't\n  // want to expand it.\n  ispolyfactoredorexpandedform = function(p, x) {\n    return ispolyfactoredorexpandedform_factor(p, x);\n  };\n\n  ispolyfactoredorexpandedform_factor = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (DEBUG) {\n          console.log(\"ispolyfactoredorexpandedform_factor testing \" + car(p));\n        }\n        if (!ispolyfactoredorexpandedform_power(car(p), x)) {\n          if (DEBUG) {\n            console.log(\"... tested negative:\" + car(p));\n          }\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyfactoredorexpandedform_power(p, x);\n    }\n  };\n\n  ispolyfactoredorexpandedform_power = function(p, x) {\n    if (car(p) === symbol(POWER)) {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power (isposint(caddr(p)) \" + (isposint(caddr(p)), DEBUG ? console.log(\"ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) \" + ispolyexpandedform_expr(cadr(p), x)) : void 0));\n      }\n      return isposint(caddr(p)) && ispolyexpandedform_expr(cadr(p), x);\n    } else {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power not a power, testing if this is exp form: \" + p);\n      }\n      return ispolyexpandedform_expr(p, x);\n    }\n  };\n\n  // --------------------------------------\n  ispolyexpandedform = function(p, x) {\n    if (Find(p, x)) {\n      return ispolyexpandedform_expr(p, x);\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyexpandedform_expr = function(p, x) {\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_term(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_term(p, x);\n    }\n  };\n\n  ispolyexpandedform_term = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_factor(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_factor(p, x);\n    }\n  };\n\n  ispolyexpandedform_factor = function(p, x) {\n    if (equal(p, x)) {\n      return 1;\n    }\n    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {\n      if (isposint(caddr(p))) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    if (Find(p, x)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  // --------------------------------------\n  isnegativeterm = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  hasNegativeRationalExponent = function(p) {\n    if (car(p) === symbol(POWER) && isrational(car(cdr(cdr(p)))) && isnegativenumber(car(cdr(p)))) {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has imaginary component\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has NO imaginary component\");\n      }\n      return 0;\n    }\n  };\n\n  isimaginarynumberdouble = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && hasNegativeRationalExponent(caddr(p))) || equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isimaginarynumber = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isNumericAtom(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit) || hasNegativeRationalExponent(caddr(p))) {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" isn't an imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iscomplexnumberdouble = function(p) {\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p))) || isimaginarynumberdouble(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  iscomplexnumber = function(p) {\n    if (DEBUG_IS) {\n      debugger;\n    }\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isNumericAtom(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iseveninteger = function(p) {\n    if (isinteger(p) && p.q.a.isEven()) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isnegative = function(p) {\n    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {\n      return 1;\n    } else if (isnegativeterm(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // returns 1 if there's a symbol somewhere.\n  // not used anywhere.\n  // NOTE: PI and POWER are symbols,\n  // so for example 2^3 would be symbolic\n  // while -1^(1/2) i.e. 'i' is not, so this can\n  // be tricky to use.\n  issymbolic = function(p) {\n    if (issymbol(p)) {\n      return 1;\n    } else {\n      while (iscons(p)) {\n        if (issymbolic(car(p))) {\n          return 1;\n        }\n        p = cdr(p);\n      }\n      return 0;\n    }\n  };\n\n  // i.e. 2, 2^3, etc.\n  isintegerfactor = function(p) {\n    return isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p));\n  };\n\n  isNumberOneOverSomething = function(p) {\n    return isfraction(p) && MEQUAL(p.q.a.abs(), 1);\n  };\n\n  isoneover = function(p) {\n    return car(p) === symbol(POWER) && isminusone(caddr(p));\n  };\n\n  isfraction = function(p) {\n    return p.k === NUM && !MEQUAL(p.q.b, 1);\n  };\n\n  // p is a U, n an int\n  equaln = function(p, n) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1);\n      case DOUBLE:\n        return p.d === n;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U, a and b ints\n  equalq = function(p, a, b) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b);\n      case DOUBLE:\n        return p.d === a / b;\n      default:\n        return false;\n    }\n  };\n\n  // 1/2 ?\n  isoneovertwo = function(p) {\n    return equalq(p, 1, 2);\n  };\n\n  // -1/2 ?\n  isminusoneovertwo = function(p) {\n    return equalq(p, -1, 2);\n  };\n\n  // 1/sqrt(2) ?\n  isoneoversqrttwo = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2);\n  };\n\n  // -1/sqrt(2) ?\n  isminusoneoversqrttwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3;\n  };\n\n  // sqrt(3)/2 ?\n  issqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // -sqrt(3)/2 ?\n  isminussqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isminusoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // p == sqrt(3) ?\n  issqrtthree = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 3) && isoneovertwo(caddr(p));\n  };\n\n  isfloating = function(p) {\n    if (p.k === DOUBLE || p === symbol(FLOATF)) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isfloating(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  isimaginaryunit = function(p) {\n    if (equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // n/2 * i * pi ?\n\n  // return value:\n\n  //  0  no\n\n  //  1  1\n\n  //  2  -1\n\n  //  3  i\n\n  //  4  -i\n  isquarterturn = function(p) {\n    var minussign, n;\n    n = 0;\n    minussign = 0;\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (equal(cadr(p), imaginaryunit)) {\n      if (caddr(p) !== symbol(PI)) {\n        return 0;\n      }\n      if (length(p) !== 3) {\n        return 0;\n      }\n      return 2;\n    }\n    if (!isNumericAtom(cadr(p))) {\n      return 0;\n    }\n    if (!equal(caddr(p), imaginaryunit)) {\n      return 0;\n    }\n    if (cadddr(p) !== symbol(PI)) {\n      return 0;\n    }\n    if (length(p) !== 4) {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 1) {\n      minussign = 1;\n      n = -n;\n    }\n    switch (n % 4) {\n      case 0:\n        n = 1;\n        break;\n      case 1:\n        if (minussign) {\n          n = 4;\n        } else {\n          n = 3;\n        }\n        break;\n      case 2:\n        n = 2;\n        break;\n      case 3:\n        if (minussign) {\n          n = 3;\n        } else {\n          n = 4;\n        }\n    }\n    return n;\n  };\n\n  // special multiple of pi?\n\n  // returns for the following multiples of pi...\n\n  //  -4/2  -3/2  -2/2  -1/2  1/2  2/2  3/2  4/2\n\n  //  4  1  2  3  1  2  3  4\n  isnpi = function(p) {\n    var doNothing, n;\n    n = 0;\n    if (p === symbol(PI)) {\n      return 2;\n    }\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {\n      doNothing = 0;\n    } else {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 0) {\n      n = 4 - (-n) % 4;\n    } else {\n      n = 1 + (n - 1) % 4;\n    }\n    return n;\n  };\n\n  $.isZeroAtomOrTensor = isZeroAtomOrTensor;\n\n  $.isnegativenumber = isnegativenumber;\n\n  $.isplusone = isplusone;\n\n  $.isminusone = isminusone;\n\n  $.isinteger = isinteger;\n\n  $.isnonnegativeinteger = isnonnegativeinteger;\n\n  $.isposint = isposint;\n\n  $.isnegativeterm = isnegativeterm;\n\n  $.isimaginarynumber = isimaginarynumber;\n\n  $.iscomplexnumber = iscomplexnumber;\n\n  $.iseveninteger = iseveninteger;\n\n  $.isnegative = isnegative;\n\n  $.issymbolic = issymbolic;\n\n  $.isintegerfactor = isintegerfactor;\n\n  $.isoneover = isoneover;\n\n  $.isfraction = isfraction;\n\n  $.isoneoversqrttwo = isoneoversqrttwo;\n\n  $.isminusoneoversqrttwo = isminusoneoversqrttwo;\n\n  $.isfloating = isfloating;\n\n  $.isimaginaryunit = isimaginaryunit;\n\n  $.isquarterturn = isquarterturn;\n\n  $.isnpi = isnpi;\n\n  Eval_isprime = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_laguerre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return laguerre();\n  };\n\n  //define X p1\n  //define N p2\n  //define K p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  laguerre = function() {\n    var n;\n    n = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(LAGUERRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      restore();\n      return;\n    }\n    if (issymbol(p1)) {\n      laguerre2(n);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      laguerre2(n);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return restore();\n  };\n\n  laguerre2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      subtract();\n      push(p3);\n      add();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p3);\n      add();\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      results.push(divide());\n    }\n    return results;\n  };\n\n  // Find the least common multiple of two expressions.\n  Eval_lcm = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      lcm();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  lcm = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    yylcm();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yylcm = function() {\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    gcd();\n    push(p1);\n    divide();\n    push(p2);\n    divide();\n    return inverse();\n  };\n\n  Eval_leading = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return leading();\n  };\n\n  //define P p1\n  //define X p2\n  //define N p3\n  leading = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1); // N = degree of P\n    push(p2);\n    degree();\n    p3 = pop();\n    push(p1); // divide through by X ^ N\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2); // remove terms that depend on X\n    filter();\n    return restore();\n  };\n\n  Eval_legendre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg (optional)\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return legendre();\n  };\n\n  //define X p1\n  //define N p2\n  //define M p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  legendre = function() {\n    save();\n    __legendre();\n    return restore();\n  };\n\n  __legendre = function() {\n    var m, n;\n    m = 0;\n    n = 0;\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {\n      push_symbol(LEGENDRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      return;\n    }\n    if (issymbol(p1)) {\n      __legendre2(n, m);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      __legendre2(n, m);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return __legendre3(m);\n  };\n\n  __legendre2 = function(n, m) {\n    var i, i1, o, ref, ref1, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n//  i=1  p5 = 0 \n//    p6 = 1 \n//    ((2*i+1)*x*p6 - i*p5) / i = x\n\n//  i=2  p5 = 1\n//    p6 = x\n//    ((2*i+1)*x*p6 - i*p5) / i = -1/2 + 3/2*x^2\n\n//  i=3  p5 = x\n//    p6 = -1/2 + 3/2*x^2\n//    ((2*i+1)*x*p6 - i*p5) / i = -3/2*x + 5/2*x^3\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      multiply();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      divide();\n    }\n    results = [];\n    for (i = i1 = 0, ref1 = m; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1);\n      results.push(derivative());\n    }\n    return results;\n  };\n\n  // moveTos tos * (-1)^m * (1-x^2)^(m/2)\n  __legendre3 = function(m) {\n    if (m === 0) {\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      sine();\n      square();\n    } else if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      cosine();\n      square();\n    } else {\n      push_integer(1);\n      push(p1);\n      square();\n      subtract();\n    }\n    push_integer(m);\n    push_rational(1, 2);\n    multiply();\n    power();\n    multiply();\n    if (m % 2) {\n      return negate();\n    }\n  };\n\n  // Create a list from n things on the stack.\n\n  // n is an integer\n  list = function(n) {\n    var listIterator, o, ref, results;\n    listIterator = 0;\n    push(symbol(NIL));\n    results = [];\n    for (listIterator = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); listIterator = 0 <= ref ? ++o : --o) {\n      results.push(cons());\n    }\n    return results;\n  };\n\n  // Natural logarithm.\n\n  // Note that we use the mathematics / Javascript / Mathematica\n  // convention that \"log\" is indeed the natural logarithm.\n\n  // In engineering, biology, astronomy, \"log\" can stand instead\n  // for the \"common\" logarithm i.e. base 10. Also note that Google\n  // calculations use log for the common logarithm.\n  Eval_log = function() {\n    push(cadr(p1));\n    Eval();\n    return logarithm();\n  };\n\n  logarithm = function() {\n    save();\n    yylog();\n    return restore();\n  };\n\n  yylog = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (p1 === symbol(E)) {\n      push_integer(1);\n      return;\n    }\n    if (equaln(p1, 1)) {\n      push_integer(0);\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      logarithm();\n      push(imaginaryunit);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      multiply();\n      add();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.log(p1.d);\n      push_double(d);\n      return;\n    }\n    // rational number and not an integer?\n    if (isfraction(p1)) {\n      push(p1);\n      numerator();\n      logarithm();\n      push(p1);\n      denominator();\n      logarithm();\n      subtract();\n      return;\n    }\n    // log(a ^ b) --> b log(a)\n    if (car(p1) === symbol(POWER)) {\n      push(caddr(p1));\n      push(cadr(p1));\n      logarithm();\n      multiply();\n      return;\n    }\n    // log(a * b) --> log(a) + log(b)\n    if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        logarithm();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    push_symbol(LOG);\n    push(p1);\n    return list(2);\n  };\n\n  // now this might be a little confusing, so a\n  // clarification is in order.\n  // First off, at the scripting level most things\n  // as they are handled get evalled.\n  // That means that they are recursively \"calculated\"\n  // as much as possible, i.e. variables are recursively\n  // looked up for their values, operators are applied,\n  // functions are ivoked, etc.\n  // I.e. while scripting, most things are\n  // evalled all the times.\n  // e.g. if I type\n  //   x = 1+1\n  // then x is actually assigned 2, not 1+1\n  // Something that helps a little is \"quote\", e.g.\n  // If I assign\n  //   x = quote(1+1)\n  // then x actually contains 1+1, not 2.\n  // But then x is evaluated as soon as I type\n  //   x // gives \"2\" as x is evaluated\n\n  // Evaluation is great, but sometimes one wants\n  // to look at the actual structure of an expression\n  // or a content of a variable, without those\n  // being evaluated first.\n\n  // for example I might type\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // and from this point on printing the actual\n  // structure of x is impossible, because from\n  // now on any evaluation of x will give \"3\"\n  // You might say \"but you have x defined up there,\n  // what's the point of printing it out?\", to which\n  // the answer is that one might do further\n  // substitutions or transformations of special kind\n  // to x. One might want to look at the structure\n  // and it might be complex or impossible.\n\n  // So this function does that.\n  // If it's passed a variable, then it\n  // DOES NOT eval the variable, RATHER\n  // it prints the content of the variable without\n  // evaluating it.\n  // In the other cases it works like \"quote\" e.g.\n  // it just gives the argument as is, again without\n  // evaluating it.\n\n  // In the following examples, for brevity, I just\n  // use\n  //   x = quote(1+2)\n  // instead of this:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // to put a structure in x that is easy to see whether\n  // it's avaulated or not.\n\n  // So lookup allows this:\n  //   x = quote(1+2)\n  //   print(lookup(x)) # gives 1+2\n\n  // Note that there would be potentially a way\n  // to achieve a similar result, you could do:\n  //   x = quote(quote(1+2))\n  //   print(x)\n  // but you can't always control x to contain\n  // two quotes like that...\n  // note how two \"quotes\" are needed because\n  // if you just put one, then\n  // x would indeed contain 1+2 instead of 3,\n  // but then print would evaluate that to 3:\n  //   x = quote(1+2) # now x contains 1+2, not 3\n  //   print(x) # but x evaluated here to 3\n\n  // Other workarounds would not work:\n  //   x = quote(1+2)\n  //   print(quote(x))\n  // would not work because quote(x) literally means 'x'\n  // so 'x' is printed instead of its content.\n\n  // Note also that lookup allows you to copy\n  // the structure of a variable to another:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // now:\n  //   y = x # y contains the number 3 and prints to 3\n  //   y = lookup(x) # y contains \"a+b\" and prints to 3\n  //   y = quote(x) # y contains \"x\" and prints to 3\n  // note that in the first and second case y is\n  // independent from x, i.e. changing x doesn't change y\n  // while in the last case it is.\n\n  // Another similar simple example is when doing something\n  // like this:\n  //    x = y\n  //    y = z\n  //    x\n  //       => gives z\n  //    lookup(x)\n  //       => gives y\n  //          i.e. lookup allows you to see the immediate\n  //          content of x, rather than the evaluation which\n  //          would end up in x -> y -> z\n  // Note that if you invert the order of the assignments i.e.\n  //    y = z\n  //    x = y\n  // Then at this point x immediately contains z, since the\n  // assignment x = y is not quoted, hence y is evaluated to z\n  // when assigned to x.\n  //    lookup(x)\n  //       => gives z\n  Eval_lookup = function() {\n    p1 = cadr(p1);\n    if (!iscons(p1) && cadr(p1).k === SYM) {\n      p1 = get_binding(p1);\n    }\n    return push(p1); // Bignum addition and subtraction\n  };\n\n  \n  //static unsigned int *addf(unsigned int *, unsigned int *)\n  //static unsigned int *subf(unsigned int *, unsigned int *)\n  //static int ucmp(unsigned int *, unsigned int *)\n  madd = function(a, b) {\n    return a.add(b);\n  };\n\n  msub = function(a, b) {\n    return a.subtract(b);\n  };\n\n  addf = function(a, b) {\n    return a.add(b);\n  };\n\n  subf = function(a, b) {\n    return a.subtract(b);\n  };\n\n  // unsigned compare\n  ucmp = function(a, b) {\n    return a.compareAbs(b);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum GCD\n\n  //  Uses the binary GCD algorithm.\n\n  //  See \"The Art of Computer Programming\" p. 338.\n\n  //  mgcd always returns a positive value\n\n  //  mgcd(0, 0) = 0\n\n  //  mgcd(u, 0) = |u|\n\n  //  mgcd(0, v) = |v|\n\n  //-----------------------------------------------------------------------------\n  mgcd = function(u, v) {\n    return bigInt.gcd(u, v);\n  };\n\n  //if SELFTEST\n\n  // s is a string\n  new_string = function(s) {\n    var theNewString;\n    theNewString = new U();\n    theNewString.k = STR;\n    theNewString.str = s;\n    return theNewString;\n  };\n\n  out_of_memory = function() {\n    return stop(\"out of memory\");\n  };\n\n  // both ints\n  push_zero_matrix = function(i, j) {\n    push(alloc_tensor(i * j));\n    stack[tos - 1].tensor.ndim = 2;\n    stack[tos - 1].tensor.dim[0] = i;\n    return stack[tos - 1].tensor.dim[1] = j;\n  };\n\n  push_identity_matrix = function(n) {\n    var i, o, ref;\n    push_zero_matrix(n, n);\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[tos - 1].tensor.elem[i * n + i] = one;\n    }\n    return check_tensor_dimensions(stack[tos - 1]);\n  };\n\n  push_cars = function(p) {\n    var results;\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  // see cmp_expr definition, this\n  // function alone just does simple structure comparison\n  // or compares numbers (either rationals or integers or doubles)\n  // but can't be used alone to test\n  // more complex mathematical equalities...\n  equal = function(p1, p2) {\n    if (cmp_expr(p1, p2) === 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  lessp = function(p1, p2) {\n    if (cmp_expr(p1, p2) < 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  sign = function(n) {\n    if (n < 0) {\n      return -1;\n    } else if (n > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // compares whether two expressions\n  // have the same structure.\n  // For example this method alone\n  // would compare \"1+1\" and \"2\"\n  // as different.\n  // It just so happens though that one oftens\n  // evaluates the two sides before passing them\n  // to this function, so chances are that the two\n  // sides have the same normal form.\n  // Even a simple evaluation might not cut it\n  // though... a simplification of both sides\n  // would then help. And even that might not\n  // cut it in some cases...\n  cmp_expr = function(p1, p2) {\n    var n;\n    n = 0;\n    if (p1 === p2) {\n      return 0;\n    }\n    if (p1 === symbol(NIL)) {\n      return -1;\n    }\n    if (p2 === symbol(NIL)) {\n      return 1;\n    }\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      return sign(compare_numbers(p1, p2));\n    }\n    if (isNumericAtom(p1)) {\n      return -1;\n    }\n    if (isNumericAtom(p2)) {\n      return 1;\n    }\n    if (isstr(p1) && isstr(p2)) {\n      return sign(strcmp(p1.str, p2.str));\n    }\n    if (isstr(p1)) {\n      return -1;\n    }\n    if (isstr(p2)) {\n      return 1;\n    }\n    if (issymbol(p1) && issymbol(p2)) {\n      return sign(strcmp(get_printname(p1), get_printname(p2)));\n    }\n    if (issymbol(p1)) {\n      return -1;\n    }\n    if (issymbol(p2)) {\n      return 1;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      return compare_tensors(p1, p2);\n    }\n    if (istensor(p1)) {\n      return -1;\n    }\n    if (istensor(p2)) {\n      return 1;\n    }\n    // recursion here\n    while (iscons(p1) && iscons(p2)) {\n      n = cmp_expr(car(p1), car(p2));\n      if (n !== 0) {\n        return n;\n      }\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    if (iscons(p2)) {\n      return -1;\n    }\n    if (iscons(p1)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  length = function(p) {\n    var n;\n    n = 0;\n    while (iscons(p)) {\n      p = cdr(p);\n      n++;\n    }\n    return n;\n  };\n\n  unique = function(p) {\n    save();\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    unique_f(p);\n    if (p2 !== symbol(NIL)) {\n      p1 = symbol(NIL);\n    }\n    p = p1;\n    restore();\n    return p;\n  };\n\n  unique_f = function(p) {\n    if (isstr(p)) {\n      if (p1 === symbol(NIL)) {\n        p1 = p;\n      } else if (p !== p1) {\n        p2 = p;\n      }\n      return;\n    }\n    while (iscons(p)) {\n      unique_f(car(p));\n      if (p2 !== symbol(NIL)) {\n        return;\n      }\n      p = cdr(p);\n    }\n  };\n\n  ssqrt = function() {\n    push_rational(1, 2);\n    return power();\n  };\n\n  yyexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  exponential = function() {\n    push_symbol(E);\n    swap();\n    return power();\n  };\n\n  square = function() {\n    push_integer(2);\n    return power();\n  };\n\n  //__cmp = (p1, p2) ->\n  //  return cmp_expr(p1, p2)\n\n  // n an integer\n  sort_stack = function(n) {\n    var h, subsetOfStack;\n    //qsort(stack + tos - n, n, sizeof (U *), __cmp)\n    h = tos - n;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n  };\n\n  $.equal = equal;\n\n  $.length = length;\n\n  // Bignum multiplication and division\n  mmul = function(a, b) {\n    return a.multiply(b);\n  };\n\n  mdiv = function(a, b) {\n    return a.divide(b);\n  };\n\n  // a = a + b\n  /*\n  static void\n  addf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # can be signed or unsigned \n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] + b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = a - b\n\n  static void\n  subf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # must be signed\n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] - b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = b * c\n\n  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000\n\n  static void\n  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)\n  {\n    int i\n    unsigned long long t = 0; # must be unsigned\n    for (i = 0; i < len; i++) {\n      t += (unsigned long long) b[i] * c\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n    a[i] = (unsigned int) t\n  }\n  */\n  mmod = function(a, b) {\n    return a.mod(b);\n  };\n\n  // return both quotient and remainder of a/b\n  // we'd have this method as divmod(number)\n  // but obviously doesn't change the passed parameters\n  mdivrem = function(a, b) {\n    var toReturn;\n    toReturn = a.divmod(b);\n    return [toReturn.quotient, toReturn.remainder];\n  };\n\n  //if SELFTEST\n\n  // small integer tests\n  Eval_mod = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return mod();\n  };\n\n  mod = function() {\n    var n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"mod function: divide by zero\");\n    }\n    if (!isNumericAtom(p1) || !isNumericAtom(p2)) {\n      push_symbol(MOD);\n      push(p1);\n      push(p2);\n      list(3);\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      push(p1);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p1 = pop();\n    }\n    if (isdouble(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p2 = pop();\n    }\n    if (!isinteger(p1) || !isinteger(p2)) {\n      stop(\"mod function: integer arguments expected\");\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mmod(p1.q.a, p2.q.a);\n    p3.q.b = mint(1);\n    push(p3);\n    return restore();\n  };\n\n  // Bignum power\n\n  // a is a bigint, n is a small normal int\n  mpow = function(a, n) {\n    return a.pow(n);\n  };\n\n  //if SELFTEST\n\n  // Bignum prime test (returns 1 if prime, 0 if not)\n\n  // Uses Algorithm P (probabilistic primality test) from p. 395 of\n  // \"The Art of Computer Programming, Volume 2\" by Donald E. Knuth.\n  mprime = function(n) {\n    return n.isProbablePrime();\n  };\n\n  //if SELFTEST\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum root\n\n  //  Returns null pointer if not perfect root.\n\n  //  The sign of the radicand is ignored.\n\n  //-----------------------------------------------------------------------------\n  mroot = function(n, index) {\n    var i, j, k, o, ref, x, y;\n    // this doesn't quite work\n    //return n.pow(1/index +  0.0000000000000001)\n\n    // sign of radicand ignored\n    n = n.abs();\n    i = 0;\n    j = 0;\n    k = 0;\n    if (index === 0) {\n      stop(\"root index is zero\");\n    }\n    // count number of bits\n    k = 0;\n    while (n.shiftRight(k) > 0) {\n      k++;\n    }\n    if (k === 0) {\n      return mint(0);\n    }\n    // initial guess\n    k = Math.floor((k - 1) / index);\n    j = Math.floor(k / 32 + 1);\n    x = bigInt(j);\n    for (i = o = 0, ref = j; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      // zero-out the ith bit\n      x = x.and(bigInt(1).shiftLeft(i).not());\n    }\n    while (k >= 0) {\n      // set the kth bit\n      x = x.or(bigInt(1).shiftLeft(k));\n      y = mpow(x, index);\n      switch (mcmp(y, n)) {\n        case 0:\n          return x;\n        case 1:\n          //mp_clr_bit(x, k)\n          // clear the kth bit\n          x = x.and(bigInt(1).shiftLeft(k).not());\n      }\n      k--;\n    }\n    return 0;\n  };\n\n  //if SELFTEST\n\n  // Symbolic multiplication\n\n  // multiplication is commutative, so it can't be used\n  // e.g. on two matrices.\n  // But it can be used, say, on a scalar and a matrix.,\n  // so the output of a multiplication is not\n  // always a scalar.\n\n  //extern void append(void)\n  //static void parse_p1(void)\n  //static void parse_p2(void)\n  //static void __normalize_radical_factors(int)\n  DEBUG_MULTIPLY = false;\n\n  Eval_multiply = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      multiply();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // this one doesn't eval the factors,\n  // so you pass i*(-1)^(1/2), it wouldnt't\n  // give -1, because i is not evalled\n  multiply = function() {\n    if (esc_flag) {\n      stop(\"escape key stop\");\n    }\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply_numbers();\n    } else {\n      save();\n      yymultiply();\n      return restore();\n    }\n  };\n\n  yymultiply = function() {\n    var h, i, n, o, ref, ref1;\n    h = 0;\n    i = 0;\n    n = 0;\n    // pop operands\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    // is either operand zero?\n    if (isZeroAtom(p1) || isZeroAtom(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    // is either operand a sum?\n\n    //console.log(\"yymultiply: expanding: \" + expanding)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        multiply();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    if (expanding && isadd(p2)) {\n      p2 = cdr(p2);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p2)) {\n        push(p1);\n        push(car(p2));\n        multiply();\n        add();\n        p2 = cdr(p2);\n      }\n      return;\n    }\n    if (!istensor(p1) && istensor(p2)) {\n      push(p1);\n      push(p2);\n      scalar_times_tensor();\n      return;\n    }\n    // tensor times scalar?\n    if (istensor(p1) && !istensor(p2)) {\n      push(p1);\n      push(p2);\n      tensor_times_scalar();\n      return;\n    }\n    // adjust operands\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n    } else {\n      push(p1);\n      list(1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n    } else {\n      push(p2);\n      list(1);\n      p2 = pop();\n    }\n    // handle numerical coefficients\n    if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {\n      push(car(p1));\n      push(car(p2));\n      multiply_numbers();\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    } else if (isNumericAtom(car(p1))) {\n      push(car(p1));\n      p1 = cdr(p1);\n    } else if (isNumericAtom(car(p2))) {\n      push(car(p2));\n      p2 = cdr(p2);\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n    }\n    parse_p1();\n    parse_p2();\n    while (iscons(p1) && iscons(p2)) {\n      //    if (car(p1)->gamma && car(p2)->gamma) {\n      //      combine_gammas(h)\n      //      p1 = cdr(p1)\n      //      p2 = cdr(p2)\n      //      parse_p1()\n      //      parse_p2()\n      //      continue\n      //    }\n      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {\n        push_symbol(OPERATOR);\n        push(cdar(p1));\n        push(cdar(p2));\n        append();\n        cons();\n        p1 = cdr(p1);\n        p2 = cdr(p2);\n        parse_p1();\n        parse_p2();\n        continue;\n      }\n      switch (cmp_expr(p3, p4)) {\n        case -1:\n          push(car(p1));\n          p1 = cdr(p1);\n          parse_p1();\n          break;\n        case 1:\n          push(car(p2));\n          p2 = cdr(p2);\n          parse_p2();\n          break;\n        case 0:\n          combine_factors(h);\n          p1 = cdr(p1);\n          p2 = cdr(p2);\n          parse_p1();\n          parse_p2();\n          break;\n        default:\n          stop(\"internal error 2\");\n      }\n    }\n    // push remaining factors, if any\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    while (iscons(p2)) {\n      push(car(p2));\n      p2 = cdr(p2);\n    }\n    // normalize radical factors\n\n    // example: 2*2(-1/2) -> 2^(1/2)\n\n    // must be done after merge because merge may produce radical\n\n    // example: 2^(1/2-a)*2^a -> 2^(1/2)\n    __normalize_radical_factors(h);\n    // this hack should not be necessary, unless power returns a multiply\n\n    //for (i = h; i < tos; i++) {\n    //  if (car(stack[i]) == symbol(MULTIPLY)) {\n    //    multiply_all(tos - h)\n    //    return\n    //  }\n    //}\n    if (expanding) {\n      for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n        if (isadd(stack[i])) {\n          multiply_all(tos - h);\n          return;\n        }\n      }\n    }\n    // n is the number of result factors on the stack\n    n = tos - h;\n    if (n === 1) {\n      return;\n    }\n    // discard integer 1\n    if (isrational(stack[h]) && equaln(stack[h], 1)) {\n      if (n === 2) {\n        p7 = pop();\n        pop();\n        push(p7);\n      } else {\n        stack[h] = symbol(MULTIPLY);\n        list(n);\n      }\n      return;\n    }\n    list(n);\n    p7 = pop();\n    push_symbol(MULTIPLY);\n    push(p7);\n    return cons();\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p1)    factor\n\n  // output:  p3    factor's base\n\n  //    p5    factor's power (possibly 1)\n  parse_p1 = function() {\n    p3 = car(p1);\n    p5 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p3) === symbol(POWER)) {\n      p5 = caddr(p3);\n      return p3 = cadr(p3);\n    }\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p2)    factor\n\n  // output:  p4    factor's base\n\n  //    p6    factor's power (possibly 1)\n  parse_p2 = function() {\n    p4 = car(p2);\n    p6 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p4) === symbol(POWER)) {\n      p6 = caddr(p4);\n      return p4 = cadr(p4);\n    }\n  };\n\n  // h an integer\n  combine_factors = function(h) {\n    push(p4);\n    push(p5);\n    push(p6);\n    add();\n    power();\n    p7 = pop();\n    if (isNumericAtom(p7)) {\n      push(stack[h]);\n      push(p7);\n      multiply_numbers();\n      return stack[h] = pop();\n    } else if (car(p7) === symbol(MULTIPLY)) {\n      // power can return number * factor (i.e. -1 * i)\n      if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {\n        push(stack[h]);\n        push(cadr(p7));\n        multiply_numbers();\n        stack[h] = pop();\n        return push(caddr(p7));\n      } else {\n        return push(p7);\n      }\n    } else {\n      return push(p7);\n    }\n  };\n\n  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];\n\n  //if 0\n\n  // h an int\n  combine_gammas = function(h) {\n    var n;\n    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];\n    if (n < 0) {\n      n = -n;\n      push(stack[h]);\n      negate();\n      stack[h] = pop();\n    }\n    if (n > 1) {\n      return push(_gamma[n]);\n    }\n  };\n\n  // this is useful for example when you are just adding/removing\n  // factors from an already factored quantity.\n  // e.g. if you factored x^2 + 3x + 2 into (x+1)(x+2)\n  // and you want to divide by (x+1) , i.e. you multiply by (x-1)^-1,\n  // then there is no need to expand.\n  multiply_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply();\n    return expanding = prev_expanding;\n  };\n\n  // multiply n factors on stack\n\n  // n an integer\n  multiply_all = function(n) {\n    var h, i, o, ref;\n    i = 0;\n    if (n === 1) {\n      return;\n    }\n    if (n === 0) {\n      push(evaluatingAsFloats ? one_as_double : one);\n      return;\n    }\n    h = tos - n;\n    push(stack[h]);\n    for (i = o = 1, ref = n; (1 <= ref ? o < ref : o > ref); i = 1 <= ref ? ++o : --o) {\n      push(stack[h + i]);\n      multiply();\n    }\n    stack[h] = pop();\n    return moveTos(h + 1);\n  };\n\n  // n an integer\n  multiply_all_noexpand = function(n) {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply_all(n);\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Symbolic division, or numeric division if doubles are found.\n\n  //  Input:    Dividend and divisor on stack\n\n  //  Output:    Quotient on stack\n\n  //-----------------------------------------------------------------------------\n  divide = function() {\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return divide_numbers();\n    } else {\n      inverse();\n      return multiply();\n    }\n  };\n\n  // this is different from inverse of a matrix (inv)!\n  inverse = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return invert_number();\n    } else {\n      push_integer(-1);\n      return power();\n    }\n  };\n\n  reciprocate = function() {\n    return inverse();\n  };\n\n  negate = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return negate_number();\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(-1.0);\n      } else {\n        push_integer(-1);\n      }\n      return multiply();\n    }\n  };\n\n  negate_expand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  negate_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize radical factors\n\n  //  Input:    stack[h]  Coefficient factor, possibly 1\n\n  //      stack[h + 1]  Second factor\n\n  //      stack[tos - 1]  Last factor\n\n  //  Output:    Reduced coefficent and normalized radicals (maybe)\n\n  //  Example:  2*2^(-1/2) -> 2^(1/2)\n\n  //  (power number number) is guaranteed to have the following properties:\n\n  //  1. Base is an integer\n\n  //  2. Absolute value of exponent < 1\n\n  //  These properties are assured by the power function.\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define B p2\n\n  //define BASE p3\n  //define EXPO p4\n\n  //define TMP p5\n\n  // h is an int\n  __normalize_radical_factors = function(h) {\n    var i, i1, j1, o, ref, ref1, ref2, ref3, ref4, ref5;\n    i = 0;\n    // if coeff is 1 or floating then don't bother\n    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {\n      return;\n    }\n// if no radicals then don't bother\n    for (i = o = ref = h + 1, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      if (__is_radical_number(stack[i])) {\n        break;\n      }\n    }\n    if (i === tos) {\n      return;\n    }\n    // ok, try to simplify\n    save();\n    // numerator\n    push(stack[h]);\n    mp_numerator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors numerator: \" + stack[tos - 1]);\n    }\n    p1 = pop();\n    for (i = i1 = ref2 = h + 1, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      if (isplusone(p1) || isminusone(p1)) { // p1 is A\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (!isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // numerator divisible by p3 (base)?\n      push(p1);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      // reduce numerator\n      p1 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(evaluatingAsFloats ? one_as_double : one);\n      push(p4);\n      add();\n      list(3);\n      stack[i] = pop();\n    }\n    // denominator\n    push(stack[h]);\n    mp_denominator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors denominator: \" + stack[tos - 1]);\n    }\n    p2 = pop();\n    for (i = j1 = ref4 = h + 1, ref5 = tos; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); i = ref4 <= ref5 ? ++j1 : --j1) {\n      if (isplusone(p2)) { // p2 is B\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // denominator divisible by p3? #p3 is BASE\n      push(p2);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p5: \" + p5.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical top stack: \" + stack[tos - 1]);\n      }\n      // reduce denominator\n      p2 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(p4);\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p3: \" + p3.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p4: \" + p4.toString());\n      }\n      push(one);\n      subtract();\n      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {\n        if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {\n          // bail out,\n          // we want to avoid going ahead with the subtraction of\n          // the exponents, because that would turn a perfectly good\n          // integer exponent in the denominator into a fractional one\n          // i.e. a radical.\n          // Note that this only prevents new radicals ending up\n          // in the denominator, it doesn't fix existing ones.\n          pop();\n          pop();\n          pop();\n          push(p1);\n          push(p3);\n          divide();\n          p1 = pop();\n          break;\n        }\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical exponent: \" + stack[tos - 1]);\n      }\n      list(3);\n      stack[i] = pop();\n    }\n    // reconstitute the coefficient\n    push(p1);\n    push(p2);\n    divide();\n    stack[h] = pop();\n    return restore();\n  };\n\n  // don't include i\n  // p is a U\n  // TODO should this be in is.coffee ?\n  __is_radical_number = function(p) {\n    // don't use i\n    return car(p) === symbol(POWER) && isNumericAtom(cadr(p)) && isfraction(caddr(p)) && !isminusone(cadr(p));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  > a*hilbert(2)\n  //  ((a,1/2*a),(1/2*a,1/3*a))\n\n  //  Note that \"a\" is presumed to be a scalar. Is this correct?\n\n  //  Yes, because \"*\" has no meaning if \"a\" is a tensor.\n  //  To multiply tensors, \"dot\" or \"outer\" should be used.\n\n  //  > dot(a,hilbert(2))\n  //  dot(a,((1,1/2),(1/2,1/3)))\n\n  //  In this case \"a\" could be a scalar or tensor so the result is not\n  //  expanded.\n\n  //-----------------------------------------------------------------------------\n\n  // find the roots of a polynomial numerically\n  NROOTS_YMAX = 101;\n\n  NROOTS_DELTA = 1.0e-6;\n\n  NROOTS_EPSILON = 1.0e-9;\n\n  NROOTS_ABS = function(z) {\n    return Math.sqrt(z.r * z.r + z.i * z.i);\n  };\n\n  // random between -2 and 2\n  theRandom = 0.0;\n\n  NROOTS_RANDOM = function() {\n    //theRandom += 0.2\n    //return theRandom\n    return 4.0 * Math.random() - 2.0;\n  };\n\n  numericRootOfPolynomial = (function() {\n    class numericRootOfPolynomial {};\n\n    numericRootOfPolynomial.prototype.r = 0.0;\n\n    numericRootOfPolynomial.prototype.i = 0.0;\n\n    return numericRootOfPolynomial;\n\n  }).call(this);\n\n  nroots_a = new numericRootOfPolynomial();\n\n  nroots_b = new numericRootOfPolynomial();\n\n  nroots_x = new numericRootOfPolynomial();\n\n  nroots_y = new numericRootOfPolynomial();\n\n  nroots_fa = new numericRootOfPolynomial();\n\n  nroots_fb = new numericRootOfPolynomial();\n\n  nroots_dx = new numericRootOfPolynomial();\n\n  nroots_df = new numericRootOfPolynomial();\n\n  nroots_c = [];\n\n  for (initNRoots = o = 0, ref = NROOTS_YMAX; (0 <= ref ? o < ref : o > ref); initNRoots = 0 <= ref ? ++o : --o) {\n    nroots_c[initNRoots] = new numericRootOfPolynomial();\n  }\n\n  Eval_nroots = function() {\n    var h, i, i1, j1, k, l1, n, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"nroots: polynomial?\");\n    }\n    // mark the stack\n    h = tos;\n    // get the coefficients\n    n = coeff(p2, p1);\n    if (n > NROOTS_YMAX) {\n      stop(\"nroots: degree?\");\n    }\n// convert the coefficients to real and imaginary doubles\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(stack[h + i]);\n      real();\n      yyfloat();\n      Eval();\n      p1 = pop();\n      push(stack[h + i]);\n      imag();\n      yyfloat();\n      Eval();\n      p2 = pop();\n      if (!isdouble(p1) || !isdouble(p2)) {\n        stop(\"nroots: coefficients?\");\n      }\n      nroots_c[i].r = p1.d;\n      nroots_c[i].i = p2.d;\n    }\n    // pop the coefficients\n    moveTos(h);\n    // n is the number of coefficients, n = deg(p) + 1\n    monic(n);\n    for (k = j1 = ref2 = n; j1 > 1; k = j1 += -1) {\n      findroot(k);\n      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {\n        nroots_a.r = 0.0;\n      }\n      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {\n        nroots_a.i = 0.0;\n      }\n      push_double(nroots_a.r);\n      push_double(nroots_a.i);\n      push(imaginaryunit);\n      multiply();\n      add();\n      NROOTS_divpoly(k);\n    }\n    // now make n equal to the number of roots\n    n = tos - h;\n    if (n > 1) {\n      sort_stack(n);\n      p1 = alloc_tensor(n);\n      p1.tensor.ndim = 1;\n      p1.tensor.dim[0] = n;\n      for (i = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        p1.tensor.elem[i] = stack[h + i];\n      }\n      moveTos(h);\n      return push(p1);\n    }\n  };\n\n  // divide the polynomial by its leading coefficient\n  monic = function(n) {\n    var i1, k, ref1, t;\n    k = 0;\n    t = 0.0;\n    nroots_y.r = nroots_c[n - 1].r;\n    nroots_y.i = nroots_c[n - 1].i;\n    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;\n    for (k = i1 = 0, ref1 = n - 1; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;\n      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;\n    }\n    nroots_c[n - 1].r = 1.0;\n    return nroots_c[n - 1].i = 0.0;\n  };\n\n  // uses the secant method\n  findroot = function(n) {\n    var i1, j, j1, k, nrabs, t;\n    j = 0;\n    k = 0;\n    t = 0.0;\n    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {\n      nroots_a.r = 0.0;\n      nroots_a.i = 0.0;\n      return;\n    }\n    for (j = i1 = 0; i1 < 100; j = ++i1) {\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      compute_fa(n);\n      nroots_b.r = nroots_a.r;\n      nroots_b.i = nroots_a.i;\n      nroots_fb.r = nroots_fa.r;\n      nroots_fb.i = nroots_fa.i;\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      for (k = j1 = 0; j1 < 1000; k = ++j1) {\n        compute_fa(n);\n        nrabs = NROOTS_ABS(nroots_fa);\n        if (DEBUG) {\n          console.log(\"nrabs: \" + nrabs);\n        }\n        if (nrabs < NROOTS_EPSILON) {\n          return;\n        }\n        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {\n          nroots_x.r = nroots_a.r;\n          nroots_x.i = nroots_a.i;\n          nroots_a.r = nroots_b.r;\n          nroots_a.i = nroots_b.i;\n          nroots_b.r = nroots_x.r;\n          nroots_b.i = nroots_x.i;\n          nroots_x.r = nroots_fa.r;\n          nroots_x.i = nroots_fa.i;\n          nroots_fa.r = nroots_fb.r;\n          nroots_fa.i = nroots_fb.i;\n          nroots_fb.r = nroots_x.r;\n          nroots_fb.i = nroots_x.i;\n        }\n        // dx = nroots_b - nroots_a\n        nroots_dx.r = nroots_b.r - nroots_a.r;\n        nroots_dx.i = nroots_b.i - nroots_a.i;\n        // df = fb - fa\n        nroots_df.r = nroots_fb.r - nroots_fa.r;\n        nroots_df.i = nroots_fb.i - nroots_fa.i;\n        // y = dx / df\n        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;\n        if (t === 0.0) {\n          break;\n        }\n        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;\n        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;\n        // a = b - y * fb\n        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);\n        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);\n      }\n    }\n    return stop(\"nroots: convergence error\");\n  };\n\n  compute_fa = function(n) {\n    var i1, k, ref1, results, t;\n    k = 0;\n    t = 0.0;\n    // x = a\n    nroots_x.r = nroots_a.r;\n    nroots_x.i = nroots_a.i;\n    // fa = c0 + c1 * x\n    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;\n    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;\n    results = [];\n    for (k = i1 = 2, ref1 = n; (2 <= ref1 ? i1 < ref1 : i1 > ref1); k = 2 <= ref1 ? ++i1 : --i1) {\n      // x = a * x\n      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;\n      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;\n      nroots_x.r = t;\n      // fa += c[k] * x\n      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;\n      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);\n    }\n    return results;\n  };\n\n  // divide the polynomial by x - a\n  NROOTS_divpoly = function(n) {\n    var i1, j1, k, ref1, ref2, results;\n    k = 0;\n    for (k = i1 = ref1 = n - 1; (ref1 <= 0 ? i1 < 0 : i1 > 0); k = ref1 <= 0 ? ++i1 : --i1) {\n      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;\n      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;\n    }\n    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {\n      stop(\"nroots: residual error\");\n    }\n    results = [];\n    for (k = j1 = 0, ref2 = n - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      nroots_c[k].r = nroots_c[k + 1].r;\n      results.push(nroots_c[k].i = nroots_c[k + 1].i);\n    }\n    return results;\n  };\n\n  Eval_numerator = function() {\n    push(cadr(p1));\n    Eval();\n    return numerator();\n  };\n\n  numerator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      //console.trace \"rationalising \"\n      rationalize();\n      theArgument = pop();\n    }\n    //console.log \"rationalised: \" + theArgument\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      //console.log \"theArgument inside multiply: \" + theArgument\n      //console.log \"first term: \" + car(theArgument)\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        numerator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_numerator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      return push(one);\n    } else {\n      return push(theArgument);\n    }\n  };\n\n  // Outer product of tensors\n  Eval_outer = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      outer();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  outer = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1) && istensor(p2)) {\n      yyouter();\n    } else {\n      push(p1);\n      push(p2);\n      if (istensor(p1)) {\n        tensor_times_scalar();\n      } else if (istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        multiply();\n      }\n    }\n    return restore();\n  };\n\n  yyouter = function() {\n    var i, i1, j, j1, k, l1, m1, ndim, nelem, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    k = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"outer: rank of result exceeds maximum\");\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = i1 = 0, ref1 = p1.tensor.ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    j = i;\n    for (i = j1 = 0, ref2 = p2.tensor.ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      p3.tensor.dim[j + i] = p2.tensor.dim[i];\n    }\n    k = 0;\n    for (i = l1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      for (j = m1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2.tensor.elem[j]);\n        multiply();\n        p3.tensor.elem[k++] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  partition = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push_integer(1);\n    p3 = pop();\n    p4 = p3;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      if (Find(car(p1), p2)) {\n        push(p4);\n        push(car(p1));\n        multiply();\n        p4 = pop();\n      } else {\n        push(p3);\n        push(car(p1));\n        multiply();\n        p3 = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push(p3);\n    push(p4);\n    return restore();\n  };\n\n  /*\n    Add a pattern i.e. a substitution rule.\n    Substitution rule needs a template as first argument\n    and what to transform it to as second argument.\n    Optional third argument is a boolean test which\n    adds conditions to when the rule is applied.\n  */\n  // same as Eval_pattern but only leaves\n  // NIL on stack at return, hence gives no\n  // printout\n  Eval_silentpattern = function() {\n    Eval_pattern();\n    pop();\n    return push_symbol(NIL);\n  };\n\n  Eval_pattern = function() {\n    var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;\n    if (!iscons(cdr(p1))) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    firstArgument = car(cdr(p1));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    if (!iscons(cdr(cdr(p1)))) {\n      thirdArgument = symbol(NIL);\n    } else {\n      thirdArgument = car(cdr(cdr(cdr(p1))));\n    }\n    if (equal(firstArgument, secondArgument)) {\n      stop(\"recursive pattern\");\n    }\n    // console.log \"Eval_pattern of \" + cdr(p1)\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    stringKey = \"template: \" + print_list(firstArgument);\n    stringKey += \" tests: \" + print_list(thirdArgument);\n    if (DEBUG) {\n      console.log(\"pattern stringkey: \" + stringKey);\n    }\n    patternPosition = userSimplificationsInStringForm.indexOf(stringKey);\n    // if pattern is not there yet, add it, otherwise replace it\n    if (patternPosition === -1) {\n      //console.log \"adding pattern because it doesn't exist: \" + cdr(p1)\n      userSimplificationsInStringForm.push(stringKey);\n      userSimplificationsInListForm.push(cdr(p1));\n    } else {\n      if (DEBUG) {\n        console.log(\"pattern already exists, replacing. \" + cdr(p1));\n      }\n      userSimplificationsInStringForm[patternPosition] = stringKey;\n      userSimplificationsInListForm[patternPosition] = cdr(p1);\n    }\n    // return the pattern node itself so we can\n    // give some printout feedback\n    push_symbol(PATTERN);\n    push(cdr(p1));\n    return list(2);\n  };\n\n  do_clearPatterns = function() {\n    userSimplificationsInListForm = [];\n    return userSimplificationsInStringForm = [];\n  };\n\n  Eval_clearpatterns = function() {\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    do_clearPatterns();\n    \n    // return nothing\n    return push_symbol(NIL);\n  };\n\n  Eval_patternsinfo = function() {\n    var patternsinfoToBePrinted;\n    patternsinfoToBePrinted = patternsinfo();\n    if (patternsinfoToBePrinted !== \"\") {\n      return push(new_string(patternsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  patternsinfo = function() {\n    var i, i1, len, patternsinfoToBePrinted;\n    patternsinfoToBePrinted = \"\";\n    for (i1 = 0, len = userSimplificationsInListForm.length; i1 < len; i1++) {\n      i = userSimplificationsInListForm[i1];\n      patternsinfoToBePrinted += userSimplificationsInListForm + \"\\n\";\n    }\n    return patternsinfoToBePrinted;\n  };\n\n  Eval_polar = function() {\n    push(cadr(p1));\n    Eval();\n    return polar();\n  };\n\n  polar = function() {\n    // there are points where we turn polar\n    // representations into rect, we set a \"stack flag\"\n    // here to avoid that, so we don't undo the\n    // work that we are trying to do.\n    evaluatingPolar++;\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n    push(imaginaryunit);\n    push(p1);\n    arg();\n    multiply();\n    exponential();\n    multiply();\n    evaluatingPolar--;\n    return restore();\n  };\n\n  // Factor using the Pollard rho method\n  n_factor_number = 0;\n\n  factor_number = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    // 0 or 1?\n    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    n_factor_number = p1.q.a;\n    h = tos;\n    factor_a();\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      cons();\n    }\n    return restore();\n  };\n\n  // factor using table look-up, then switch to rho method if necessary\n\n  // From TAOCP Vol. 2 by Knuth, p. 380 (Algorithm A)\n  factor_a = function() {\n    var i1, k;\n    k = 0;\n    if (n_factor_number.isNegative()) {\n      n_factor_number = setSignTo(n_factor_number, 1);\n      push_integer(-1);\n    }\n    for (k = i1 = 0; i1 < 10000; k = ++i1) {\n      try_kth_prime(k);\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        return;\n      }\n    }\n    return factor_b();\n  };\n\n  try_kth_prime = function(k) {\n    var count, d, q, r;\n    count = 0;\n    d = mint(primetab[k]);\n    count = 0;\n    while (1) {\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        if (count) {\n          push_factor(d, count);\n        }\n        return;\n      }\n      [q, r] = mdivrem(n_factor_number, d);\n      // continue looping while remainder is zero\n      if (r.isZero()) {\n        count++;\n        n_factor_number = q;\n      } else {\n        break;\n      }\n    }\n    if (count) {\n      push_factor(d, count);\n    }\n    // q = n_factor_number/d, hence if q < d then\n    // n_factor_number < d^2 so n_factor_number is prime\n    if (mcmp(q, d) === -1) {\n      push_factor(n_factor_number, 1);\n      return n_factor_number = mint(1);\n    }\n  };\n\n  // From TAOCP Vol. 2 by Knuth, p. 385 (Algorithm B)\n  factor_b = function() {\n    var bigint_one, g, k, l, t, x, xprime;\n    k = 0;\n    l = 0;\n    bigint_one = mint(1);\n    x = mint(5);\n    xprime = mint(2);\n    k = 1;\n    l = 1;\n    while (1) {\n      if (mprime(n_factor_number)) {\n        push_factor(n_factor_number, 1);\n        return 0;\n      }\n      while (1) {\n        if (esc_flag) {\n          stop(\"esc\");\n        }\n        // g = gcd(x' - x, n_factor_number)\n        t = msub(xprime, x);\n        t = setSignTo(t, 1);\n        g = mgcd(t, n_factor_number);\n        if (MEQUAL(g, 1)) {\n          if (--k === 0) {\n            xprime = x;\n            l *= 2;\n            k = l;\n          }\n          // x = (x ^ 2 + 1) mod n_factor_number\n          t = mmul(x, x);\n          x = madd(t, bigint_one);\n          t = mmod(x, n_factor_number);\n          x = t;\n          continue;\n        }\n        push_factor(g, 1);\n        if (mcmp(g, n_factor_number) === 0) {\n          return -1;\n        }\n        // n_factor_number = n_factor_number / g\n        t = mdiv(n_factor_number, g);\n        n_factor_number = t;\n        // x = x mod n_factor_number\n        t = mmod(x, n_factor_number);\n        x = t;\n        // xprime = xprime mod n_factor_number\n        t = mmod(xprime, n_factor_number);\n        xprime = t;\n        break;\n      }\n    }\n  };\n\n  push_factor = function(d, count) {\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = d;\n    p1.q.b = mint(1);\n    push(p1);\n    if (count > 1) {\n      push_symbol(POWER);\n      swap();\n      p1 = new U();\n      p1.k = NUM;\n      p1.q.a = mint(count);\n      p1.q.b = mint(1);\n      push(p1);\n      return list(3);\n    }\n  };\n\n  DEBUG_POWER = false;\n\n  Eval_power = function() {\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return power();\n  };\n\n  power = function() {\n    save();\n    yypower();\n    return restore();\n  };\n\n  yypower = function() {\n    var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n;\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    n = 0;\n    p2 = pop(); // exponent\n    p1 = pop(); // base\n    inputExp = p2;\n    inputBase = p1;\n    //debugger\n    if (DEBUG_POWER) {\n      console.log(\"POWER: \" + p1 + \" ^ \" + p2);\n    }\n    // first, some very basic simplifications right away\n\n    //  1 ^ a    ->  1\n    //  a ^ 0    ->  1\n    if (equal(p1, one) || isZeroAtomOrTensor(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  a ^ 1    ->  a\n    if (equal(p2, one)) {\n      push(p1);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1    ->  -1\n    if (isminusone(p1) && isminusone(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ 1/2  ->  i\n    if (isminusone(p1) && (isoneovertwo(p2))) {\n      push(imaginaryunit);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1/2  ->  -i\n    if (isminusone(p1) && isminusoneovertwo(p2)) {\n      push(imaginaryunit);\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ rational\n    if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: -1 ^ rational\");\n      }\n      if (DEBUG_POWER) {\n        console.log(\" trick: p2.q.a , p2.q.b \" + p2.q.a + \" , \" + p2.q.b);\n      }\n      if (p2.q.a < p2.q.b) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n      } else {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push_symbol(POWER);\n        push(p1);\n        push_rational(p2.q.a.mod(p2.q.b), p2.q.b);\n        list(3);\n        list(3);\n        if (DEBUG_POWER) {\n          console.log(\" trick applied : \" + stack[tos - 1]);\n        }\n      }\n      // evaluates clock form into\n      // rectangular form. This seems to give\n      // slightly better form to some test results.\n      rect();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are rational numbers?\n    if (isrational(p1) && isrational(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: isrational(p1) && isrational(p2)\");\n      }\n      push(p1);\n      push(p2);\n      qpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are either rational or double?\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: both base and exponent are either rational or double \");\n      }\n      if (DEBUG_POWER) {\n        console.log(\"POWER - isNumericAtom(p1) && isNumericAtom(p2)\");\n      }\n      push(p1);\n      push(p2);\n      dpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    if (istensor(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: istensor(p1) \");\n      }\n      power_tensor();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // if we only assume variables to be real, then |a|^2 = a^2\n    // (if x is complex this doesn't hold e.g. i, which makes 1 and -1\n    if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: even power of absolute of real value \");\n      }\n      push(cadr(p1));\n      push(p2);\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^log(...)\n    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {\n      push(cadr(p2));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^some_float\n    if (p1 === symbol(E) && isdouble(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: p1 == symbol(E) && isdouble(p2) \");\n      }\n      push_double(Math.exp(p2.d));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number in exponential form, get it to rectangular\n    // but only if we are not in the process of calculating a polar form,\n    // otherwise we'd just undo the work we want to do\n    if (p1 === symbol(E) && Find(p2, imaginaryunit) !== 0 && Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      if (DEBUG_POWER) {\n        console.log(\"   power: turning complex exponential to rect: \" + stack[tos - 1]);\n      }\n      rect();\n      hopefullySimplified = pop();\n      if (Find(hopefullySimplified, symbol(PI)) === 0) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: turned complex exponential to rect: \" + hopefullySimplified);\n        }\n        push(hopefullySimplified);\n        return;\n      }\n    }\n    //  (a * b) ^ c  ->  (a ^ c) * (b ^ c)\n    // note that we can't in general do this, for example\n    // sqrt(x*y) != x^(1/2) y^(1/2) (counterexample\" x = -1 and y = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n    if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) \");\n      }\n      p1 = cdr(p1);\n      push(car(p1));\n      push(p2);\n      power();\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        power();\n        multiply();\n        p1 = cdr(p1);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // (a ^ b) ^ c  ->  a ^ (b * c)\n    // note that we can't in general do this, for example\n    // sqrt(x^y) !=  x^(1/2 y) (counterexample x = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n\n    // simple numeric check to see if a is a number > 0\n    is_a_moreThanZero = false;\n    if (isNumericAtom(cadr(p1))) {\n      is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));\n    }\n    if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) { // when a is >= 0\n      push(cadr(p1));\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    b_isEven_and_c_isItsInverse = false;\n    if (iseveninteger(caddr(p1))) {\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      isThisOne = pop();\n      if (isone(isThisOne)) {\n        b_isEven_and_c_isItsInverse = true;\n      }\n    }\n    if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse \");\n      }\n      push(cadr(p1));\n      abs();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  when expanding,\n    //  (a + b) ^ n  ->  (a + b) * (a + b) ...\n    if (expanding && isadd(p1) && isNumericAtom(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (n > 1 && !isNaN(n)) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: expanding && isadd(p1) && isNumericAtom(p2) \");\n        }\n        power_sum(n);\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    //  sin(x) ^ 2n -> (1 - cos(x) ^ 2) ^ n\n    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      cosine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  cos(x) ^ 2n -> (1 - sin(x) ^ 2) ^ n\n    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      sine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number? (just number, not expression)\n    if (iscomplexnumber(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\" power - handling the case (a + ib) ^ n\");\n      }\n      // integer power?\n\n      // n will be negative here, positive n already handled\n      if (isinteger(p2)) {\n        //               /        \\  n\n        //         -n   |  a - ib  |\n        // (a + ib)   = | -------- |\n        //              |   2   2  |\n        //               \\ a + b  /\n        push(p1);\n        conjugate();\n        p3 = pop();\n        push(p3);\n        // gets the denominator\n        push(p3);\n        push(p1);\n        multiply();\n        divide();\n        if (!isone(p2)) {\n          push(p2);\n          negate();\n          power();\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n      // noninteger or floating power?\n      if (isNumericAtom(p2)) {\n        push(p1);\n        abs();\n        push(p2);\n        power();\n        push_integer(-1);\n        push(p1);\n        arg();\n        push(p2);\n        multiply();\n        if (evaluatingAsFloats || (iscomplexnumberdouble(p1) && isdouble(p2))) {\n          // remember that the \"double\" type is\n          // toxic, i.e. it propagates, so we do\n          // need to evaluate PI to its actual double\n          // value\n          push_double(Math.PI);\n        } else {\n          //console.log(\"power pushing PI when p1 is: \" + p1 + \" and p2 is:\" + p2)\n          push(symbol(PI));\n        }\n        divide();\n        power();\n        multiply();\n        // if we calculate the power making use of arctan:\n        //  * it prevents nested radicals from being simplified\n        //  * results become really hard to manipulate afterwards\n        //  * we can't go back to other forms.\n        // so leave the power as it is.\n        if (avoidCalculatingPowersIntoArctans) {\n          if (Find(stack[tos - 1], symbol(ARCTAN))) {\n            pop();\n            push_symbol(POWER);\n            push(p1);\n            push(p2);\n            list(3);\n          }\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    \n    //push(p1)\n    //abs()\n    //push(p2)\n    //power()\n    //push(symbol(E))\n    //push(p1)\n    //arg()\n    //push(p2)\n    //multiply()\n    //push(imaginaryunit)\n    //multiply()\n    //power()\n    //multiply()\n\n    if (simplify_polar()) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: using simplify_polar\");\n      }\n      return;\n    }\n    if (DEBUG_POWER) {\n      console.log(\"   power: nothing can be done \");\n    }\n    push_symbol(POWER);\n    push(p1);\n    push(p2);\n    list(3);\n    if (DEBUG_POWER) {\n      return console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute the power of a sum\n\n  //  Input:    p1  sum\n\n  //      n  exponent\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses the multinomial series (see Math World)\n\n  //                          n              n!          n1   n2       nk\n  //  (a1 + a2 + ... + ak)  = sum (--------------- a1   a2   ... ak  )\n  //                               n1! n2! ... nk!\n\n  //  The sum is over all n1 ... nk such that n1 + n2 + ... + nk = n.\n\n  //-----------------------------------------------------------------------------\n\n  // first index is the term number 0..k-1, second index is the exponent 0..n\n\n  //define A(i, j) frame[(i) * (n + 1) + (j)]\n  power_sum = function(n) {\n    var a, i, i1, j, j1, k, l1, ref1, ref2, ref3;\n    a = [];\n    i = 0;\n    j = 0;\n    k = 0;\n    // number of terms in the sum\n    k = length(p1) - 1;\n    // local frame\n    push_frame(k * (n + 1));\n    // array of powers\n    p1 = cdr(p1);\n    for (i = i1 = 0, ref1 = k; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      for (j = j1 = 0, ref2 = n; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n        push(car(p1));\n        push_integer(j);\n        power();\n        stack[frame + i * (n + 1) + j] = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push_integer(n);\n    factorial();\n    p1 = pop();\n    for (i = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      a[i] = 0;\n    }\n    push(zero);\n    multinomial_sum(k, n, a, 0, n);\n    return pop_frame(k * (n + 1));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute multinomial sum\n\n  //  Input:    k  number of factors\n\n  //      n  overall exponent\n\n  //      a  partition array\n\n  //      i  partition array index\n\n  //      m  partition remainder\n\n  //      p1  n!\n\n  //      A  factor array\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses recursive descent to fill the partition array.\n\n  //-----------------------------------------------------------------------------\n\n  //int k, int n, int *a, int i, int m\n  multinomial_sum = function(k, n, a, i, m) {\n    var i1, j, j1, l1, ref1, ref2, ref3;\n    j = 0;\n    if (i < k - 1) {\n      for (j = i1 = 0, ref1 = m; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        a[i] = j;\n        multinomial_sum(k, n, a, i + 1, m - j);\n      }\n      return;\n    }\n    a[i] = m;\n    // coefficient\n    push(p1);\n    for (j = j1 = 0, ref2 = k; (0 <= ref2 ? j1 < ref2 : j1 > ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n      push_integer(a[j]);\n      factorial();\n      divide();\n    }\n// factors\n    for (j = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[frame + j * (n + 1) + a[j]]);\n      multiply();\n    }\n    return add();\n  };\n\n  // exp(n/2 i pi) ?\n\n  // p2 is the exponent expression\n\n  // clobbers p3\n  simplify_polar = function() {\n    var doNothing, n;\n    n = 0;\n    n = isquarterturn(p2);\n    switch (n) {\n      case 0:\n        doNothing = 1;\n        break;\n      case 1:\n        push_integer(1);\n        return 1;\n      case 2:\n        push_integer(-1);\n        return 1;\n      case 3:\n        push(imaginaryunit);\n        return 1;\n      case 4:\n        push(imaginaryunit);\n        negate();\n        return 1;\n    }\n    if (car(p2) === symbol(ADD)) {\n      p3 = cdr(p2);\n      while (iscons(p3)) {\n        n = isquarterturn(car(p3));\n        if (n) {\n          break;\n        }\n        p3 = cdr(p3);\n      }\n      switch (n) {\n        case 0:\n          return 0;\n        case 1:\n          push_integer(1);\n          break;\n        case 2:\n          push_integer(-1);\n          break;\n        case 3:\n          push(imaginaryunit);\n          break;\n        case 4:\n          push(imaginaryunit);\n          negate();\n      }\n      push(p2);\n      push(car(p3));\n      subtract();\n      exponential();\n      multiply();\n      return 1;\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Look up the nth prime\n\n  //  Input:    n on stack (0 < n < 10001)\n\n  //  Output:    nth prime on stack\n\n  //-----------------------------------------------------------------------------\n  Eval_prime = function() {\n    push(cadr(p1));\n    Eval();\n    return prime();\n  };\n\n  prime = function() {\n    var n;\n    n = 0;\n    n = pop_integer();\n    if (n < 1 || n > MAXPRIMETAB) {\n      stop(\"prime: Argument out of range.\");\n    }\n    n = primetab[n - 1];\n    return push_integer(n);\n  };\n\n  power_str = \"^\";\n\n  codeGen = false;\n\n  // this is only invoked when user invokes\n  // \"print\" explicitly\n  Eval_print = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"print2dascii\" explicitly\n  Eval_print2dascii = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printcomputer\" explicitly\n  Eval_printcomputer = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlatex\" explicitly\n  Eval_printlatex = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printhuman\" explicitly\n  Eval_printhuman = function() {\n    var original_test_flag;\n    // test flag needs to be suspended\n    // because otherwise \"printcomputer\" mode\n    // will happen.\n    original_test_flag = test_flag;\n    test_flag = 0;\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);\n    test_flag = original_test_flag;\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlist\" explicitly\n  Eval_printlist = function() {\n    var beenPrinted;\n    beenPrinted = _print(cdr(p1), PRINTMODE_LIST);\n    stringsEmittedByUserPrintouts += beenPrinted;\n    return push(symbol(NIL));\n  };\n\n  _print = function(p, passedPrintMode) {\n    var accumulator, origPrintMode;\n    accumulator = \"\";\n    while (iscons(p)) {\n      push(car(p));\n      Eval();\n      p2 = pop();\n      origPrintMode = printMode;\n      if (passedPrintMode === PRINTMODE_COMPUTER) {\n        printMode = PRINTMODE_COMPUTER;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_FULL_PRINT);\n      } else if (passedPrintMode === PRINTMODE_HUMAN) {\n        printMode = PRINTMODE_HUMAN;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_PLAIN_PRINT);\n      } else if (passedPrintMode === PRINTMODE_2DASCII) {\n        printMode = PRINTMODE_2DASCII;\n        accumulator = print2dascii(p2);\n        rememberPrint(accumulator, LAST_2DASCII_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LATEX) {\n        printMode = PRINTMODE_LATEX;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_LATEX_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LIST) {\n        printMode = PRINTMODE_LIST;\n        accumulator = print_list(p2);\n        rememberPrint(accumulator, LAST_LIST_PRINT);\n      }\n      printMode = origPrintMode;\n      p = cdr(p);\n    }\n    if (DEBUG) {\n      console.log(\"emttedString from display: \" + stringsEmittedByUserPrintouts);\n    }\n    return accumulator;\n  };\n\n  rememberPrint = function(theString, theTypeOfPrint) {\n    var parsedString;\n    scan('\"' + theString + '\"');\n    parsedString = pop();\n    return set_binding(symbol(theTypeOfPrint), parsedString);\n  };\n\n  print_str = function(s) {\n    if (DEBUG) {\n      console.log(\"emttedString from print_str: \" + stringsEmittedByUserPrintouts);\n    }\n    return s;\n  };\n\n  print_char = function(c) {\n    return c;\n  };\n\n  collectLatexStringFromReturnValue = function(p) {\n    var origPrintMode, originalCodeGen, returnedString;\n    origPrintMode = printMode;\n    printMode = PRINTMODE_LATEX;\n    originalCodeGen = codeGen;\n    codeGen = false;\n    returnedString = print_expr(p);\n    // some variables might contain underscores, escape those\n    returnedString = returnedString.replace(/_/g, \"\\\\_\");\n    printMode = origPrintMode;\n    codeGen = originalCodeGen;\n    if (DEBUG) {\n      console.log(\"emttedString from collectLatexStringFromReturnValue: \" + stringsEmittedByUserPrintouts);\n    }\n    return returnedString;\n  };\n\n  printline = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(p);\n    return accumulator;\n  };\n\n  print_base_of_denom = function(p1) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) { // p1 is BASE\n      accumulator += print_char('(');\n      accumulator += print_expr(p1);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p1); // p1 is BASE\n    }\n    return accumulator;\n  };\n\n  print_expo_of_denom = function(p2) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) { // p2 is EXPO\n      accumulator += print_char('(');\n      accumulator += print_expr(p2);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p2); // p2 is EXPO\n    }\n    return accumulator;\n  };\n\n  // prints stuff after the divide symbol \"/\"\n\n  // d is the number of denominators\n\n  //define BASE p1\n  //define EXPO p2\n  print_denom = function(p, d) {\n    var accumulator;\n    accumulator = \"\";\n    save();\n    p1 = cadr(p);\n    p2 = caddr(p);\n    if (isminusone(p2)) { // p2 is EXPO\n      accumulator += print_base_of_denom(p1);\n      restore();\n      return accumulator;\n    }\n    if (d === 1) { // p2 is EXPO\n      accumulator += print_char('(');\n    }\n    // prepare the exponent\n    // (needs to be negated)\n    // before printing it out\n    push(p2);\n    negate();\n    p2 = pop();\n    accumulator += print_power(p1, p2);\n    if (d === 1) {\n      accumulator += print_char(')');\n    }\n    restore();\n    return accumulator;\n  };\n\n  //define A p3\n  //define B p4\n  print_a_over_b = function(p) {\n    var accumulator, d, doNothing, n;\n    accumulator = \"\";\n    flag = 0;\n    n = 0;\n    d = 0;\n    save();\n    // count numerators and denominators\n    n = 0;\n    d = 0;\n    p1 = cdr(p);\n    p2 = car(p1);\n    if (isrational(p2)) {\n      push(p2);\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(p2);\n      mp_denominator();\n      p4 = pop();\n      if (!isplusone(p3)) { // p3 is A\n        n++;\n      }\n      if (!isplusone(p4)) { // p4 is B\n        d++;\n      }\n      p1 = cdr(p1);\n    } else {\n      p3 = one;\n      p4 = one; // p4 is B\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        d++;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    //debugger\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('\\\\frac{');\n    }\n    if (n === 0) {\n      accumulator += print_char('1');\n    } else {\n      flag = 0;\n      p1 = cdr(p);\n      if (isrational(car(p1))) {\n        p1 = cdr(p1);\n      }\n      if (!isplusone(p3)) { // p3 is A\n        accumulator += print_factor(p3);\n        flag = 1;\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (is_denominator(p2)) {\n          doNothing = 1;\n        } else {\n          if (flag) {\n            accumulator += print_multiply_sign();\n          }\n          accumulator += print_factor(p2);\n          flag = 1;\n        }\n        p1 = cdr(p1);\n      }\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}{');\n    } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n      accumulator += print_str(\" / \");\n    } else {\n      accumulator += print_str(\"/\");\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char('(');\n    }\n    flag = 0;\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    if (!isplusone(p4)) { // p4 is B\n      accumulator += print_factor(p4);\n      flag = 1;\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        if (flag) {\n          accumulator += print_multiply_sign();\n        }\n        accumulator += print_denom(p2, d);\n        flag = 1;\n      }\n      p1 = cdr(p1);\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char(')');\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}');\n    }\n    restore();\n    return accumulator;\n  };\n\n  print_expr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(p)) {\n      p = cdr(p);\n      if (sign_of_term(car(p)) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (sign_of_term(car(p)) === '+') {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" + \");\n          } else {\n            accumulator += print_str(\"+\");\n          }\n        } else {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" - \");\n          } else {\n            accumulator += print_str(\"-\");\n          }\n        }\n        accumulator += print_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (sign_of_term(p) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(p);\n    }\n    return accumulator;\n  };\n\n  sign_of_term = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && lessp(cadr(p), zero)) {\n      accumulator += '-';\n    } else if (isNumericAtom(p) && lessp(p, zero)) {\n      accumulator += '-';\n    } else {\n      accumulator += '+';\n    }\n    return accumulator;\n  };\n\n  print_term = function(p) {\n    var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {\n      accumulator += print_a_over_b(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      // coeff -1?\n      if (isminusone(car(p))) {\n        //      print_char('-')\n        p = cdr(p);\n      }\n      previousFactorWasANumber = false;\n      // print the first factor ------------\n      if (isNumericAtom(car(p))) {\n        previousFactorWasANumber = true;\n      }\n      // this numberOneOverSomething thing is so that\n      // we show things of the form\n      //   numericFractionOfForm1/something * somethingElse\n      // as\n      //   somethingElse / something\n      // so for example 1/2 * sqrt(2) is rendered as\n      //   sqrt(2)/2\n      // rather than the first form, which looks confusing.\n      // NOTE that you might want to avoid this\n      // when printing polynomials, as it could be nicer\n      // to show the numeric coefficients well separated from\n      // the variable, but we'll see when we'll\n      // come to it if it's an issue.\n      numberOneOverSomething = false;\n      if (printMode === PRINTMODE_LATEX && iscons(cdr(p)) && isNumberOneOverSomething(car(p))) {\n        numberOneOverSomething = true;\n        denom = car(p).q.b.toString();\n      }\n      if (numberOneOverSomething) {\n        origAccumulator = accumulator;\n        accumulator = \"\";\n      } else {\n        accumulator += print_factor(car(p));\n      }\n      p = cdr(p);\n      // print all the other factors -------\n      while (iscons(p)) {\n        // check if we end up having a case where two numbers\n        // are next to each other. In those cases, latex needs\n        // to insert a \\cdot otherwise they end up\n        // right next to each other and read like one big number\n        if (printMode === PRINTMODE_LATEX) {\n          if (previousFactorWasANumber) {\n            // if what comes next is a power and the base\n            // is a number, then we are in the case\n            // of consecutive numbers.\n            // Note that sqrt() i.e when exponent is 1/2\n            // doesn't count because the radical gives\n            // a nice graphical separation already.\n            if (caar(p) === symbol(POWER)) {\n              if (isNumericAtom(car(cdr(car(p))))) {\n                if (!isfraction(car(cdr(cdr(car(p)))))) {\n                  accumulator += \" \\\\cdot \";\n                }\n              }\n            }\n          }\n        }\n        accumulator += print_multiply_sign();\n        accumulator += print_factor(car(p), false, true);\n        previousFactorWasANumber = false;\n        if (isNumericAtom(car(p))) {\n          previousFactorWasANumber = true;\n        }\n        p = cdr(p);\n      }\n      if (numberOneOverSomething) {\n        accumulator = origAccumulator + \"\\\\frac{\" + accumulator + \"}{\" + denom + \"}\";\n      }\n    } else {\n      accumulator += print_factor(p);\n    }\n    return accumulator;\n  };\n\n  print_subexpr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_char('(');\n    accumulator += print_expr(p);\n    accumulator += print_char(')');\n    return accumulator;\n  };\n\n  print_factorial_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(p);\n    } else {\n      accumulator += print_expr(p);\n    }\n    accumulator += print_char('!');\n    return accumulator;\n  };\n\n  print_ABS_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\left |\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\right |\");\n    return accumulator;\n  };\n\n  print_BINOMIAL_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\binom{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"}{\");\n    accumulator += print_expr(caddr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_DOT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\cdot \");\n    accumulator += print_expr(caddr(p));\n    return accumulator;\n  };\n\n  print_DOT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"dot(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \", \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.sin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_COS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.cos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_TAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.tan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCSIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.asin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCCOS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.acos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCTAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.atan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SQRT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\sqrt{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^T\");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"transpose(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_UNIT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"identity(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_INV_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^{-1}\");\n    return accumulator;\n  };\n\n  print_INV_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"inv(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_DEFINT_latex = function(p) {\n    var accumulator, functionBody, i, i1, numberOfIntegrals, originalIntegral, ref1, theIntegral, theVariable;\n    accumulator = \"\";\n    functionBody = car(cdr(p));\n    p = cdr(p);\n    originalIntegral = p;\n    numberOfIntegrals = 0;\n    while (iscons(cdr(cdr(p)))) {\n      numberOfIntegrals++;\n      theIntegral = cdr(cdr(p));\n      accumulator += print_str(\"\\\\int^{\");\n      accumulator += print_expr(car(cdr(theIntegral)));\n      accumulator += print_str(\"}_{\");\n      accumulator += print_expr(car(theIntegral));\n      accumulator += print_str(\"} \\\\! \");\n      p = cdr(theIntegral);\n    }\n    accumulator += print_expr(functionBody);\n    accumulator += print_str(\" \\\\,\");\n    p = originalIntegral;\n    for (i = i1 = 1, ref1 = numberOfIntegrals; (1 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      theVariable = cdr(p);\n      accumulator += print_str(\" \\\\mathrm{d} \");\n      accumulator += print_expr(car(theVariable));\n      if (i < numberOfIntegrals) {\n        accumulator += print_str(\" \\\\, \");\n      }\n      p = cdr(cdr(theVariable));\n    }\n    return accumulator;\n  };\n\n  print_tensor = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_tensor_inner(p, 0, 0)[1];\n    return accumulator;\n  };\n\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner = function(p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    accumulator += print_str(\"[\");\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner(p, j + 1, k);\n        accumulator += retString;\n        // add separator between elements dimensions\n        // \"above\" the inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // add separator between elements in the\n        // inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n        k++;\n      }\n    }\n    accumulator += print_str(\"]\");\n    return [k, accumulator];\n  };\n\n  print_tensor_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (p.tensor.ndim <= 2) {\n      accumulator += print_tensor_inner_latex(true, p, 0, 0)[1];\n    }\n    return accumulator;\n  };\n\n  // firstLevel is needed because printing a matrix\n  // is not exactly an elegant recursive procedure:\n  // the vector on the first level prints the latex\n  // \"wrap\", while the vectors that make up the\n  // rows don't. so it's a bit asymmetric and this\n  // flag helps.\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner_latex = function(firstLevel, p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    // open the outer latex wrap\n    if (firstLevel) {\n      accumulator += \"\\\\begin{bmatrix} \";\n    }\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner_latex(0, p, j + 1, k);\n        accumulator += retString;\n        if (i !== p.tensor.dim[j] - 1) {\n          // add separator between rows\n          accumulator += print_str(\" \\\\\\\\ \");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // separator between elements in each row\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" & \");\n        }\n        k++;\n      }\n    }\n    // close the outer latex wrap\n    if (firstLevel) {\n      accumulator += \" \\\\end{bmatrix}\";\n    }\n    return [k, accumulator];\n  };\n\n  print_SUM_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\sum_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_SUM_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderSum = 0; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderSum += \" + print_expr(body) + \";\" + \" } \" + \" return holderSum;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_TEST_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\left\\\\{ \\\\begin{array}{ll}\";\n    p = cdr(p);\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"{\";\n        accumulator += print_expr(car(p));\n        accumulator += \"} & otherwise \";\n        accumulator += \" \\\\\\\\\\\\\\\\\";\n        break;\n      }\n      accumulator += \"{\";\n      accumulator += print_expr(cadr(p));\n      accumulator += \"} & if & \";\n      accumulator += print_expr(car(p));\n      accumulator += \" \\\\\\\\\\\\\\\\\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      p = cddr(p);\n    }\n    accumulator = accumulator.substring(0, accumulator.length - 4);\n    return accumulator += \"\\\\end{array} \\\\right.\";\n  };\n\n  print_TEST_codegen = function(p) {\n    var accumulator, howManyIfs;\n    accumulator = \"(function(){\";\n    p = cdr(p);\n    howManyIfs = 0;\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"else {\";\n        accumulator += \"return (\" + print_expr(car(p)) + \");\";\n        accumulator += \"}\";\n        break;\n      }\n      if (howManyIfs) {\n        accumulator += \" else \";\n      }\n      accumulator += \"if (\" + print_expr(car(p)) + \"){\";\n      accumulator += \"return (\" + print_expr(cadr(p)) + \");\";\n      accumulator += \"}\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      howManyIfs++;\n      p = cddr(p);\n    }\n    accumulator += \"})()\";\n    return accumulator;\n  };\n\n  print_TESTLT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" < \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTLE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\leq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" > \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\geq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTEQ_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" = \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_FOR_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   \" + print_expr(body) + \" } \" + \"})()\";\n    return accumulator;\n  };\n\n  print_DO_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    while (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n    }\n    return accumulator;\n  };\n\n  print_SETQ_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \" = \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"; \";\n    return accumulator;\n  };\n\n  print_PRODUCT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\prod_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_PRODUCT_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderProduct = 1; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderProduct *= \" + print_expr(body) + \";\" + \" } \" + \" return holderProduct;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_base = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(cadr(p));\n      accumulator += print_str(')');\n    } else if (isNumericAtom(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {\n      accumulator += print_str('(');\n      accumulator += print_factor(cadr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(cadr(p));\n    }\n    return accumulator;\n  };\n\n  print_exponent = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isNumericAtom(caddr(p)) && lessp(caddr(p), zero))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(caddr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(caddr(p));\n    }\n    return accumulator;\n  };\n\n  print_power = function(base, exponent) {\n    var accumulator, denomExponent, newExponent, numExponent;\n    accumulator = \"\";\n    //debugger\n    if (DEBUG) {\n      console.log(\"power base: \" + base + \" \" + \" exponent: \" + exponent);\n    }\n    // quick check is this is actually a square root.\n    if (isoneovertwo(exponent)) {\n      if (equaln(base, 2)) {\n        if (codeGen) {\n          accumulator += print_str(\"Math.SQRT2\");\n          return accumulator;\n        }\n      } else {\n        if (printMode === PRINTMODE_LATEX) {\n          accumulator += print_str(\"\\\\sqrt{\");\n          accumulator += print_expr(base);\n          accumulator += print_str(\"}\");\n          return accumulator;\n        } else if (codeGen) {\n          accumulator += print_str(\"Math.sqrt(\");\n          accumulator += print_expr(base);\n          accumulator += print_str(')');\n          return accumulator;\n        }\n      }\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1)) && base === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.exp(\");\n        accumulator += print_expo_of_denom(exponent);\n        accumulator += print_str(')');\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"e^{\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(\"}\");\n      } else {\n        accumulator += print_str(\"exp(\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (codeGen) {\n      accumulator += print_str(\"Math.pow(\");\n      accumulator += print_base_of_denom(base);\n      accumulator += print_str(\", \");\n      accumulator += print_expo_of_denom(exponent);\n      accumulator += print_str(')');\n      return accumulator;\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0)) || base.printname !== \"x\") {\n      // if the exponent is negative then\n      // we invert the base BUT we don't do\n      // that if the base is \"e\", because for\n      // example when trigonometric functions are\n      // expressed in terms of exponential functions\n      // that would be really confusing, one wants to\n      // keep \"e\" as the base and the negative exponent\n      if (base !== symbol(E)) {\n        if (isminusone(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_expr(base);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_expr(base);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n        if (isnegativeterm(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          push(exponent);\n          push_integer(-1);\n          multiply();\n          newExponent = pop();\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_power(base, newExponent);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_power(base, newExponent);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n      }\n      if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\sqrt\");\n        push(exponent);\n        denominator();\n        denomExponent = pop();\n        if (!isplustwo(denomExponent)) {\n          accumulator += print_str(\"[\");\n          accumulator += print_expr(denomExponent);\n          accumulator += print_str(\"]\");\n        }\n        accumulator += print_str(\"{\");\n        push(exponent);\n        numerator();\n        numExponent = pop();\n        exponent = numExponent;\n        accumulator += print_power(base, exponent);\n        accumulator += print_str(\"}\");\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {\n      // if we are in latex mode we turn many\n      // radicals into a radix sign with a power\n      // underneath, and the power is often one\n      // (e.g. square root turns into a radical\n      // with a power one underneath) so handle\n      // this case simply here, just print the base\n      accumulator += print_expr(base);\n    } else {\n      // print the base,\n      // determining if it needs to be\n      // wrapped in parentheses or not\n      if (isadd(base) || isnegativenumber(base)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(base);\n        accumulator += print_str(')');\n      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str('(');\n        }\n        accumulator += print_factor(base, true);\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str(')');\n        }\n      } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {\n        accumulator += print_str('(');\n        accumulator += print_factor(base);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(base);\n      }\n      // print the power symbol\n      //debugger\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        //print_str(\" ^ \")\n        accumulator += print_str(power_str);\n      } else {\n        accumulator += print_str(\"^\");\n      }\n      // print the exponent\n      if (printMode === PRINTMODE_LATEX) {\n        // in latex mode, one can omit the curly braces\n        // wrapping the exponent if the exponent is only\n        // one character long\n        if (print_expr(exponent).length > 1) {\n          accumulator += print_str(\"{\");\n          accumulator += print_expr(exponent);\n          accumulator += print_str(\"}\");\n        } else {\n          accumulator += print_expr(exponent);\n        }\n      } else if (iscons(exponent) || isfraction(exponent) || (isNumericAtom(exponent) && lessp(exponent, zero))) {\n        accumulator += print_str('(');\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(exponent);\n      }\n    }\n    return accumulator;\n  };\n\n  print_index_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(car(p));\n    } else {\n      accumulator += print_expr(car(p));\n    }\n    accumulator += print_str('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        accumulator += print_str(',');\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    accumulator += print_str(']');\n    return accumulator;\n  };\n\n  print_factor = function(p, omitParens, pastFirstFactor) {\n    var accumulator, base, exponent, fbody, parameters, returned;\n    // debugger\n    accumulator = \"\";\n    if (isNumericAtom(p)) {\n      // in an evaluated term, all the numeric parts\n      // are at the beginning of the term.\n      // When printing the EXPRESSION,\n      // we peek into the first factor of the term and we\n      // look at whether it's a number less then zero.\n      // if it is, we print the \"-\" as the \"leading\" part of the\n      // print of the EXPRESSION, and then we proceed printint the factors\n      // of the term. This means that when we come here, we must\n      // skip printing the minus if the number is negative,\n      // because it's already been printed.\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += '(';\n      }\n      accumulator += print_number(p, pastFirstFactor);\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += ')';\n      }\n      return accumulator;\n    }\n    if (isstr(p)) {\n      accumulator += print_str(\"\\\"\");\n      accumulator += print_str(p.str);\n      accumulator += print_str(\"\\\"\");\n      return accumulator;\n    }\n    if (istensor(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_tensor_latex(p);\n      } else {\n        accumulator += print_tensor(p);\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\left (\");\n          } else {\n            accumulator += print_str('(');\n          }\n        }\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\right ) \");\n          } else {\n            accumulator += print_str(')');\n          }\n        }\n      }\n      return accumulator;\n    } else if (isadd(p)) {\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(POWER)) {\n      base = cadr(p);\n      exponent = caddr(p);\n      accumulator += print_power(base, exponent);\n      return accumulator;\n    }\n    //  if (car(p) == _list) {\n    //    print_str(\"{\")\n    //    p = cdr(p)\n    //    if (iscons(p)) {\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    while (iscons(p)) {\n    //      print_str(\",\")\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    print_str(\"}\")\n    //    return\n    //  }\n    if (car(p) === symbol(FUNCTION)) {\n      fbody = cadr(p);\n      if (!codeGen) {\n        parameters = caddr(p);\n        accumulator += print_str(\"function \");\n        if (DEBUG) {\n          console.log(\"emittedString from print_factor \" + stringsEmittedByUserPrintouts);\n        }\n        returned = print_list(parameters);\n        accumulator += returned;\n        accumulator += print_str(\" -> \");\n      }\n      accumulator += print_expr(fbody);\n      return accumulator;\n    }\n    if (car(p) === symbol(PATTERN)) {\n      accumulator += print_expr(caadr(p));\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\" \\\\rightarrow \");\n      } else {\n        if (printMode === PRINTMODE_HUMAN && !test_flag) {\n          accumulator += print_str(\" -> \");\n        } else {\n          accumulator += print_str(\"->\");\n        }\n      }\n      accumulator += print_expr(car(cdr(cadr(p))));\n      return accumulator;\n    }\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      accumulator += print_index_function(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      accumulator += print_factorial_function(p);\n      return accumulator;\n    } else if (car(p) === symbol(ABS) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_ABS_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {\n      //debugger\n      accumulator += print_SQRT_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(TRANSPOSE)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TRANSPOSE_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_TRANSPOSE_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(UNIT)) {\n      if (codeGen) {\n        accumulator += print_UNIT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(INV)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_INV_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_INV_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_BINOMIAL_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_DEFINT_latex(p);\n      return accumulator;\n    } else if (isinnerordot(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_DOT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_DOT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SIN)) {\n      if (codeGen) {\n        accumulator += print_SIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(COS)) {\n      if (codeGen) {\n        accumulator += print_COS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TAN)) {\n      if (codeGen) {\n        accumulator += print_TAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCSIN)) {\n      if (codeGen) {\n        accumulator += print_ARCSIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCCOS)) {\n      if (codeGen) {\n        accumulator += print_ARCCOS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCTAN)) {\n      if (codeGen) {\n        accumulator += print_ARCTAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SUM)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_SUM_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_SUM_codegen(p);\n        return accumulator;\n      }\n    //else if car(p) == symbol(QUOTE)\n    //  if printMode == PRINTMODE_LATEX\n    //    print_expr(cadr(p))\n    //    return accumulator\n    } else if (car(p) === symbol(PRODUCT)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_PRODUCT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_PRODUCT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FOR)) {\n      if (codeGen) {\n        accumulator += print_FOR_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(DO)) {\n      if (codeGen) {\n        accumulator += print_DO_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TEST)) {\n      if (codeGen) {\n        accumulator += print_TEST_codegen(p);\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TEST_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") < (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") <= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") > (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") >= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTEQ)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") === (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTEQ_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FLOOR)) {\n      if (codeGen) {\n        accumulator += \"Math.floor(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lfloor {\" + print_expr(cadr(p)) + \"} \\\\rfloor \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(CEILING)) {\n      if (codeGen) {\n        accumulator += \"Math.ceiling(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lceil {\" + print_expr(cadr(p)) + \"} \\\\rceil \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ROUND)) {\n      if (codeGen) {\n        accumulator += \"Math.round(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SETQ)) {\n      if (codeGen) {\n        accumulator += print_SETQ_codegen(p);\n        return accumulator;\n      } else {\n        accumulator += print_expr(cadr(p));\n        accumulator += print_str(\"=\");\n        accumulator += print_expr(caddr(p));\n        return accumulator;\n      }\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p)->k == SYM) {\n      //  print_str(((struct symbol *) cadr(p))->name)\n      //  return\n      //}\n      accumulator += print_factor(car(p));\n      p = cdr(p);\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      if (iscons(p)) {\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += print_str(\",\");\n          accumulator += print_expr(car(p));\n          p = cdr(p);\n        }\n      }\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (p === symbol(DERIVATIVE)) {\n      accumulator += print_char('d');\n    } else if (p === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.E\");\n      } else {\n        accumulator += print_str(\"e\");\n      }\n    } else if (p === symbol(PI)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\pi\");\n      } else {\n        accumulator += print_str(\"pi\");\n      }\n    } else {\n      accumulator += print_str(get_printname(p));\n    }\n    return accumulator;\n  };\n\n  print_list = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    switch (p.k) {\n      case CONS:\n        accumulator += '(';\n        accumulator += print_list(car(p));\n        if (p === cdr(p) && p !== symbol(NIL)) {\n          console.log(\"oh no recursive!\");\n          debugger;\n        }\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += \" \";\n          accumulator += print_list(car(p));\n          p = cdr(p);\n          if (p === cdr(p) && p !== symbol(NIL)) {\n            console.log(\"oh no recursive!\");\n            debugger;\n          }\n        }\n        if (p !== symbol(NIL)) {\n          accumulator += \" . \";\n          accumulator += print_list(p);\n        }\n        accumulator += ')';\n        break;\n      case STR:\n        //print_str(\"\\\"\")\n        accumulator += p.str;\n        break;\n      //print_str(\"\\\"\")\n      case NUM:\n      case DOUBLE:\n        accumulator += print_number(p, true);\n        break;\n      case SYM:\n        accumulator += get_printname(p);\n        break;\n      default:\n        accumulator += \"<tensor>\";\n    }\n    return accumulator;\n  };\n\n  print_multiply_sign = function() {\n    var accumulator;\n    accumulator = \"\";\n    if (printMode === PRINTMODE_LATEX) {\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(\" \");\n      } else {\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {\n      accumulator += print_str(\" \");\n    } else {\n      accumulator += print_str(\"*\");\n    }\n    return accumulator;\n  };\n\n  is_denominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // don't consider the leading fraction\n  // we want 2/3*a*b*c instead of 2*a*b*c/3\n  any_denominators = function(p) {\n    var q;\n    p = cdr(p);\n    //  if (isfraction(car(p)))\n    //    return 1\n    while (iscons(p)) {\n      q = car(p);\n      if (is_denominator(q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  /*\n\n  Prints in \"2d\", e.g. instead of 1/(x+1)^2 :\n\n        1\n   ----------\n           2\n    (1 + x)\n\n   Note that although this looks more natural, a) it's not parsable and\n   b) it can be occasionally be ambiguous, such as:\n\n     1\n   ----\n     2\n   x\n\n  is 1/x^2 but it also looks a little like x^(1/2)\n\n  */\n  //-----------------------------------------------------------------------------\n\n  //  Examples:\n\n  //     012345678\n  //  -2 .........\n  //  -1 .........\n  //   0 ..hello..  x=2, y=0, h=1, w=5\n  //   1 .........\n  //   2 .........\n\n  //     012345678\n  //  -2 .........\n  //  -1 ..355....\n  //   0 ..---....  x=2, y=-1, h=3, w=3\n  //   1 ..113....\n  //   2 .........\n\n  //-----------------------------------------------------------------------------\n  YMAX = 10000;\n\n  glyph = (function() {\n    class glyph {};\n\n    glyph.prototype.c = 0;\n\n    glyph.prototype.x = 0;\n\n    glyph.prototype.y = 0;\n\n    return glyph;\n\n  }).call(this);\n\n  // will contain glyphs\n  chartab = [];\n\n  for (charTabIndex = i1 = 0, ref1 = YMAX; (0 <= ref1 ? i1 < ref1 : i1 > ref1); charTabIndex = 0 <= ref1 ? ++i1 : --i1) {\n    chartab[charTabIndex] = new glyph();\n  }\n\n  yindex = 0;\n\n  level = 0;\n\n  emit_x = 0;\n\n  expr_level = 0;\n\n  display_flag = 0;\n\n  // this is not really the translated version,\n  // the original is in window.cpp and is\n  // rather more complex\n  printchar_nowrap = function(character) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += character;\n    return accumulator;\n  };\n\n  printchar = function(character) {\n    return printchar_nowrap(character);\n  };\n\n  print2dascii = function(p) {\n    var beenPrinted, h, w, y;\n    h = 0;\n    w = 0;\n    y = 0;\n    save();\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_top_expr(p);\n    // if too wide then print flat\n    [h, w, y] = get_size(0, yindex);\n    if (w > 100) {\n      printline(p);\n      restore();\n      return;\n    }\n    beenPrinted = print_glyphs();\n    restore();\n    return beenPrinted;\n  };\n\n  emit_top_expr = function(p) {\n    if (car(p) === symbol(SETQ)) {\n      emit_expr(cadr(p));\n      __emit_str(\" = \");\n      emit_expr(caddr(p));\n      return;\n    }\n    if (istensor(p)) {\n      return emit_tensor(p);\n    } else {\n      return emit_expr(p);\n    }\n  };\n\n  will_be_displayed_as_fraction = function(p) {\n    if (level > 0) {\n      return 0;\n    }\n    if (isfraction(p)) {\n      return 1;\n    }\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (isfraction(cadr(p))) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  emit_expr = function(p) {\n    //  if (level > 0) {\n    //    printexpr(p)\n    //    return\n    //  }\n    expr_level++;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      if (__is_negative(car(p))) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(car(p))) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (__is_negative(p)) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(p)) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(p);\n    }\n    return expr_level--;\n  };\n\n  emit_unsigned_expr = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      //    if (__is_negative(car(p)))\n      //      __emit_char('-')\n      emit_term(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      //    if (__is_negative(p))\n      //      __emit_char('-')\n      return emit_term(p);\n    }\n  };\n\n  __is_negative = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    }\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_term = function(p) {\n    var n;\n    if (car(p) === symbol(MULTIPLY)) {\n      n = count_denominators(p);\n      if (n && level === 0) {\n        return emit_fraction(p, n);\n      } else {\n        return emit_multiply(p, n);\n      }\n    } else {\n      return emit_factor(p);\n    }\n  };\n\n  isdenominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  count_denominators = function(p) {\n    var count, q;\n    count = 0;\n    p = cdr(p);\n    //  if (isfraction(car(p))) {\n    //    count++\n    //    p = cdr(p)\n    //  }\n    while (iscons(p)) {\n      q = car(p);\n      if (isdenominator(q)) {\n        count++;\n      }\n      p = cdr(p);\n    }\n    return count;\n  };\n\n  // n is the number of denominators, not counting a fraction like 1/2\n  emit_multiply = function(p, n) {\n    var results;\n    if (n === 0) {\n      p = cdr(p);\n      if (isplusone(car(p)) || isminusone(car(p))) {\n        p = cdr(p);\n      }\n      emit_factor(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        __emit_char(' ');\n        emit_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      emit_numerators(p);\n      __emit_char('/');\n      // need grouping if more than one denominator\n      if (n > 1 || isfraction(cadr(p))) {\n        __emit_char('(');\n        emit_denominators(p);\n        return __emit_char(')');\n      } else {\n        return emit_denominators(p);\n      }\n    }\n  };\n\n  //define A p3\n  //define B p4\n\n  // sign of term has already been emitted\n  emit_fraction = function(p, d) {\n    var count, doNothing, k1, k2, n, x;\n    count = 0;\n    k1 = 0;\n    k2 = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = one;\n    p4 = one;\n    if (isrational(cadr(p))) {\n      push(cadr(p));\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(cadr(p));\n      mp_denominator();\n      p4 = pop(); // p4 is B\n    }\n    if (isdouble(cadr(p))) {\n      push(cadr(p));\n      absval();\n      p3 = pop(); // p3 is A\n    }\n    \n    // count numerators\n    if (isplusone(p3)) { // p3 is A\n      n = 0;\n    } else {\n      n = 1;\n    }\n    p1 = cdr(p);\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    // emit numerators\n    x = emit_x;\n    k1 = yindex;\n    count = 0;\n    if (!isplusone(p3)) { // p3 is A\n      emit_number(p3, 0);\n      count++;\n    }\n    // skip over \"multiply\"\n    p1 = cdr(p);\n    // skip over numerical coefficient, already handled\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        if (n === 1) {\n          emit_expr(p2);\n        } else {\n          emit_factor(p2);\n        }\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    if (count === 0) {\n      __emit_char('1');\n    }\n    // emit denominators\n    k2 = yindex;\n    count = 0;\n    if (!isplusone(p4)) { // p4 is B\n      emit_number(p4, 0);\n      count++;\n      d++;\n    }\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(p2, d);\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_numerators = function(p) {\n    var doNothing, n;\n    save();\n    n = 0;\n    p1 = one;\n    p = cdr(p);\n    if (isrational(car(p))) {\n      push(car(p));\n      mp_numerator();\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    } else if (isdouble(car(p))) {\n      push(car(p));\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    }\n    n = 0;\n    if (!isplusone(p1)) {\n      emit_number(p1, 0);\n      n++;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        doNothing = 1;\n      } else {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_factor(car(p));\n        n++;\n      }\n      p = cdr(p);\n    }\n    if (n === 0) {\n      __emit_char('1');\n    }\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_denominators = function(p) {\n    var n;\n    save();\n    n = 0;\n    p = cdr(p);\n    if (isfraction(car(p))) {\n      push(car(p));\n      mp_denominator();\n      p1 = pop();\n      emit_number(p1, 0);\n      n++;\n      p = cdr(p);\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(car(p), 0);\n        n++;\n      }\n      p = cdr(p);\n    }\n    return restore();\n  };\n\n  emit_factor = function(p) {\n    if (istensor(p)) {\n      if (level === 0) {\n        //emit_tensor(p)\n        emit_flat_tensor(p);\n      } else {\n        emit_flat_tensor(p);\n      }\n      return;\n    }\n    if (isdouble(p)) {\n      emit_number(p, 0);\n      return;\n    }\n    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {\n      emit_subexpr(p);\n      return;\n    }\n    if (car(p) === symbol(POWER)) {\n      emit_power(p);\n      return;\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p).k == SYM)\n      //  emit_symbol(cadr(p))\n      //else\n      emit_function(p);\n      return;\n    }\n    if (isNumericAtom(p)) {\n      if (level === 0) {\n        emit_numerical_fraction(p);\n      } else {\n        emit_number(p, 0);\n      }\n      return;\n    }\n    if (issymbol(p)) {\n      emit_symbol(p);\n      return;\n    }\n    if (isstr(p)) {\n      emit_string(p);\n    }\n  };\n\n  emit_numerical_fraction = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    save();\n    push(p);\n    mp_numerator();\n    absval();\n    p3 = pop();\n    push(p);\n    mp_denominator();\n    p4 = pop();\n    if (isplusone(p4)) { // p4 is B\n      emit_number(p3, 0);\n      restore();\n      return;\n    }\n    x = emit_x;\n    k1 = yindex;\n    emit_number(p3, 0);\n    k2 = yindex;\n    emit_number(p4, 0); // p4 is B\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // if it's a factor then it doesn't need parens around it, i.e. 1/sin(theta)^2\n  isfactor = function(p) {\n    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {\n      return 1;\n    }\n    if (issymbol(p)) {\n      return 1;\n    }\n    if (isfraction(p)) {\n      return 0;\n    }\n    if (isnegativenumber(p)) {\n      return 0;\n    }\n    if (isNumericAtom(p)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_power = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    if (cadr(p) === symbol(E)) {\n      __emit_str(\"exp(\");\n      emit_expr(caddr(p));\n      __emit_char(')');\n      return;\n    }\n    if (level > 0) {\n      if (isminusone(caddr(p))) {\n        __emit_char('1');\n        __emit_char('/');\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n      } else {\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n        __emit_char('^');\n        if (isfactor(caddr(p))) {\n          emit_factor(caddr(p));\n        } else {\n          emit_subexpr(caddr(p));\n        }\n      }\n      return;\n    }\n    // special case: 1 over something\n    if (__is_negative(caddr(p))) {\n      x = emit_x;\n      k1 = yindex;\n      __emit_char('1');\n      k2 = yindex;\n      //level++\n      emit_denominator(p, 1);\n      //level--\n      fixup_fraction(x, k1, k2);\n      return;\n    }\n    k1 = yindex;\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    level++;\n    emit_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  // if n == 1 then emit as expr (no parens)\n\n  // p is a power\n  emit_denominator = function(p, n) {\n    var k1, k2;\n    k1 = 0;\n    k2 = 0;\n    // special case: 1 over something\n    if (isminusone(caddr(p))) {\n      if (n === 1) {\n        emit_expr(cadr(p));\n      } else {\n        emit_factor(cadr(p));\n      }\n      return;\n    }\n    k1 = yindex;\n    // emit base\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    // emit exponent, don't emit minus sign\n    level++;\n    emit_unsigned_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_function = function(p) {\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      emit_index_function(p);\n      return;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      emit_factorial_function(p);\n      return;\n    }\n    if (car(p) === symbol(DERIVATIVE)) {\n      __emit_char('d');\n    } else {\n      emit_symbol(car(p));\n    }\n    __emit_char('(');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        //__emit_char(' ')\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(')');\n  };\n\n  emit_index_function = function(p) {\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      emit_subexpr(car(p));\n    } else {\n      emit_expr(car(p));\n    }\n    __emit_char('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(']');\n  };\n\n  emit_factorial_function = function(p) {\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      emit_subexpr(p);\n    } else {\n      emit_expr(p);\n    }\n    return __emit_char('!');\n  };\n\n  emit_subexpr = function(p) {\n    __emit_char('(');\n    emit_expr(p);\n    return __emit_char(')');\n  };\n\n  emit_symbol = function(p) {\n    var i, j1, pPrintName, ref2, results;\n    i = 0;\n    if (p === symbol(E)) {\n      __emit_str(\"exp(1)\");\n      return;\n    }\n    pPrintName = get_printname(p);\n    results = [];\n    for (i = j1 = 0, ref2 = pPrintName.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(pPrintName[i]));\n    }\n    return results;\n  };\n\n  emit_string = function(p) {\n    var i, j1, pString, ref2;\n    i = 0;\n    pString = p.str;\n    __emit_char('\"');\n    for (i = j1 = 0, ref2 = pString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      __emit_char(pString[i]);\n    }\n    return __emit_char('\"');\n  };\n\n  fixup_fraction = function(x, k1, k2) {\n    var dx, dy, h1, h2, i, j1, ref2, results, w, w1, w2, y, y1, y2;\n    dx = 0;\n    dy = 0;\n    i = 0;\n    w = 0;\n    y = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    if (w2 > w1) {\n      dx = (w2 - w1) / 2; // shift numerator right\n    } else {\n      dx = 0;\n    }\n    dx++;\n    // this is how much is below the baseline\n    y = y1 + h1 - 1;\n    dy = -y - 1;\n    move(k1, k2, dx, dy);\n    if (w2 > w1) {\n      dx = -w1;\n    } else {\n      dx = -w1 + (w1 - w2) / 2;\n    }\n    dx++;\n    dy = -y2 + 1;\n    move(k2, yindex, dx, dy);\n    if (w2 > w1) {\n      w = w2;\n    } else {\n      w = w1;\n    }\n    w += 2;\n    emit_x = x;\n    results = [];\n    for (i = j1 = 0, ref2 = w; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char('-'));\n    }\n    return results;\n  };\n\n  fixup_power = function(k1, k2) {\n    var dy, h1, h2, w1, w2, y1, y2;\n    dy = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    // move superscript to baseline\n    dy = -y2 - h2 + 1;\n    // now move above base\n    dy += y1 - 1;\n    return move(k2, yindex, 0, dy);\n  };\n\n  move = function(j, k, dx, dy) {\n    var i, j1, ref2, ref3, results;\n    i = 0;\n    results = [];\n    for (i = j1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      chartab[i].x += dx;\n      results.push(chartab[i].y += dy);\n    }\n    return results;\n  };\n\n  // finds the bounding rectangle and vertical position\n  get_size = function(j, k) {\n    var h, i, j1, max_x, max_y, min_x, min_y, ref2, ref3, w, y;\n    i = 0;\n    min_x = chartab[j].x;\n    max_x = chartab[j].x;\n    min_y = chartab[j].y;\n    max_y = chartab[j].y;\n    for (i = j1 = ref2 = j + 1, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      if (chartab[i].x < min_x) {\n        min_x = chartab[i].x;\n      }\n      if (chartab[i].x > max_x) {\n        max_x = chartab[i].x;\n      }\n      if (chartab[i].y < min_y) {\n        min_y = chartab[i].y;\n      }\n      if (chartab[i].y > max_y) {\n        max_y = chartab[i].y;\n      }\n    }\n    h = max_y - min_y + 1;\n    w = max_x - min_x + 1;\n    y = min_y;\n    return [h, w, y];\n  };\n\n  displaychar = function(c) {\n    return __emit_char(c);\n  };\n\n  __emit_char = function(c) {\n    if (yindex === YMAX) {\n      return;\n    }\n    if (chartab[yindex] == null) {\n      debugger;\n    }\n    chartab[yindex].c = c;\n    chartab[yindex].x = emit_x;\n    chartab[yindex].y = 0;\n    yindex++;\n    return emit_x++;\n  };\n\n  __emit_str = function(s) {\n    var i, j1, ref2, results;\n    i = 0;\n    results = [];\n    for (i = j1 = 0, ref2 = s.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(s[i]));\n    }\n    return results;\n  };\n\n  emit_number = function(p, emit_sign) {\n    var i, j1, l1, m1, ref2, ref3, ref4, results, results1, tmpString;\n    tmpString = \"\";\n    i = 0;\n    switch (p.k) {\n      case NUM:\n        tmpString = p.q.a.toString();\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        for (i = j1 = 0, ref2 = tmpString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n          __emit_char(tmpString[i]);\n        }\n        tmpString = p.q.b.toString();\n        if (tmpString === \"1\") {\n          break;\n        }\n        __emit_char('/');\n        results = [];\n        for (i = l1 = 0, ref3 = tmpString.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n          results.push(__emit_char(tmpString[i]));\n        }\n        return results;\n        break;\n      case DOUBLE:\n        tmpString = doubleToReasonableString(p.d);\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        results1 = [];\n        for (i = m1 = 0, ref4 = tmpString.length; (0 <= ref4 ? m1 < ref4 : m1 > ref4); i = 0 <= ref4 ? ++m1 : --m1) {\n          results1.push(__emit_char(tmpString[i]));\n        }\n        return results1;\n    }\n  };\n\n  // a and b are glyphs\n  cmpGlyphs = function(a, b) {\n    if (a.y < b.y) {\n      return -1;\n    }\n    if (a.y > b.y) {\n      return 1;\n    }\n    if (a.x < b.x) {\n      return -1;\n    }\n    if (a.x > b.x) {\n      return 1;\n    }\n    return 0;\n  };\n\n  print_glyphs = function() {\n    var accumulator, i, j1, ref2, subsetOfStack, x, y;\n    i = 0;\n    accumulator = \"\";\n    \n    // now sort the glyphs by their vertical positions,\n    // since we are going to build a string where obviously the\n    // \"upper\" line has to printed out first, followed by\n    // a new line, followed by the other lines.\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        accumulator += printchar('\\n');\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        accumulator += printchar_nowrap(' ');\n        x++;\n      }\n      accumulator += printchar_nowrap(chartab[i].c);\n      x++;\n    }\n    return accumulator;\n  };\n\n  buffer = \"\";\n\n  getdisplaystr = function() {\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_expr(pop());\n    fill_buf();\n    return buffer;\n  };\n\n  fill_buf = function() {\n    var i, j1, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;\n    tmpBuffer = buffer;\n    sIndex = 0;\n    i = 0;\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        tmpBuffer[sIndex++] = '\\n';\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        tmpBuffer[sIndex++] = ' ';\n        x++;\n      }\n      tmpBuffer[sIndex++] = chartab[i].c;\n      x++;\n    }\n    return tmpBuffer[sIndex++] = '\\n';\n  };\n\n  N = 100;\n\n  oneElement = (function() {\n    class oneElement {};\n\n    oneElement.prototype.x = 0;\n\n    oneElement.prototype.y = 0;\n\n    oneElement.prototype.h = 0;\n\n    oneElement.prototype.w = 0;\n\n    oneElement.prototype.index = 0;\n\n    oneElement.prototype.count = 0;\n\n    return oneElement;\n\n  }).call(this);\n\n  elem = [];\n\n  for (elelmIndex = j1 = 0; j1 < 10000; elelmIndex = ++j1) {\n    elem[elelmIndex] = new oneElement();\n  }\n\n  SPACE_BETWEEN_COLUMNS = 3;\n\n  SPACE_BETWEEN_ROWS = 1;\n\n  emit_tensor = function(p) {\n    var col, dx, dy, eh, ew, h, i, l1, m1, n, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, row, w, x, y;\n    i = 0;\n    n = 0;\n    nrow = 0;\n    ncol = 0;\n    x = 0;\n    y = 0;\n    h = 0;\n    w = 0;\n    dx = 0;\n    dy = 0;\n    eh = 0;\n    ew = 0;\n    row = 0;\n    col = 0;\n    if (p.tensor.ndim > 2) {\n      emit_flat_tensor(p);\n      return;\n    }\n    nrow = p.tensor.dim[0];\n    if (p.tensor.ndim === 2) {\n      ncol = p.tensor.dim[1];\n    } else {\n      ncol = 1;\n    }\n    n = nrow * ncol;\n    if (n > N) {\n      emit_flat_tensor(p);\n      return;\n    }\n    // horizontal coordinate of the matrix\n\n    //if 0\n    //emit_x += 2; # make space for left paren\n    //endif\n    x = emit_x;\n// emit each element\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      elem[i].index = yindex;\n      elem[i].x = emit_x;\n      emit_expr(p.tensor.elem[i]);\n      elem[i].count = yindex - elem[i].index;\n      [elem[i].h, elem[i].w, elem[i].y] = get_size(elem[i].index, yindex);\n    }\n    // find element height and width\n    eh = 0;\n    ew = 0;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (elem[i].h > eh) {\n        eh = elem[i].h;\n      }\n      if (elem[i].w > ew) {\n        ew = elem[i].w;\n      }\n    }\n    // this is the overall height of the matrix\n    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;\n    // this is the overall width of the matrix\n    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;\n    // this is the vertical coordinate of the matrix\n    y = -(h / 2);\n// move elements around\n    for (row = n1 = 0, ref4 = nrow; (0 <= ref4 ? n1 < ref4 : n1 > ref4); row = 0 <= ref4 ? ++n1 : --n1) {\n      for (col = o1 = 0, ref5 = ncol; (0 <= ref5 ? o1 < ref5 : o1 > ref5); col = 0 <= ref5 ? ++o1 : --o1) {\n        i = row * ncol + col;\n        // first move to upper left corner of matrix\n        dx = x - elem[i].x;\n        dy = y - elem[i].y;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n        // now move to official position\n        dx = 0;\n        if (col > 0) {\n          dx = col * (ew + SPACE_BETWEEN_COLUMNS);\n        }\n        dy = 0;\n        if (row > 0) {\n          dy = row * (eh + SPACE_BETWEEN_ROWS);\n        }\n        // small correction for horizontal centering\n        dx += (ew - elem[i].w) / 2;\n        // small correction for vertical centering\n        dy += (eh - elem[i].h) / 2;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n      }\n    }\n    return emit_x = x + w;\n  };\n\n  emit_flat_tensor = function(p) {\n    return emit_tensor_inner(p, 0, 0);\n  };\n\n  emit_tensor_inner = function(p, j, k) {\n    var i, l1, ref2;\n    i = 0;\n    __emit_char('(');\n    for (i = l1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (j + 1 === p.tensor.ndim) {\n        emit_expr(p.tensor.elem[k]);\n        k = k + 1;\n      } else {\n        k = emit_tensor_inner(p, j + 1, k);\n      }\n      if (i + 1 < p.tensor.dim[j]) {\n        __emit_char(',');\n      }\n    }\n    __emit_char(')');\n    return k;\n  };\n\n  // 'product' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the product at the top of the stack\n  Eval_product = function() {\n    var body, i, indexVariable, j, k, l1, oldIndexVariableValue, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    oldIndexVariableValue = get_binding(indexVariable);\n    push_integer(1);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      if (DEBUG) {\n        console.log(\"product - factor 1: \" + stack[tos - 1].toString());\n        console.log(\"product - factor 2: \" + stack[tos - 2].toString());\n      }\n      multiply();\n      if (DEBUG) {\n        console.log(\"product - result: \" + stack[tos - 1].toString());\n      }\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, oldIndexVariableValue);\n  };\n\n  //  Add rational numbers\n\n  //  Input:    tos-2    addend\n\n  //      tos-1    addend\n\n  //  Output:    sum on stack\n  qadd = function() {\n    var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;\n    // a, qadd_ab, b, qadd_ba, c are all bigNum\n    // we are adding the fractions qadd_frac1 + qadd_frac2 i.e.\n    // qadd_frac1.q.a/qadd_frac1.q.b + qadd_frac2.q.a/qadd_frac2.q.b\n    qadd_frac2 = pop();\n    qadd_frac1 = pop();\n    qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);\n    qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);\n    qadd_numerator = madd(qadd_ab, qadd_ba);\n    //mfree(qadd_ab)\n    //mfree(qadd_ba)\n\n    // zero?\n    if (MZERO(qadd_numerator)) {\n      //console.log \"qadd IS ZERO\"\n      //mfree(qadd_numerator)\n      push(zero);\n      return;\n    }\n    qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);\n    gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);\n    //console.log \"gcd(\"+qadd_numerator+\",\"+qadd_denominator+\"): \" + gcdBetweenNumeratorAndDenominator\n    gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);\n    //console.log \"qadd qadd_denominator: \" + qadd_denominator\n    //console.log \"qadd gcdBetweenNumeratorAndDenominator: \" + gcdBetweenNumeratorAndDenominator\n    resultSum = new U();\n    resultSum.k = NUM;\n    resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);\n    resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);\n    //console.log \"qadd resultSum.q.a: \" + resultSum.q.a\n    //console.log \"qadd resultSum.q.b: \" + resultSum.q.b\n\n    //mfree(qadd_numerator)\n    //mfree(qadd_denominator)\n    //mfree(gcdBetweenNumeratorAndDenominator)\n    return push(resultSum);\n  };\n\n  //console.log \"qadd result: \" + resultSum\n\n  //  Divide rational numbers\n\n  //  Input:    tos-2    dividend\n\n  //      tos-1    divisor\n\n  //  Output:    quotient on stack\n  qdiv = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p2.q.a)) {\n      stop(\"divide by zero\");\n    }\n    if (MZERO(p1.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.b);\n    bb = mmul(p1.q.b, p2.q.a);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  //  Multiply rational numbers\n\n  //  Input:    tos-2    multiplicand\n\n  //      tos-1    multiplier\n\n  //  Output:    product on stack\n  qmul = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.a);\n    bb = mmul(p1.q.b, p2.q.b);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    //mfree(aa)\n    //mfree(bb)\n    push(p1);\n    return restore();\n  };\n\n  // Rational power function\n  qpow = function() {\n    save();\n    qpowf();\n    return restore();\n  };\n\n  //define BASE p1\n  //define EXPO p2\n  qpowf = function() {\n    var a, b, expo, t, x, y;\n    expo = 0;\n    //unsigned int a, b, *t, *x, *y\n    p2 = pop();\n    p1 = pop();\n    if (isplusone(p1) || isZeroAtomOrTensor(p2)) { // p1 is BASE  # p2 is EXPO\n      push_integer(1);\n      return;\n    }\n    // if (-1)^(1/2) -> leave it as is\n    if (isminusone(p1) && isoneovertwo(p2)) { // p1 is BASE  # p2 is EXPO\n      push(imaginaryunit);\n      return;\n    }\n    // if base is zero then return 0\n    if (isZeroAtomOrTensor(p1)) { // p1 is BASE\n      if (isnegativenumber(p2)) { // p2 is EXPO\n        stop(\"divide by zero\");\n      }\n      push(zero);\n      return;\n    }\n    // if exponent is 1 then return base\n    if (isplusone(p2)) { // p2 is EXPO\n      push(p1);\n      return;\n    }\n    // if exponent is integer then power\n    if (isinteger(p2)) { // p2 is EXPO\n      push(p2);\n      expo = pop_integer();\n      if (isNaN(expo)) {\n        // expo greater than 32 bits\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n        return;\n      }\n      x = mpow(p1.q.a, Math.abs(expo));\n      y = mpow(p1.q.b, Math.abs(expo));\n      if (expo < 0) {\n        t = x;\n        x = y;\n        y = t;\n        x = makeSignSameAs(x, y);\n        y = makePositive(y);\n      }\n      p3 = new U();\n      p3.k = NUM;\n      p3.q.a = x;\n      p3.q.b = y;\n      push(p3);\n      return;\n    }\n    // from here on out the exponent is NOT an integer\n\n    // if base is -1 then normalize polar angle\n    if (isminusone(p1)) { // p1 is BASE\n      push(p2);\n      normalize_angle();\n      return;\n    }\n    // if base is negative then (-N)^M -> N^M * (-1)^M\n    if (isnegativenumber(p1)) { // p1 is BASE\n      push(p1);\n      negate();\n      push(p2);\n      qpow();\n      push_integer(-1);\n      push(p2);\n      qpow();\n      multiply();\n      return;\n    }\n    if (!isinteger(p1)) { // p1 is BASE\n      push(p1);\n      mp_numerator();\n      push(p2);\n      qpow();\n      push(p1);\n      mp_denominator();\n      push(p2);\n      negate();\n      qpow();\n      multiply();\n      return;\n    }\n    // At this point p1 (BASE) is a positive integer.\n\n    // If p1 (BASE) is small then factor it.\n    if (is_small_integer(p1)) { // p1 is BASE\n      push(p1);\n      push(p2);\n      quickfactor();\n      return;\n    }\n    if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) { // p2 is EXPO\n      push_symbol(POWER);\n      push(p1); // p1 is BASE\n      push(p2);\n      list(3);\n      return;\n    }\n    a = p2.q.a;\n    b = p2.q.b;\n    x = mroot(p1.q.a, b);\n    if (x === 0) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    y = mpow(x, a);\n    //mfree(x)\n    p3 = new U();\n    p3.k = NUM;\n    if (p2.q.a.isNegative()) { // p2 is EXPO\n      p3.q.a = bigInt(1);\n      p3.q.b = y;\n    } else {\n      p3.q.a = y;\n      p3.q.b = bigInt(1);\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize the angle of unit imaginary, i.e. (-1) ^ N\n\n  //  Input:    N on stack (must be rational, not float)\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  n = q * d + r\n\n  //  Example:\n  //            n  d  q  r\n\n  //  (-1)^(8/3)  ->   (-1)^(2/3)  8  3  2  2\n  //  (-1)^(7/3)  ->   (-1)^(1/3)  7  3  2  1\n  //  (-1)^(5/3)  ->  -(-1)^(2/3)  5  3  1  2\n  //  (-1)^(4/3)  ->  -(-1)^(1/3)  4  3  1  1\n  //  (-1)^(2/3)  ->   (-1)^(2/3)  2  3  0  2\n  //  (-1)^(1/3)  ->   (-1)^(1/3)  1  3  0  1\n\n  //  (-1)^(-1/3)  ->  -(-1)^(2/3)  -1  3  -1  2\n  //  (-1)^(-2/3)  ->  -(-1)^(1/3)  -2  3  -1  1\n  //  (-1)^(-4/3)  ->   (-1)^(2/3)  -4  3  -2  2\n  //  (-1)^(-5/3)  ->   (-1)^(1/3)  -5  3  -2  1\n  //  (-1)^(-7/3)  ->  -(-1)^(2/3)  -7  3  -3  2\n  //  (-1)^(-8/3)  ->  -(-1)^(1/3)  -8  3  -3  1\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define Q p2\n  //define R p3\n  normalize_angle = function() {\n    save();\n    p1 = pop();\n    if (isinteger(p1)) { // p1 is A\n      if (p1.q.a.isOdd()) { // p1 is A\n        push_integer(-1); // odd exponent\n      } else {\n        push_integer(1); // even exponent\n      }\n      restore();\n      return;\n    }\n    // floor\n    push(p1);\n    bignum_truncate();\n    p2 = pop();\n    if (isnegativenumber(p1)) { // p1 is A\n      push(p2); // p2 is Q\n      push_integer(-1);\n      add();\n      p2 = pop(); // p2 is Q\n    }\n    \n    // remainder (always positive)\n    push(p1);\n    push(p2);\n    subtract();\n    p3 = pop();\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p3); // p3 is R\n    list(3);\n    // negate if quotient is odd\n    if (p2.q.a.isOdd()) { // p2 is Q\n      negate();\n    }\n    return restore();\n  };\n\n  is_small_integer = function(p) {\n    return isSmall(p.q.a);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor small numerical powers\n\n  //  Input:    tos-2    Base (positive integer < 2^31 - 1)\n\n  //      tos-1    Exponent\n\n  //  Output:    Expr on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define BASE p1\n  //define EXPO p2\n  quickfactor = function() {\n    var h, i, l1, n, ref2, stackIndex;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push(p1);\n    factor_small_number();\n    n = tos - h;\n    stackIndex = h;\n    for (i = l1 = 0, ref2 = n; l1 < ref2; i = l1 += 2) {\n      push(stack[stackIndex + i]);\n      push(stack[stackIndex + i + 1]);\n      push(p2);\n      multiply();\n      quickpower();\n    }\n    // stack has n results from factor_number_raw()\n\n    // on top of that are all the expressions from quickpower()\n\n    // multiply the quickpower() results\n    multiply_all(tos - h - n);\n    p1 = pop();\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  // p1 (BASE) is a prime number so power is simpler\n  quickpower = function() {\n    var expo;\n    expo = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    bignum_truncate();\n    p3 = pop();\n    push(p2);\n    push(p3);\n    subtract();\n    p4 = pop();\n    if (!isZeroAtomOrTensor(p4)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p4);\n      list(3);\n    }\n    push(p3);\n    expo = pop_integer();\n    if (isNaN(expo)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p3);\n      list(3);\n      restore();\n      return;\n    }\n    if (expo === 0) {\n      restore();\n      return;\n    }\n    push(p1);\n    bignum_power_number(expo);\n    return restore();\n  };\n\n  //if SELFTEST\n\n  // Divide polynomials\n  Eval_quotient = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      p1 = symbol(SYMBOL_X);\n    }\n    push(p1);\n    return divpoly();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide polynomials\n\n  //  Input:    tos-3    Dividend\n\n  //      tos-2    Divisor\n\n  //      tos-1    x\n\n  //  Output:    tos-1    Quotient\n\n  //-----------------------------------------------------------------------------\n\n  //define DIVIDEND p1\n  //define DIVISOR p2\n  //define X p3\n  //define Q p4\n  //define QUOTIENT p5\n  divpoly = function() {\n    var dividend, divisor, h, i, l1, m, n, ref2, x;\n    h = 0;\n    i = 0;\n    m = 0;\n    n = 0;\n    x = 0;\n    //U **dividend, **divisor\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    dividend = tos;\n    m = coeff(p3, p1) - 1;\n    divisor = tos;\n    n = coeff(p3, p2) - 1;\n    x = m - n;\n    push_integer(0);\n    p5 = pop();\n    while (x >= 0) {\n      push(stack[dividend + m]);\n      push(stack[divisor + n]);\n      divide();\n      p4 = pop();\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        push(stack[dividend + x + i]);\n        push(stack[divisor + i]);\n        push(p4);\n        multiply();\n        subtract();\n        stack[dividend + x + i] = pop();\n      }\n      push(p5);\n      push(p4);\n      push(p3);\n      push_integer(x);\n      power();\n      multiply();\n      add();\n      p5 = pop();\n      m--;\n      x--;\n    }\n    moveTos(h);\n    push(p5);\n    return restore();\n  };\n\n  DEBUG_RATIONALIZE = false;\n\n  Eval_rationalize = function() {\n    push(cadr(p1));\n    Eval();\n    return rationalize();\n  };\n\n  rationalize = function() {\n    var x;\n    x = expanding;\n    yyrationalize();\n    return expanding = x;\n  };\n\n  yyrationalize = function() {\n    var commonDenominator, eachTerm, theArgument;\n    theArgument = pop();\n    if (istensor(theArgument)) {\n      __rationalize_tensor(theArgument);\n      return;\n    }\n    expanding = 0;\n    if (car(theArgument) !== symbol(ADD)) {\n      push(theArgument);\n      return;\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the input expr: \" + theArgument);\n    }\n    // get new denominator\n    push(one);\n    multiply_denominators(theArgument);\n    commonDenominator = pop();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the new denominator: \" + commonDenominator);\n    }\n    // multiply each term by new denominator\n    push(zero);\n    eachTerm = cdr(theArgument);\n    while (iscons(eachTerm)) {\n      if (DEBUG_RATIONALIZE) {\n        console.log(\"term: \" + car(eachTerm));\n      }\n      push(commonDenominator);\n      push(car(eachTerm));\n      multiply();\n      add();\n      eachTerm = cdr(eachTerm);\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: original terms times new denominator: \" + stack[tos - 1]);\n    }\n    // collect common factors\n    Condense();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: after factoring: \" + stack[tos - 1]);\n    }\n    // divide by common denominator\n    push(commonDenominator);\n    divide();\n    if (DEBUG_RATIONALIZE) {\n      return console.log(\"rationalize: after dividing by new denom. (and we're done): \" + stack[tos - 1]);\n    }\n  };\n\n  multiply_denominators = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_term(p);\n    }\n  };\n\n  multiply_denominators_term = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_factor(p);\n    }\n  };\n\n  multiply_denominators_factor = function(p) {\n    if (car(p) !== symbol(POWER)) {\n      return;\n    }\n    push(p);\n    p = caddr(p);\n    // like x^(-2) ?\n    if (isnegativenumber(p)) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // like x^(-a) ?\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // no match\n    return pop();\n  };\n\n  __rationalize_tensor = function(theTensor) {\n    var i, l1, n, ref2;\n    i = 0;\n    push(theTensor);\n    Eval();\n    theTensor = pop();\n    if (!istensor(theTensor)) { // might be zero\n      push(theTensor);\n      return;\n    }\n    n = theTensor.tensor.nelem;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(theTensor.tensor.elem[i]);\n      rationalize();\n      theTensor.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(theTensor);\n    return push(theTensor);\n  };\n\n  __lcm = function() {\n    save();\n    p1 = pop();\n    p2 = pop();\n    push(p1);\n    push(p2);\n    multiply();\n    push(p1);\n    push(p2);\n    gcd();\n    divide();\n    return restore();\n  };\n\n  Eval_real = function() {\n    push(cadr(p1));\n    Eval();\n    return real();\n  };\n\n  real = function() {\n    save();\n    rect();\n    p1 = pop();\n    push(p1);\n    push(p1);\n    conjugate();\n    add();\n    push_integer(2);\n    divide();\n    return restore();\n  };\n\n  DEBUG_RECT = false;\n\n  Eval_rect = function() {\n    push(cadr(p1));\n    Eval();\n    return rect();\n  };\n\n  rect = function() {\n    var input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_RECT) {\n      console.log(\"RECT of \" + input);\n    }\n    if (DEBUG_RECT) {\n      console.log(\"any clock forms in : \" + input + \" ? \" + findPossibleClockForm(input));\n    }\n    // if we assume real variables, then the\n    // rect of any symbol is the symbol itself\n    // (note that 'i' is not a symbol, it's made of (-1)^(1/2))\n    // otherwise we have to leave unevalled\n    if (issymbol(p1)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push(p1);\n      } else {\n        push_symbol(YYRECT);\n        push(p1);\n        list(2);\n      }\n    } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !findPossibleExponentialForm(p1) && !findPossibleClockForm(p1) && !(Find(p1, symbol(SIN)) && Find(p1, symbol(COS)) && Find(p1, imaginaryunit))) { // no polar form?\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      push(p1);\n    // ib\n    } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      push(p1);\n    // sum\n    } else if (car(p1) === symbol(ADD)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is a sum \");\n      }\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        rect();\n        add();\n        p1 = cdr(p1);\n      }\n    } else {\n      // try to get to the rectangular form by doing\n      // abs(p1) * (cos (theta) + i * sin(theta))\n      // where theta is arg(p1)\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is NOT a sum \");\n      }\n      push(p1);\n      abs();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" abs: \" + stack[tos - 1].toString());\n      }\n      push(p1);\n      arg();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" arg of \" + p1 + \" : \" + stack[tos - 1].toString());\n      }\n      p1 = pop();\n      push(p1);\n      cosine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cosine: \" + stack[tos - 1].toString());\n      }\n      push(imaginaryunit);\n      push(p1);\n      sine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" i * sine: \" + stack[tos - 1].toString());\n      }\n      add();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cos + i * sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n    }\n    restore();\n    if (DEBUG_RECT) {\n      return console.log(\"rect of \" + input + \" : \" + stack[tos - 1]);\n    }\n  };\n\n  //define POLY p1\n  //define X p2\n  //define A p3\n  //define B p4\n  //define C p5\n  //define Y p6\n  show_power_debug = false;\n\n  performing_roots = false;\n\n  Eval_roots = function() {\n    // this transforms simple \"equation\" forms into\n    // something that can be processed. E.g., say, y = 3x - 2\n    // A == B -> A - B\n    // A = B -> A - B\n    p2 = cadr(p1);\n    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n      push(cadr(p2));\n      Eval();\n      push(caddr(p2));\n      Eval();\n      subtract();\n    } else {\n      push(p2);\n      Eval();\n      p2 = pop();\n      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n        push(cadr(p2));\n        Eval();\n        push(caddr(p2));\n        Eval();\n        subtract();\n      } else {\n        push(p2);\n      }\n    }\n    // 2nd arg, x\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"roots: 1st argument is not a polynomial in the variable \" + p2);\n    }\n    push(p1);\n    push(p2);\n    return roots();\n  };\n\n  hasImaginaryCoeff = function(k) {\n    var h, i, imaginaryCoefficients, l1, ref2;\n    //polycoeff = tos\n    imaginaryCoefficients = false;\n    h = tos;\n    for (i = l1 = ref2 = k; l1 > 0; i = l1 += -1) {\n      //console.log \"hasImaginaryCoeff - coeff.:\" + stack[tos-i].toString()\n      if (iscomplexnumber(stack[tos - i])) {\n        imaginaryCoefficients = true;\n        break;\n      }\n    }\n    return imaginaryCoefficients;\n  };\n\n  isSimpleRoot = function(k) {\n    var h, i, isSimpleRootPolynomial, l1, ref2;\n    //polycoeff = tos\n\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    if (k > 2) {\n      isSimpleRootPolynomial = true;\n      h = tos;\n      if (isZeroAtomOrTensor(stack[tos - k])) {\n        isSimpleRootPolynomial = false;\n      }\n      for (i = l1 = ref2 = k - 1; l1 > 1; i = l1 += -1) {\n        if (!isZeroAtomOrTensor(stack[tos - i])) {\n          isSimpleRootPolynomial = false;\n          break;\n        }\n      }\n    } else {\n      isSimpleRootPolynomial = false;\n    }\n    return isSimpleRootPolynomial;\n  };\n\n  normalisedCoeff = function(variable, polynomial) {\n    var divideBy, i, k, l1, m1, miniStack, ref2, ref3;\n    k = coeff(variable, polynomial);\n    //console.log(\"->\" + tos)\n    divideBy = stack[tos - 1];\n    miniStack = [];\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      miniStack.push(pop());\n    }\n//console.log(tos)\n    for (i = m1 = ref3 = k - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); i = ref3 <= 0 ? ++m1 : --m1) {\n      push(miniStack[i]);\n      push(divideBy);\n      divide();\n    }\n    //console.log(tos)\n    return k;\n  };\n\n  // takes the polynomial and the\n  // variable on the stack\n  roots = function() {\n    var h, i, k, l1, lastCoeff, leadingCoeff, n, ref2;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (DEBUG) {\n      console.log(\"roots: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    // the simplification of nested radicals uses\n    // \"roots\", which in turn uses simplification\n    // of nested radicals. Usually there is no problem,\n    // one level of recursion does the job. Beyond that,\n    // we probably got stuck in a strange case of infinite\n    // recursion, so bail out and return NIL.\n    if (recursionLevelNestedRadicalsRemoval > 1) {\n      pop();\n      pop();\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    performing_roots = true;\n    h = tos - 2;\n    if (DEBUG) {\n      console.log(\"roots checking if \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n    }\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (isSimpleRoot(k)) {\n      if (DEBUG) {\n        console.log(\"yes, \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n      }\n      lastCoeff = stack[tos - k];\n      leadingCoeff = stack[tos - 1];\n      moveTos(tos - k);\n      pop();\n      pop();\n      getSimpleRoots(k, leadingCoeff, lastCoeff);\n    } else {\n      moveTos(tos - k);\n      roots2();\n    }\n    n = tos - h;\n    if (n === 0) {\n      stop(\"roots: the polynomial is not factorable, try nroots\");\n    }\n    if (n === 1) {\n      performing_roots = false;\n      restore();\n      return;\n    }\n    sort_stack(n);\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    restore();\n    return performing_roots = false;\n  };\n\n  // ok to generate these roots take a look at their form\n  // in the case of even and odd exponents here:\n  // http://www.wolframalpha.com/input/?i=roots+x%5E14+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+ax%5E14+%2B+b\n  // http://www.wolframalpha.com/input/?i=roots+x%5E15+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+a*x%5E15+%2B+b\n  getSimpleRoots = function(n, leadingCoeff, lastCoeff) {\n    var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;\n    if (DEBUG) {\n      console.log(\"getSimpleRoots\");\n    }\n    save();\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    n = n - 1;\n    push(lastCoeff);\n    push_rational(1, n);\n    power();\n    push(leadingCoeff);\n    push_rational(1, n);\n    power();\n    divide();\n    commonPart = pop();\n    if (n % 2 === 0) {\n      for (rootsOfOne = l1 = 1, ref2 = n; l1 <= ref2; rootsOfOne = l1 += 2) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        aSol = pop();\n        push(aSol);\n        push(aSol);\n        negate();\n      }\n    } else {\n      for (rootsOfOne = m1 = 1, ref3 = n; (1 <= ref3 ? m1 <= ref3 : m1 >= ref3); rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        if (rootsOfOne % 2 === 0) {\n          negate();\n        }\n      }\n    }\n    return restore();\n  };\n\n  roots2 = function() {\n    var k;\n    save();\n    if (DEBUG) {\n      console.log(\"roots2: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    p2 = pop(); // the polynomial variable\n    p1 = pop(); // the polynomial\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (!hasImaginaryCoeff(k)) {\n      moveTos(tos - k);\n      factorpoly();\n      p1 = pop();\n    } else {\n      moveTos(tos - k);\n      pop();\n      pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      // scan through all the factors\n      // and find the roots of each of them\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        roots3();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      roots3();\n    }\n    return restore();\n  };\n\n  roots3 = function() {\n    var n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {\n      n = normalisedCoeff(p2, cadr(p1));\n      mini_solve(n);\n    } else if (ispolyexpandedform(p1, p2)) {\n      n = normalisedCoeff(p2, p1);\n      mini_solve(n);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    stack[tos - 2]    polynomial\n\n  //      stack[tos - 1]    dependent symbol\n\n  //  Output:    stack      roots on stack\n\n  //            (input args are popped first)\n\n  //-----------------------------------------------------------------------------\n\n  // note that for many quadratic, cubic and quartic polynomials we don't\n  // actually end up using the quadratic/cubic/quartic formulas in here,\n  // since there is a chance we factored the polynomial and in so\n  // doing we found some solutions and lowered the degree.\n  mini_solve = function(n) {\n    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;\n    //console.log \"mini_solve >>>>>>>>>>>>>>>>>>>>>>>> tos:\" + tos\n    save();\n    // AX + B, X = -B/A\n    if (n === 2) {\n      //console.log \"mini_solve >>>>>>>>> 1st degree\"\n      p3 = pop();\n      p4 = pop();\n      push(p4);\n      push(p3);\n      divide();\n      negate();\n      restore();\n      return;\n    }\n    // AX^2 + BX + C, X = (-B +/- (B^2 - 4AC)^(1/2)) / (2A)\n    if (n === 3) {\n      //console.log \"mini_solve >>>>>>>>> 2nd degree\"\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      \n      // B^2\n      push(p4);\n      push_integer(2);\n      power();\n      // 4AC\n      push_integer(4);\n      push(p3);\n      multiply();\n      push(p5);\n      multiply();\n      // B^2 - 4AC\n      subtract();\n      //(B^2 - 4AC)^(1/2)\n      push_rational(1, 2);\n      power();\n      //p6 is (B^2 - 4AC)^(1/2)\n      p6 = pop();\n      push(p6);\n      push(p4);\n      subtract(); // -B + (B^2 - 4AC)^(1/2)\n      \n      // 1/2A\n      push(p3);\n      push_integer(2);\n      multiply();\n      divide();\n      //simplify()\n      //rationalize()\n      // tos - 1 now is 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      push(p6);\n      push(p4);\n      add();\n      // tos - 1 now is  B + (B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      negate();\n      // tos - 1 now is  -B -(B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n\n      // 1/2A again\n      push(p3);\n      divide();\n      push_rational(1, 2);\n      multiply();\n      //simplify()\n      //rationalize()\n      // tos - 1: 2nd root: (-B - (B^2 - 4AC)^(1/2)) / (2A)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      restore();\n      return;\n    }\n    //if (n == 4)\n    if (n === 4 || n === 5) {\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      p6 = pop(); // D\n      \n      // C - only related calculations\n      push(p5);\n      push(p5);\n      multiply();\n      R_c2 = pop();\n      push(R_c2);\n      push(p5);\n      multiply();\n      R_c3 = pop();\n      // B - only related calculations\n      push(p4);\n      push(p4);\n      multiply();\n      R_b2 = pop();\n      push(R_b2);\n      push(p4);\n      multiply();\n      R_b3 = pop();\n      push(R_b3);\n      push(p6);\n      multiply();\n      R_b3_d = pop();\n      push(R_b3_d);\n      push_integer(-4);\n      multiply();\n      R_m4_b3_d = pop();\n      push(R_b3);\n      push_integer(2);\n      multiply();\n      R_2_b3 = pop();\n      // A - only related calculations\n      push(p3);\n      push(p3);\n      multiply();\n      R_a2 = pop();\n      push(R_a2);\n      push(p3);\n      multiply();\n      R_a3 = pop();\n      push_integer(3);\n      push(p3);\n      multiply();\n      R_3_a = pop();\n      push(R_a2);\n      push(p6);\n      multiply();\n      R_a2_d = pop();\n      push(R_a2_d);\n      push(p6);\n      multiply();\n      R_a2_d2 = pop();\n      push(R_a2_d);\n      push_integer(27);\n      multiply();\n      R_27_a2_d = pop();\n      push(R_a2_d2);\n      push_integer(-27);\n      multiply();\n      R_m27_a2_d2 = pop();\n      push(R_3_a);\n      push_integer(2);\n      multiply();\n      R_6_a = pop();\n      // mixed calculations\n      push(p3);\n      push(p5);\n      multiply();\n      R_a_c = pop();\n      push(R_a_c);\n      push(p4);\n      multiply();\n      R_a_b_c = pop();\n      push(R_a_b_c);\n      push(p6);\n      multiply();\n      R_a_b_c_d = pop();\n      push(R_a_c);\n      push_integer(3);\n      multiply();\n      R_3_a_c = pop();\n      push_integer(-4);\n      push(p3);\n      push(R_c3);\n      multiply();\n      multiply();\n      R_m4_a_c3 = pop();\n      push(R_a_b_c);\n      push_integer(9);\n      multiply();\n      negate();\n      R_m9_a_b_c = pop();\n      push(R_a_b_c_d);\n      push_integer(18);\n      multiply();\n      R_18_a_b_c_d = pop();\n      push(R_b2);\n      push(R_3_a_c);\n      subtract();\n      R_DELTA0 = pop();\n      push(R_b2);\n      push(R_c2);\n      multiply();\n      R_b2_c2 = pop();\n      push(p4);\n      negate();\n      push(R_3_a);\n      divide();\n      R_m_b_over_3a = pop();\n      if (n === 4) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< \");\n        }\n        //console.log \">>>> A:\" + p3.toString()\n        //console.log \">>>> B:\" + p4.toString()\n        //console.log \">>>> C:\" + p5.toString()\n        //console.log \">>>> D:\" + p6.toString()\n        if (DEBUG) {\n          console.log(\"cubic: D0: \" + R_DELTA0.toString());\n        }\n        push(R_DELTA0);\n        push_integer(3);\n        power();\n        push_integer(4);\n        multiply();\n        R_4_DELTA03 = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_toBeCheckedIfZero = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D0 as float: \" + R_DELTA0_toBeCheckedIfZero.toString());\n        }\n        //if isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)\n        //  console.log \" *********************************** D0 IS ZERO\"\n\n        // DETERMINANT\n        push(R_18_a_b_c_d);\n        push(R_m4_b3_d);\n        push(R_b2_c2);\n        push(R_m4_a_c3);\n        push(R_m27_a2_d2);\n        add();\n        add();\n        add();\n        add();\n        simplify();\n        absValFloat();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"cubic: DETERMINANT: \" + R_determinant.toString());\n        }\n        // R_DELTA1\n        push(R_2_b3);\n        push(R_m9_a_b_c);\n        push(R_27_a2_d);\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D1: \" + R_DELTA1.toString());\n        }\n        // R_Q\n        push(R_DELTA1);\n        push_integer(2);\n        power();\n        push(R_4_DELTA03);\n        subtract();\n        push_rational(1, 2);\n        power();\n        simplify();\n        R_Q = pop();\n        if (isZeroAtomOrTensor(R_determinant)) {\n          if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is zero\");\n            }\n            push(R_m_b_over_3a); // just same solution three times\n            restore();\n            return;\n          } else {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is not zero\");\n            }\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            push(p4);\n            push(p5);\n            multiply();\n            subtract();\n            push(R_DELTA0);\n            push_integer(2);\n            multiply();\n            divide(); // first solution\n            root_solution = pop();\n            push(root_solution); // pushing two of them on the stack\n            push(root_solution);\n            // second solution here\n            // 4abc\n            push(R_a_b_c);\n            push_integer(4);\n            multiply();\n            // -9a*a*d\n            push(p3);\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            multiply();\n            negate();\n            // -9*b^3\n            push(R_b3);\n            negate();\n            // sum the three terms\n            add();\n            add();\n            // denominator is a*delta0\n            push(p3);\n            push(R_DELTA0);\n            multiply();\n            // build the fraction\n            divide();\n            restore();\n            return;\n          }\n        }\n        C_CHECKED_AS_NOT_ZERO = false;\n        flipSignOFQSoCIsNotZero = false;\n        while (!C_CHECKED_AS_NOT_ZERO) {\n          // R_C\n          push(R_Q);\n          if (flipSignOFQSoCIsNotZero) {\n            negate();\n          }\n          push(R_DELTA1);\n          add();\n          push_rational(1, 2);\n          multiply();\n          push_rational(1, 3);\n          power();\n          simplify();\n          R_C = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C: \" + R_C.toString());\n          }\n          push(R_C);\n          simplify();\n          absValFloat();\n          R_C_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C as absval and float: \" + R_C_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: C IS ZERO flipping the sign\");\n            }\n            flipSignOFQSoCIsNotZero = true;\n          } else {\n            C_CHECKED_AS_NOT_ZERO = true;\n          }\n        }\n        push(R_C);\n        push(R_3_a);\n        multiply();\n        R_3_a_C = pop();\n        push(R_3_a_C);\n        push_integer(2);\n        multiply();\n        R_6_a_C = pop();\n        // imaginary parts calculations\n        push(imaginaryunit);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        multiply();\n        i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        add();\n        one_plus_i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        subtract();\n        one_minus_i_sqrt3 = pop();\n        push(R_C);\n        push(R_3_a);\n        divide();\n        R_C_over_3a = pop();\n        // first solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        negate(); // second term\n        push(R_DELTA0);\n        push(R_3_a_C);\n        divide();\n        negate(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // second solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_plus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_minus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // third solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_minus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_plus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        restore();\n        return;\n      }\n      // See http://www.sscc.edu/home/jdavidso/Math/Catalog/Polynomials/Fourth/Fourth.html\n      // for a description of general shapes and properties of fourth degree polynomials\n      if (n === 5) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< \");\n        }\n        p7 = pop(); // E\n        if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {\n          if (DEBUG) {\n            console.log(\"biquadratic case\");\n          }\n          push(p3);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(p5);\n          push(symbol(SECRETX));\n          multiply();\n          push(p7);\n          add();\n          add();\n          push(symbol(SECRETX));\n          roots();\n          biquadraticSolutions = pop();\n          ref2 = biquadraticSolutions.tensor.elem;\n          for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n            eachSolution = ref2[l1];\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            simplify();\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            negate();\n            simplify();\n          }\n          restore();\n          return;\n        }\n        // D - only related calculations\n        push(p6);\n        push(p6);\n        multiply();\n        R_d2 = pop();\n        // E - only related calculations\n        push(p7);\n        push(p7);\n        multiply();\n        R_e2 = pop();\n        push(R_e2);\n        push(p7);\n        multiply();\n        R_e3 = pop();\n        // DETERMINANT\n        push_integer(256);\n        push(R_a3);\n        push(R_e3);\n        multiply();\n        multiply(); // first term 256 a^3 e^3\n        push_integer(-192);\n        push(R_a2_d);\n        push(R_e2);\n        push(p4);\n        multiply();\n        multiply();\n        multiply(); // second term -192 a^3 b d e^2\n        push_integer(-128);\n        push(R_a2);\n        push(R_c2);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // third term -128 a^2 c^2 e^2\n        push_integer(144);\n        push(R_a2_d2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fourth term 144 a^2 c d^2 e\n        push(R_m27_a2_d2);\n        push(R_d2);\n        multiply(); // fifth term -27 a^2 d^4\n        push_integer(144);\n        push(R_a_b_c);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // sixth term 144 a b^2 c e^2\n        push_integer(-6);\n        push(p3);\n        push(R_b2);\n        push(R_d2);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        multiply(); // seventh term -6 a b^2 d^2 e\n        push_integer(-80);\n        push(R_a_b_c_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // eigth term -80 a b c^2 d e\n        push_integer(18);\n        push(R_a_b_c_d);\n        push(R_d2);\n        multiply();\n        multiply(); // ninth term 18 a b c d^3\n        push_integer(16);\n        push(R_a_c);\n        push(R_c3);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // tenth term 16 a c^4 e\n        push_integer(-4);\n        push(R_a_c);\n        push(R_c2);\n        push(R_d2);\n        multiply();\n        multiply();\n        multiply(); // eleventh term -4 a c^3 d^2\n        push_integer(-27);\n        push(R_b3);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // twelveth term -27 b^4 e^2\n        push_integer(18);\n        push(R_b3_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // thirteenth term 18 b^3 c d e\n        push(R_m4_b3_d);\n        push(R_d2);\n        multiply(); // fourteenth term -4 b^3 d^3\n        push_integer(-4);\n        push(R_b2_c2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fifteenth term -4 b^2 c^3 e\n        push(R_b2_c2);\n        push(R_d2);\n        multiply(); // sixteenth term b^2 c^2 d^2\n        \n        // add together the sixteen terms by doing\n        // fifteen adds\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"R_determinant: \" + R_determinant.toString());\n        }\n        // DELTA0\n        push(R_c2); // term one of DELTA0\n        push_integer(-3);\n        push(p4);\n        push(p6);\n        multiply();\n        multiply(); // term two of DELTA0\n        push_integer(12);\n        push(p3);\n        push(p7);\n        multiply();\n        multiply(); // term three of DELTA0\n        \n        // add the three terms together\n        add();\n        add();\n        R_DELTA0 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA0: \" + R_DELTA0.toString());\n        }\n        // DELTA1\n        push_integer(2);\n        push(R_c3);\n        multiply();\n        push_integer(-9);\n        push(p4);\n        push(p5);\n        push(p6);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(27);\n        push(R_b2);\n        push(p7);\n        multiply();\n        multiply();\n        push_integer(27);\n        push(p3);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(-72);\n        push(R_a_c);\n        push(p7);\n        multiply();\n        multiply();\n        // add the five terms together\n        add();\n        add();\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA1: \" + R_DELTA1.toString());\n        }\n        // p\n        push_integer(8);\n        push(R_a_c);\n        multiply();\n        push_integer(-3);\n        push(R_b2);\n        multiply();\n        add();\n        push_integer(8);\n        push(R_a2);\n        multiply();\n        divide();\n        R_p = pop();\n        if (DEBUG) {\n          console.log(\"p: \" + R_p.toString());\n        }\n        // q\n        push(R_b3);\n        push_integer(-4);\n        push(R_a_b_c);\n        multiply();\n        push_integer(8);\n        push(R_a2_d);\n        multiply();\n        add();\n        add();\n        push_integer(8);\n        push(R_a3);\n        multiply();\n        divide();\n        R_q = pop();\n        if (DEBUG) {\n          console.log(\"q: \" + R_q.toString());\n        }\n        if (DEBUG) {\n          console.log(\"tos 1 \" + tos);\n        }\n        if (!isZeroAtomOrTensor(p4)) {\n          if (DEBUG) {\n            console.log(\"tos 2 \" + tos);\n          }\n          push_integer(8);\n          push(p5);\n          push(p3);\n          multiply();\n          multiply();\n          push_integer(-3);\n          push(p4);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          divide();\n          R_p = pop();\n          if (DEBUG) {\n            console.log(\"p for depressed quartic: \" + R_p.toString());\n          }\n          push(p4);\n          push_integer(3);\n          power();\n          push_integer(-4);\n          push(p3);\n          push(p4);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          push_integer(8);\n          push(p6);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          multiply();\n          add();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(3);\n          power();\n          multiply();\n          divide();\n          R_q = pop();\n          if (DEBUG) {\n            console.log(\"q for depressed quartic: \" + R_q.toString());\n          }\n          // convert to depressed quartic\n          push(p4);\n          push_integer(4);\n          power();\n          push_integer(-3);\n          multiply();\n          push_integer(256);\n          push(R_a3);\n          push(p7);\n          multiply();\n          multiply();\n          push_integer(-64);\n          push(R_a2_d);\n          push(p4);\n          multiply();\n          multiply();\n          push_integer(16);\n          push(R_b2);\n          push(p3);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          add();\n          add();\n          add();\n          push_integer(256);\n          push(p3);\n          push_integer(4);\n          power();\n          multiply();\n          divide();\n          R_r = pop();\n          if (DEBUG) {\n            console.log(\"r for depressed quartic: \" + R_r.toString());\n          }\n          if (DEBUG) {\n            console.log(\"tos 4 \" + tos);\n          }\n          push(symbol(SECRETX));\n          push_integer(4);\n          power();\n          if (DEBUG) {\n            console.log(\"4 * x^4: \" + stack[tos - 1].toString());\n          }\n          push(R_p);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_p * x^2: \" + stack[tos - 1].toString());\n          }\n          push(R_q);\n          push(symbol(SECRETX));\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_q * x: \" + stack[tos - 1].toString());\n          }\n          push(R_r);\n          if (DEBUG) {\n            console.log(\"R_r: \" + stack[tos - 1].toString());\n          }\n          add();\n          add();\n          add();\n          simplify();\n          if (DEBUG) {\n            console.log(\"solving depressed quartic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          depressedSolutions = pop();\n          if (DEBUG) {\n            console.log(\"depressedSolutions: \" + depressedSolutions);\n          }\n          ref3 = depressedSolutions.tensor.elem;\n          for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {\n            eachSolution = ref3[m1];\n            push(eachSolution);\n            push(p4);\n            push_integer(4);\n            push(p3);\n            multiply();\n            divide();\n            subtract();\n            simplify();\n            if (DEBUG) {\n              console.log(\"solution from depressed: \" + stack[tos - 1].toString());\n            }\n          }\n          restore();\n          return;\n        } else {\n          R_p = p5;\n          R_q = p6;\n          R_r = p7;\n          /*\n           * Descartes' solution\n           * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution\n           * finding the \"u\" in the depressed equation\n\n          push_integer(2)\n          push(R_p)\n          multiply()\n          coeff2 = pop()\n\n          push_integer(-4)\n          push(R_p)\n          push_integer(2)\n          power()\n          multiply()\n          push(R_r)\n          multiply()\n          coeff3 = pop()\n\n          push(R_q)\n          push_integer(2)\n          power()\n          negate()\n          coeff4 = pop()\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(3)\n          power()\n\n          push(coeff2)\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          multiply()\n\n          push(coeff3)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(coeff4)\n\n          add()\n          add()\n          add()\n\n          console.log(\"Descarte's resolventCubic: \" +  stack[tos-1].toString())\n          push(symbol(SECRETX))\n\n          roots()\n\n          resolventCubicSolutions = pop()\n          console.log(\"Descarte's resolventCubic solutions: \" +  resolventCubicSolutions)\n          console.log(\"tos: \" +  tos)\n\n          R_u = null\n          #R_u = resolventCubicSolutions.tensor.elem[1]\n          for eachSolution in resolventCubicSolutions.tensor.elem\n            console.log(\"examining solution: \" +  eachSolution)\n            push(eachSolution)\n            push_integer(2)\n            multiply()\n            push(R_p)\n            add()\n\n            absValFloat()\n            toBeCheckedIFZero = pop()\n            console.log(\"abs value is: \" +  eachSolution)\n            if !isZeroAtomOrTensor(toBeCheckedIFZero)\n              R_u = eachSolution\n              break\n\n          console.log(\"chosen solution: \" +  R_u)\n\n          push(R_u)\n          negate()\n          R_s = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          add()\n          add()\n          push_integer(2)\n          divide()\n          R_t = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          subtract()\n          add()\n          push_integer(2)\n          divide()\n          R_v = pop()\n\n           * factoring the quartic into two quadratics:\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_s)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_t)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 1: \" + stack[tos-1].toString())\n\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_u)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_v)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 2: \" + stack[tos-1].toString())\n          pop()\n\n          restore()\n          return\n           */\n          // Ferrari's solution\n          // https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n          // finding the \"m\" in the depressed equation\n          push_rational(5, 2);\n          push(R_p);\n          multiply();\n          coeff2 = pop();\n          push_integer(2);\n          push(R_p);\n          push_integer(2);\n          power();\n          multiply();\n          push(R_r);\n          subtract();\n          coeff3 = pop();\n          push(R_p);\n          push_integer(3);\n          power();\n          push_integer(2);\n          divide();\n          push_rational(-1, 2);\n          push(R_p);\n          push(R_r);\n          multiply();\n          multiply();\n          push_rational(-1, 8);\n          push(R_q);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n          coeff4 = pop();\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          push(coeff2);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(coeff3);\n          push(symbol(SECRETX));\n          multiply();\n          push(coeff4);\n          add();\n          add();\n          add();\n          if (DEBUG) {\n            console.log(\"resolventCubic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          resolventCubicSolutions = pop();\n          if (DEBUG) {\n            console.log(\"resolventCubicSolutions: \" + resolventCubicSolutions);\n          }\n          R_m = null;\n          ref4 = resolventCubicSolutions.tensor.elem;\n          //R_m = resolventCubicSolutions.tensor.elem[1]\n          for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {\n            eachSolution = ref4[n1];\n            if (DEBUG) {\n              console.log(\"examining solution: \" + eachSolution);\n            }\n            push(eachSolution);\n            push_integer(2);\n            multiply();\n            push(R_p);\n            add();\n            absValFloat();\n            toBeCheckedIFZero = pop();\n            if (DEBUG) {\n              console.log(\"abs value is: \" + eachSolution);\n            }\n            if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {\n              R_m = eachSolution;\n              break;\n            }\n          }\n          if (DEBUG) {\n            console.log(\"chosen solution: \" + R_m);\n          }\n          push(R_m);\n          push_integer(2);\n          multiply();\n          push(R_p);\n          add();\n          push_rational(1, 2);\n          power();\n          simplify();\n          sqrtPPlus2M = pop();\n          push(R_q);\n          push_integer(2);\n          multiply();\n          push(sqrtPPlus2M);\n          divide();\n          simplify();\n          TwoQOversqrtPPlus2M = pop();\n          push(R_p);\n          push_integer(3);\n          multiply();\n          push(R_m);\n          push_integer(2);\n          multiply();\n          add();\n          ThreePPlus2M = pop();\n          // solution1\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution2\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          // solution3\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution4\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          restore();\n          return;\n        }\n        // Q ---------------------------\n        push(R_determinant);\n        simplify();\n        absValFloat();\n        R_determinant_simplified_toCheckIfZero = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_simplified_toCheckIfZero = pop();\n        S_CHECKED_AS_NOT_ZERO = false;\n        choiceOfRadicalInQSoSIsNotZero = 0;\n        while (!S_CHECKED_AS_NOT_ZERO) {\n          Q_CHECKED_AS_NOT_ZERO = false;\n          flipSignOFRadicalSoQIsNotZero = false;\n          while (!Q_CHECKED_AS_NOT_ZERO) {\n            // D1 under the outer radical\n            push(R_DELTA1);\n            // D1^2 under the inner radical\n            push(R_DELTA1);\n            push_integer(2);\n            power();\n            // 4*D0^3 under the inner radical\n            push_integer(-4);\n            push(R_DELTA0);\n            push_integer(3);\n            power();\n            multiply();\n            // addition under the inner radical\n            add();\n            // the second radical\n            push_rational(1, 2);\n            power();\n            if (flipSignOFRadicalSoQIsNotZero) {\n              negate();\n            }\n            // the addition under the outer radical\n            add();\n            // content of outer radical divided by two\n            push_integer(2);\n            divide();\n            if (DEBUG) {\n              console.log(\"content of cubic root: \" + stack[tos - 1].toString());\n            }\n            // outer radical calculation: cubic root\n            // now we actually have to find all the roots\n            // because we have to pick the one that makes S != 0\n            push_rational(1, 3);\n            power();\n            simplify();\n            R_principalCubicRoot = pop();\n            if (DEBUG) {\n              console.log(\"principal cubic root: \" + R_principalCubicRoot.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos : \" + tos);\n            }\n            if (choiceOfRadicalInQSoSIsNotZero === 0) {\n              if (DEBUG) {\n                console.log(\"chosing principal cubic root\");\n              }\n              push(R_principalCubicRoot);\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(-1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            }\n            simplify();\n            R_Q = pop();\n            if (DEBUG) {\n              console.log(\"Q \" + R_Q.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n            push(R_Q);\n            simplify();\n            absValFloat();\n            R_Q_simplified_toCheckIfZero = pop();\n            if (DEBUG) {\n              console.log(\"Q simplified and abs\" + R_Q_simplified_toCheckIfZero.toString());\n            }\n            if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && (!isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero))) {\n              if (DEBUG) {\n                console.log(\" *********************************** Q IS ZERO and it matters, flipping the sign\");\n              }\n              flipSignOFRadicalSoQIsNotZero = true;\n            } else {\n              Q_CHECKED_AS_NOT_ZERO = true;\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n          }\n          // S\n          push_rational(-2, 3);\n          push(R_p);\n          multiply();\n          push(R_Q);\n          push(R_DELTA0);\n          push(R_Q);\n          divide();\n          add();\n          //rationalize()\n          //console.log(\"rationalised: \" + stack[tos-1].toString())\n          //simplify()\n          push(R_3_a);\n          divide();\n          add();\n          push_rational(1, 2);\n          power();\n          push_integer(2);\n          divide();\n          show_power_debug = true;\n          simplify();\n          R_S = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S.toString());\n          }\n          // now check if S is zero\n          push(R_S);\n          simplify();\n          absValFloat();\n          R_S_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" *********************************** S IS ZERO chosing another cubic root\");\n            }\n            choiceOfRadicalInQSoSIsNotZero++;\n          } else {\n            S_CHECKED_AS_NOT_ZERO = true;\n          }\n          if (DEBUG) {\n            console.log(\"tos: \" + tos);\n          }\n        }\n        // ----------------------------\n        if (DEBUG) {\n          console.log(\"tos: \" + tos);\n        }\n        push(p4);\n        negate();\n        push(p3);\n        push_integer(4);\n        multiply();\n        divide();\n        R_minus_b_over_4a = pop();\n        push_integer(-4);\n        push(R_S);\n        push_integer(2);\n        power();\n        multiply();\n        push_integer(2);\n        push(R_p);\n        multiply();\n        subtract();\n        R_minus_4S2_minus_2p = pop();\n        push(R_q);\n        push(R_S);\n        divide();\n        R_q_over_S = pop();\n        if (DEBUG) {\n          console.log(\"tos before putting together the 4 solutions: \" + tos);\n        }\n        // first solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // second solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        // third solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // fourth solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        restore();\n        return;\n      }\n    }\n    moveTos(tos - n);\n    return restore();\n  };\n\n  Eval_round = function() {\n    push(cadr(p1));\n    Eval();\n    return yround();\n  };\n\n  yround = function() {\n    save();\n    yyround();\n    return restore();\n  };\n\n  yyround = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(ROUND);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.round(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    push(p1);\n    yyfloat();\n    p1 = pop();\n    return push_integer(Math.round(p1.d));\n  };\n\n  // This scanner uses the recursive descent method.\n\n  // The char pointers token_str and scan_str are pointers to the input string as\n  // in the following example.\n\n  //  | g | a | m | m | a |   | a | l | p | h | a |\n  //    ^                   ^\n  //    token_str           scan_str\n\n  // The char pointer token_buf points to a malloc buffer.\n\n  //  | g | a | m | m | a | \\0 |\n  //    ^\n  //    token_buf\n\n  // In the sequence of method invocations for scanning,\n  // first we do the calls for scanning the operands\n  // of the operators of least precedence.\n  // So, since precedence in maths goes something like\n  // (form high to low) exponents, mult/div, plus/minus\n  // so we scan first for terms, then factors, then powers.\n  // That's the general idea, but of course we also have to deal\n  // with things like parens, non-commutative\n  // dot (or inner) product, assignments and tests,\n  // function calls etc.\n  // Note that a^1/2 is, correctly, a/2, not, incorrectly, sqrt(a),\n  // see comment in related test in power.coffee for more about this.\n\n  //  Notes:\n\n  //  Formerly add() and multiply() were used to construct expressions but\n  //  this preevaluation caused problems.\n\n  //  For example, suppose A has the floating point value inf.\n\n  //  Before, the expression A/A resulted in 1 because the scanner would\n  //  divide the symbols.\n\n  //  After removing add() and multiply(), A/A results in nan which is the\n  //  correct result.\n\n  //  The functions negate() and inverse() are used but they do not cause\n  //  problems with preevaluation of symbols.\n  T_INTEGER = 1001;\n\n  T_DOUBLE = 1002;\n\n  T_SYMBOL = 1003;\n\n  T_FUNCTION = 1004;\n\n  T_NEWLINE = 1006;\n\n  T_STRING = 1007;\n\n  T_GTEQ = 1008;\n\n  T_LTEQ = 1009;\n\n  T_EQ = 1010;\n\n  T_NEQ = 1011;\n\n  T_QUOTASSIGN = 1012;\n\n  token = \"\";\n\n  newline_flag = 0;\n\n  meta_mode = 0;\n\n  input_str = 0;\n\n  scan_str = 0;\n\n  token_str = 0;\n\n  token_buf = 0;\n\n  lastFoundSymbol = null;\n\n  symbolsRightOfAssignment = null;\n\n  symbolsLeftOfAssignment = null;\n\n  isSymbolLeftOfAssignment = null;\n\n  scanningParameters = null;\n\n  functionInvokationsScanningStack = null;\n\n  skipRootVariableToBeSolved = false;\n\n  assignmentFound = null;\n\n  // Returns number of chars scanned and expr on stack.\n\n  // Returns zero when nothing left to scan.\n\n  // takes a string\n  scanned = \"\";\n\n  scan = function(s) {\n    if (DEBUG) {\n      console.log(\"#### scanning \" + s);\n    }\n    //if s==\"y=x\"\n    //  debugger\n    //if s==\"y\"\n    //  debugger\n    //if s==\"i=sqrt(-1)\"\n    //  debugger\n    lastFoundSymbol = null;\n    symbolsRightOfAssignment = [];\n    symbolsLeftOfAssignment = [];\n    isSymbolLeftOfAssignment = true;\n    scanningParameters = [];\n    functionInvokationsScanningStack = [\"\"];\n    assignmentFound = false;\n    scanned = s;\n    meta_mode = 0;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    if (!assignmentFound) {\n      symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);\n    }\n    return token_str - input_str;\n  };\n\n  // takes a string\n  scan_meta = function(s) {\n    scanned = s;\n    meta_mode = 1;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    return token_str - input_str;\n  };\n\n  scan_stmt = function() {\n    var assignmentIsOfQuotedType, existingDependencies, i, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;\n    scan_relation();\n    assignmentIsOfQuotedType = false;\n    if (token === T_QUOTASSIGN) {\n      assignmentIsOfQuotedType = true;\n    }\n    if (token === T_QUOTASSIGN || token === '=') {\n      symbolLeftOfAssignment = lastFoundSymbol;\n      if (DEBUG) {\n        console.log(\"assignment!\");\n      }\n      assignmentFound = true;\n      isSymbolLeftOfAssignment = false;\n      get_next_token();\n      push_symbol(SETQ);\n      swap();\n      // if it's a := then add a quote\n      if (assignmentIsOfQuotedType) {\n        push_symbol(QUOTE);\n      }\n      scan_relation();\n      // if it's a := then you have to list\n      // together the quote and its argument\n      if (assignmentIsOfQuotedType) {\n        list(2);\n      }\n      list(3);\n      isSymbolLeftOfAssignment = true;\n      if (codeGen) {\n        // in case of re-assignment, the symbol on the\n        // left will also be in the set of the symbols\n        // on the right. In that case just remove it from\n        // the symbols on the right.\n        indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);\n        if (indexOfSymbolLeftOfAssignment !== -1) {\n          symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);\n          symbolsHavingReassignments.push(symbolLeftOfAssignment);\n        }\n        \n        // print out the immediate dependencies\n        if (DEBUG) {\n          console.log(\"locally, \" + symbolLeftOfAssignment + \" depends on: \");\n          for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {\n            i = symbolsRightOfAssignment[l1];\n            console.log(\"  \" + i);\n          }\n        }\n        // ok add the local dependencies to the existing\n        // dependencies of this left-value symbol\n\n        // create the exiting dependencies list if it doesn't exist\n        if (symbolsDependencies[symbolLeftOfAssignment] == null) {\n          symbolsDependencies[symbolLeftOfAssignment] = [];\n        }\n        existingDependencies = symbolsDependencies[symbolLeftOfAssignment];\n// copy over the new dependencies to the existing\n// dependencies avoiding repetitions\n        for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {\n          i = symbolsRightOfAssignment[m1];\n          if (existingDependencies.indexOf(i) === -1) {\n            existingDependencies.push(i);\n          }\n        }\n        return symbolsRightOfAssignment = [];\n      }\n    }\n  };\n\n  scan_relation = function() {\n    scan_expression();\n    switch (token) {\n      case T_EQ:\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_NEQ:\n        push_symbol(NOT);\n        swap();\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        list(3);\n        return list(2);\n      case T_LTEQ:\n        push_symbol(TESTLE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_GTEQ:\n        push_symbol(TESTGE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '<':\n        push_symbol(TESTLT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '>':\n        push_symbol(TESTGT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n    }\n  };\n\n  scan_expression = function() {\n    var h;\n    h = tos;\n    switch (token) {\n      case '+':\n        get_next_token();\n        scan_term();\n        break;\n      case '-':\n        get_next_token();\n        scan_term();\n        negate();\n        break;\n      default:\n        scan_term();\n    }\n    while (newline_flag === 0 && (token === '+' || token === '-')) {\n      if (token === '+') {\n        get_next_token();\n        scan_term();\n      } else {\n        get_next_token();\n        scan_term();\n        negate();\n      }\n    }\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(ADD);\n      swap();\n      return cons();\n    }\n  };\n\n  is_factor = function() {\n    if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n      return 1;\n    }\n    switch (token) {\n      case '*':\n      case '/':\n        return 1;\n      case '(':\n      case T_SYMBOL:\n      case T_FUNCTION:\n      case T_INTEGER:\n      case T_DOUBLE:\n      case T_STRING:\n        if (newline_flag) { // implicit mul can't cross line\n          scan_str = token_str; // better error display\n          return 0;\n        } else {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  simplify_1_in_products = function(tos, h) {\n    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {\n      return pop();\n    }\n  };\n\n  // calculate away consecutive constants\n  multiply_consecutive_constants = function(tos, h) {\n    if (tos > h + 1 && isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply();\n    }\n  };\n\n  scan_term = function() {\n    var h;\n    h = tos;\n    scan_factor();\n    if (parse_time_simplifications) {\n      simplify_1_in_products(tos, h);\n    }\n    while (is_factor()) {\n      if (token === '*') {\n        get_next_token();\n        scan_factor();\n      } else if (token === '/') {\n        // in case of 1/... then\n        // we scanned the 1, we get rid\n        // of it because otherwise it becomes\n        // an extra factor that wasn't there and\n        // things like\n        // 1/(2*a) become 1*(1/(2*a))\n        simplify_1_in_products(tos, h);\n        get_next_token();\n        scan_factor();\n        inverse();\n      } else if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n        get_next_token();\n        push_symbol(INNER);\n        swap();\n        scan_factor();\n        list(3);\n      } else {\n        scan_factor();\n      }\n      if (parse_time_simplifications) {\n        multiply_consecutive_constants(tos, h);\n        simplify_1_in_products(tos, h);\n      }\n    }\n    if (h === tos) {\n      return push_integer(1);\n    } else if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      return cons();\n    }\n  };\n\n  scan_power = function() {\n    if (token === '^') {\n      get_next_token();\n      push_symbol(POWER);\n      swap();\n      scan_factor();\n      return list(3);\n    }\n  };\n\n  scan_index = function(h) {\n    //console.log \"[ as index\"\n    get_next_token();\n    push_symbol(INDEX);\n    swap();\n    scan_expression();\n    while (token === ',') {\n      get_next_token();\n      scan_expression();\n    }\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    get_next_token();\n    return list(tos - h);\n  };\n\n  scan_factor = function() {\n    var firstFactorIsNumber, h;\n    h = tos;\n    //console.log \"scan_factor token: \" + token\n    firstFactorIsNumber = false;\n    if (token === '(') {\n      scan_subexpr();\n    } else if (token === T_SYMBOL) {\n      scan_symbol();\n    } else if (token === T_FUNCTION) {\n      scan_function_call_with_function_name();\n    } else if (token === '[') {\n      //console.log \"[ as tensor\"\n      //debugger\n      scan_tensor();\n    } else if (token === T_INTEGER) {\n      firstFactorIsNumber = true;\n      bignum_scan_integer(token_buf);\n      get_next_token();\n    } else if (token === T_DOUBLE) {\n      firstFactorIsNumber = true;\n      bignum_scan_float(token_buf);\n      get_next_token();\n    } else if (token === T_STRING) {\n      scan_string();\n    } else {\n      scan_error(\"syntax error\");\n    }\n    // after the main initial part of the factor that\n    // we just scanned above,\n    // we can get an arbitrary about of appendages\n    // of the form ...[...](...)...\n    // If the main part is not a number, then these are all, respectively,\n    //  - index references (as opposed to tensor definition) and\n    //  - function calls without an explicit function name\n    //    (instead of subexpressions or parameters of function\n    //    definitions or function calls with an explicit function\n    //    name), respectively\n    while (token === '[' || token === '(' && newline_flag === 0 && !firstFactorIsNumber) {\n      if (token === '[') {\n        scan_index(h);\n      } else if (token === '(') {\n        //console.log \"( as function call without function name \"\n        scan_function_call_without_function_name();\n      }\n    }\n    while (token === '!') {\n      get_next_token();\n      push_symbol(FACTORIAL);\n      swap();\n      list(2);\n    }\n    while ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === transpose_unicode) {\n      get_next_token();\n      push_symbol(TRANSPOSE);\n      swap();\n      list(2);\n    }\n    return scan_power();\n  };\n\n  addSymbolRightOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols right of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsRightOfAssignment.push(theSymbol);\n    }\n  };\n\n  addSymbolLeftOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols left of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsLeftOfAssignment.push(theSymbol);\n    }\n  };\n\n  scan_symbol = function() {\n    if (token !== T_SYMBOL) {\n      scan_error(\"symbol expected\");\n    }\n    if (meta_mode && token_buf.length === 1) {\n      switch (token_buf[0]) {\n        case 'a':\n          push(symbol(METAA));\n          break;\n        case 'b':\n          push(symbol(METAB));\n          break;\n        case 'x':\n          push(symbol(METAX));\n          break;\n        default:\n          push(usr_symbol(token_buf));\n      }\n    } else {\n      push(usr_symbol(token_buf));\n    }\n    //console.log \"found symbol: \" + token_buf\n    if (scanningParameters.length === 0) {\n      if (DEBUG) {\n        console.log(\"out of scanning parameters, processing \" + token_buf);\n      }\n      lastFoundSymbol = token_buf;\n      if (isSymbolLeftOfAssignment) {\n        addSymbolLeftOfAssignment(token_buf);\n      }\n    } else {\n      if (DEBUG) {\n        console.log(\"still scanning parameters, skipping \" + token_buf);\n      }\n      if (isSymbolLeftOfAssignment) {\n        addSymbolRightOfAssignment(\"'\" + token_buf);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"found symbol: \" + token_buf + \" left of assignment: \" + isSymbolLeftOfAssignment);\n    }\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    return get_next_token();\n  };\n\n  scan_string = function() {\n    push(new_string(token_buf));\n    return get_next_token();\n  };\n\n  scan_function_call_with_function_name = function() {\n    var functionName, i, l1, n, p, ref2;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_with_function_name start\");\n    }\n    n = 1; // the parameter number as we scan parameters\n    p = new U();\n    p = usr_symbol(token_buf);\n    push(p);\n    functionName = token_buf;\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.push(token_buf);\n    }\n    lastFoundSymbol = token_buf;\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    get_next_token(); // open parens\n    get_next_token(); // 1st parameter\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        // roots' disappearing variable, if there, is the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // sums' disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"sum\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // product's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"product\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // for's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"for\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // defint's disappearing variables can be in positions 2,5,8...\n        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"defint\") !== -1 && (n === 2 || (n > 2 && ((n - 2) % 3 === 0)))) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        scan_stmt();\n        skipRootVariableToBeSolved = false;\n        n++;\n      }\n      // todo refactor this, there are two copies\n      // this catches the case where the \"roots\" variable is not specified\n      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n          return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + \"x\")).test(x);\n        });\n      }\n    }\n    scanningParameters.pop();\n    for (i = l1 = 0, ref2 = symbolsRightOfAssignment.length; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (symbolsRightOfAssignment[i] != null) {\n        if (functionName === \"roots\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"defint\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"sum\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"product\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"for\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n      }\n    }\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.pop();\n    }\n    if (functionName === symbol(PATTERN).printname) {\n      patternHasBeenFound = true;\n    }\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_with_function_name end\");\n    }\n  };\n\n  scan_function_call_without_function_name = function() {\n    var n;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_without_function_name start\");\n    }\n    // the function will have to be looked up\n    // at runtime (i.e. we need to evaulate something to find it\n    // e.g. it might be inside a tensor, so we'd need to evaluate\n    // a tensor element access in that case)\n    push_symbol(EVAL);\n    swap();\n    list(2);\n    n = 1; // the parameter number as we scan parameters\n    get_next_token(); // left paren\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        scan_stmt();\n        n++;\n      }\n    }\n    scanningParameters.pop();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_without_function_name end: \" + stack[tos - 1]);\n    }\n  };\n\n  // scan subexpression\n  scan_subexpr = function() {\n    var n;\n    n = 0;\n    if (token !== '(') {\n      scan_error(\"( expected\");\n    }\n    get_next_token();\n    scan_stmt();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_tensor = function() {\n    var n;\n    n = 0;\n    if (token !== '[') {\n      scan_error(\"[ expected\");\n    }\n    get_next_token();\n    //console.log \"scanning the next statement\"\n    scan_stmt();\n    n = 1;\n    while (token === ',') {\n      get_next_token();\n      scan_stmt();\n      n++;\n    }\n    //console.log \"building tensor with elements number: \" + n\n    build_tensor(n);\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_error = function(errmsg) {\n    errorMessage = \"\";\n    // try not to put question mark on orphan line\n    while (input_str !== scan_str) {\n      if ((scanned[input_str] === '\\n' || scanned[input_str] === '\\r') && input_str + 1 === scan_str) {\n        break;\n      }\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += \" ? \";\n    while (scanned[input_str] && (scanned[input_str] !== '\\n' && scanned[input_str] !== '\\r')) {\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += '\\n';\n    return stop(errmsg);\n  };\n\n  // There are n expressions on the stack, possibly tensors.\n\n  // This function assembles the stack expressions into a single tensor.\n\n  // For example, at the top level of the expression ((a,b),(c,d)), the vectors\n  // (a,b) and (c,d) would be on the stack.\n\n  // takes an integer\n  build_tensor = function(n) {\n    var i, l1, ref2;\n    // int i, j, k, ndim, nelem\n    i = 0;\n    save();\n    p2 = alloc_tensor(n);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.elem[i] = stack[tos - n + i];\n    }\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  get_next_token = function() {\n    newline_flag = 0;\n    while (1) {\n      get_token();\n      if (token !== T_NEWLINE) {\n        break;\n      }\n      newline_flag = 1;\n    }\n    if (DEBUG) {\n      return console.log(\"get_next_token token: \" + token);\n    }\n  };\n\n  //if token == ')'\n  //  debugger\n  get_token = function() {\n    // skip spaces\n    while (isspace(scanned[scan_str])) {\n      if (scanned[scan_str] === '\\n' || scanned[scan_str] === '\\r') {\n        token = T_NEWLINE;\n        scan_str++;\n        return;\n      }\n      scan_str++;\n    }\n    token_str = scan_str;\n    // end of string?\n    if (scan_str === scanned.length) {\n      token = \"\";\n      return;\n    }\n    // number?\n    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {\n      while (isdigit(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '.') {\n        scan_str++;\n        while (isdigit(scanned[scan_str])) {\n          scan_str++;\n        }\n        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {\n          scan_str += 2;\n          while (isdigit(scanned[scan_str])) {\n            scan_str++;\n          }\n        }\n        token = T_DOUBLE;\n      } else {\n        token = T_INTEGER;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // symbol?\n    if (isalpha(scanned[scan_str])) {\n      while (isalnumorunderscore(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '(') {\n        token = T_FUNCTION;\n      } else {\n        token = T_SYMBOL;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // string ?\n    if (scanned[scan_str] === '\"') {\n      scan_str++;\n      while (scanned[scan_str] !== '\"') {\n        //if (scan_str == scanned.length || scanned[scan_str] == '\\n' || scanned[scan_str] == '\\r')\n        if (scan_str === scanned.length - 1) {\n          scan_str++;\n          scan_error(\"runaway string\");\n          scan_str--;\n        }\n        scan_str++;\n      }\n      scan_str++;\n      token = T_STRING;\n      update_token_buf(token_str + 1, scan_str - 1);\n      return;\n    }\n    // comment?\n    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {\n      while (scanned[scan_str] && scanned[scan_str] !== '\\n' && scanned[scan_str] !== '\\r') {\n        scan_str++;\n      }\n      if (scanned[scan_str]) {\n        scan_str++;\n      }\n      token = T_NEWLINE;\n      return;\n    }\n    // quote-assignment\n    if (scanned[scan_str] === ':' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_QUOTASSIGN;\n      return;\n    }\n    // relational operator?\n    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_EQ;\n      return;\n    }\n    // != operator. It's a little odd because\n    // \"!\" is not a \"not\", which would make things consistent.\n    // (it's used for factorial).\n    // An alternative would be to use \"<>\" but it's not used\n    // a lot in other languages...\n    if (scanned[scan_str] === '!' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_NEQ;\n      return;\n    }\n    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_LTEQ;\n      return;\n    }\n    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_GTEQ;\n      return;\n    }\n    // single char token\n    return token = scanned[scan_str++];\n  };\n\n  // both strings\n  update_token_buf = function(a, b) {\n    return token_buf = scanned.substring(a, b);\n  };\n\n  $.scan = scan;\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  sgn sign function\n\n  //-----------------------------------------------------------------------------\n  Eval_sgn = function() {\n    push(cadr(p1));\n    Eval();\n    return sgn();\n  };\n\n  sgn = function() {\n    save();\n    yysgn();\n    return restore();\n  };\n\n  //define X p1\n  yysgn = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d > 0) {\n        push_integer(1);\n        return;\n      } else {\n        if (p1.d === 0) {\n          push_integer(1);\n          return;\n        } else {\n          push_integer(-1);\n          return;\n        }\n      }\n    }\n    if (isrational(p1)) {\n      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {\n        push_integer(-1);\n        return;\n      } else {\n        if (MZERO(mmul(p1.q.a, p1.q.b))) {\n          push_integer(0);\n          return;\n        } else {\n          push_integer(1);\n          return;\n        }\n      }\n    }\n    if (iscomplexnumber(p1)) {\n      push_integer(-1);\n      push(p1);\n      absval();\n      power();\n      push(p1);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(SGN);\n      push(p1);\n      negate();\n      list(2);\n      push_integer(-1);\n      multiply();\n      return;\n    }\n    /*\n    push_integer(2)\n    push(p1)\n    heaviside()\n    multiply()\n    push_integer(-1)\n    add()\n    */\n    push_symbol(SGN);\n    push(p1);\n    return list(2);\n  };\n\n  // shape of tensor\n  Eval_shape = function() {\n    push(cadr(p1));\n    Eval();\n    return shape();\n  };\n\n  shape = function() {\n    var ai, an, i, l1, m1, ndim, ref2, ref3, t;\n    i = 0;\n    ndim = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"transpose: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(ndim);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push_integer(p1.tensor.dim[i]);\n      p2.tensor.elem[i] = pop();\n    }\n    push(p2);\n    return restore();\n  };\n\n  /*\n   Simplify factorials\n\n  The following script\n\n    F(n,k) = k binomial(n,k)\n    (F(n,k) + F(n,k-1)) / F(n+1,k)\n\n  generates\n\n         k! n!             n! (1 - k + n)!              k! n!\n   -------------------- + -------------------- - ----------------------\n   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!\n\n  Simplify each term to get\n\n      k       1 - k + n       1\n   ------- + ----------- - -------\n    1 + n       1 + n       1 + n\n\n  Then simplify the sum to get\n\n      n\n   -------\n    1 + n\n\n  */\n  // simplify factorials term-by-term\n  Eval_simfac = function() {\n    push(cadr(p1));\n    Eval();\n    return simfac();\n  };\n\n  //if 1\n  simfac = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      h = tos;\n      p1 = cdr(p1);\n      while (p1 !== symbol(NIL)) {\n        push(car(p1));\n        simfac_term();\n        p1 = cdr(p1);\n      }\n      add_all(tos - h);\n    } else {\n      push(p1);\n      simfac_term();\n    }\n    return restore();\n  };\n\n  //else\n  /*\n  void\n  simfac(void)\n  {\n    int h\n    save()\n    p1 = pop()\n    if (car(p1) == symbol(ADD)) {\n      h = tos\n      p1 = cdr(p1)\n      while (p1 != symbol(NIL)) {\n        push(car(p1))\n        simfac_term()\n        p1 = cdr(p1)\n      }\n      addk(tos - h)\n      p1 = pop()\n      if (find(p1, symbol(FACTORIAL))) {\n        push(p1)\n        if (car(p1) == symbol(ADD)) {\n          Condense()\n          simfac_term()\n        }\n      }\n    } else {\n      push(p1)\n      simfac_term()\n    }\n    restore()\n  }\n\n  #endif\n   */\n  simfac_term = function() {\n    var doNothing, h;\n    h = 0;\n    save();\n    p1 = pop();\n    // if not a product of factors then done\n    if (car(p1) !== symbol(MULTIPLY)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // push all factors\n    h = tos;\n    p1 = cdr(p1);\n    while (p1 !== symbol(NIL)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    // keep trying until no more to do\n    while (yysimfac(h)) {\n      doNothing = 1;\n    }\n    multiply_all_noexpand(tos - h);\n    return restore();\n  };\n\n  // try all pairs of factors\n  yysimfac = function(h) {\n    var i, j, l1, m1, ref2, ref3, ref4, ref5;\n    i = 0;\n    j = 0;\n    for (i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      p1 = stack[i];\n      for (j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); j = ref4 <= ref5 ? ++m1 : --m1) {\n        if (i === j) {\n          continue;\n        }\n        p2 = stack[j];\n        //  n! / n    ->  (n - 1)!\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {\n          push(cadr(p1));\n          push(one);\n          subtract();\n          factorial();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  n / n!    ->  1 / (n - 1)!\n        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {\n          push(p1);\n          push_integer(-1);\n          add();\n          factorial();\n          reciprocate();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  (n + 1) n!  ->  (n + 1)!\n        if (car(p2) === symbol(FACTORIAL)) {\n          push(p1);\n          push(cadr(p2));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(p1);\n            factorial();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  1 / ((n + 1) n!)  ->  1 / (n + 1)!\n        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(cadr(p1));\n            factorial();\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  (n + 1)! / n!  ->  n + 1\n\n        //  n! / (n + 1)!  ->  1 / (n + 1)\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            stack[i] = cadr(p1);\n            stack[j] = one;\n            return 1;\n          }\n          if (isminusone(p3)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n          if (equaln(p3, 2)) {\n            stack[i] = cadr(p1);\n            push(cadr(p1));\n            push_integer(-1);\n            add();\n            stack[j] = pop();\n            return 1;\n          }\n          if (equaln(p3, -2)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            push(cadr(cadr(p2)));\n            push_integer(-1);\n            add();\n            reciprocate();\n            stack[j] = pop();\n            return 1;\n          }\n        }\n      }\n    }\n    return 0;\n  };\n\n  DEBUG_SIMPLIFY = false;\n\n  Eval_simplify = function() {\n    push(cadr(p1));\n    runUserDefinedSimplifications();\n    Eval();\n    return simplify();\n  };\n\n  runUserDefinedSimplifications = function() {\n    var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;\n    // -----------------------\n    // unfortunately for the time being user\n    // specified simplifications are only\n    // run in things which don't contain\n    // integrals.\n    // Doesn't work yet, could be because of\n    // some clobbering as \"transform\" is called\n    // recursively?\n    if (userSimplificationsInListForm.length !== 0 && !Find(cadr(p1), symbol(INTEGRAL))) {\n      originalexpanding = expanding;\n      expanding = false;\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications passed: \" + stack[tos - 1].toString());\n      }\n      Eval();\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications after eval no expanding: \" + stack[tos - 1].toString());\n      }\n      expanding = originalexpanding;\n      p1 = stack[tos - 1];\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"patterns to be checked: \");\n      }\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        eachSimplification = userSimplificationsInListForm[l1];\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"...\" + eachSimplification);\n        }\n      }\n      atLeastOneSuccessInRouldOfRulesApplications = true;\n      numberOfRulesApplications = 0;\n      while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        atLeastOneSuccessInRouldOfRulesApplications = false;\n        numberOfRulesApplications++;\n        for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n          eachSimplification = userSimplificationsInListForm[m1];\n          success = true;\n          eachConsecutiveRuleApplication = 0;\n          while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            eachConsecutiveRuleApplication++;\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"simplify - tos: \" + tos + \" checking pattern: \" + eachSimplification + \" on: \" + p1);\n            }\n            push_symbol(NIL);\n            success = transform(eachSimplification, true);\n            if (success) {\n              atLeastOneSuccessInRouldOfRulesApplications = true;\n            }\n            p1 = stack[tos - 1];\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"p1 at this stage of simplification: \" + p1);\n            }\n          }\n          if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            stop(\"maximum application of single transformation rule exceeded: \" + eachSimplification);\n          }\n        }\n      }\n      if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        stop(\"maximum application of all transformation rules exceeded \");\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAX = \" + get_binding(symbol(METAX)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAA = \" + get_binding(symbol(METAA)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        return console.log(\"METAB = \" + get_binding(symbol(METAB)));\n      }\n    }\n  };\n\n  // ------------------------\n  simplifyForCodeGeneration = function() {\n    save();\n    runUserDefinedSimplifications();\n    codeGen = true;\n    // in \"codeGen\" mode we completely\n    // eval and simplify the function bodies\n    // because we really want to resolve all\n    // the variables indirections and apply\n    // all the simplifications we can.\n    simplify_main();\n    codeGen = false;\n    return restore();\n  };\n\n  simplify = function() {\n    save();\n    simplify_main();\n    return restore();\n  };\n\n  simplify_main = function() {\n    var args, fbody;\n    p1 = pop();\n    // when we do code generation, we proceed to\n    // fully evaluate and simplify the body of\n    // a function, so we resolve all variables\n    // indirections and we simplify everything\n    // we can given the current assignments.\n    if (codeGen && car(p1) === symbol(FUNCTION)) {\n      fbody = cadr(p1);\n      push(fbody);\n      // let's simplify the body so we give it a\n      // compact form\n      eval();\n      simplify();\n      p3 = pop();\n      // replace the evaled body\n      args = caddr(p1);\n      push_symbol(FUNCTION);\n      push(p3);\n      push(args);\n      list(3);\n      p1 = pop();\n    }\n    if (istensor(p1)) {\n      simplify_tensor();\n      return;\n    }\n    if (Find(p1, symbol(FACTORIAL))) {\n      push(p1);\n      simfac();\n      p2 = pop();\n      push(p1);\n      rationalize();\n      simfac();\n      p3 = pop();\n      if (count(p2) < count(p3)) {\n        p1 = p2;\n      } else {\n        p1 = p3;\n      }\n    }\n    f10();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f10: \" + p1.toString());\n    }\n    f1();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f1: \" + p1.toString());\n    }\n    f2();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f2: \" + p1.toString());\n    }\n    f3();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f3: \" + p1.toString());\n    }\n    f4();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f4: \" + p1.toString());\n    }\n    f5();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f5: \" + p1.toString());\n    }\n    f9();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f9: \" + p1.toString());\n    }\n    simplify_polarRect();\n    if (do_simplify_nested_radicals) {\n      // if there is some de-nesting then\n      // re-run a simplification because\n      // the shape of the expression might\n      // have changed significantly.\n      // e.g. simplify(14^(1/2) - (16 - 4*7^(1/2))^(1/2))\n      // needs some more semplification after the de-nesting.\n      if (simplify_nested_radicals()) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"de-nesting successful into: \" + p1.toString());\n        }\n        push(p1);\n        simplify();\n        return;\n      }\n    }\n    simplify_rectToClock();\n    simplify_rational_expressions();\n    return push(p1);\n  };\n\n  simplify_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1.tensor.elem[i]);\n      simplify();\n      p2.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p2);\n    if (isZeroAtomOrTensor(p2)) {\n      p2 = zero; // null tensor becomes scalar zero\n    }\n    return push(p2);\n  };\n\n  // try rationalizing\n  f1 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // try condensing\n  f2 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    Condense();\n    p2 = pop();\n    if (count(p2) <= count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // this simplifies forms like (A-B) / (B-A)\n  f3 = function() {\n    push(p1);\n    rationalize();\n    negate();\n    rationalize();\n    negate();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f10 = function() {\n    var a, b, carp1, miao, originalexpanding;\n    carp1 = car(p1);\n    miao = cdr(p1);\n    if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {\n      // both operands a transpose?\n      if ((car(car(cdr(p1))) === symbol(TRANSPOSE)) && (car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE))) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"maybe collecting a transpose \" + p1);\n        }\n        a = cadr(car(cdr(p1)));\n        b = cadr(car(cdr(cdr(p1))));\n        if (carp1 === symbol(MULTIPLY)) {\n          push(a);\n          push(b);\n          multiply();\n        } else if (isinnerordot(p1)) {\n          push(b);\n          push(a);\n          inner();\n        }\n        push_integer(1);\n        push_integer(2);\n        originalexpanding = expanding;\n        expanding = false;\n        transpose();\n        expanding = originalexpanding;\n        p2 = pop();\n        if (count(p2) < count(p1)) {\n          p1 = p2;\n        }\n        if (DEBUG_SIMPLIFY) {\n          return console.log(\"collecting a transpose \" + p2);\n        }\n      }\n    }\n  };\n\n  // try expanding denominators\n  f4 = function() {\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    inverse();\n    rationalize();\n    inverse();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // simplifies trig forms\n  simplify_trig = function() {\n    save();\n    p1 = pop();\n    f5();\n    push(p1);\n    return restore();\n  };\n\n  f5 = function() {\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    p2 = p1;\n    trigmode = 1;\n    push(p2);\n    Eval();\n    p3 = pop();\n    trigmode = 2;\n    push(p2);\n    Eval();\n    p4 = pop();\n    trigmode = 0;\n    if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {\n      p3 = p4;\n    }\n    if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {\n      return p1 = p3;\n    }\n  };\n\n  // if it's a sum then try to simplify each term\n  f9 = function() {\n    var oldp1, oldp2;\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push_integer(0);\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      simplify();\n      add();\n      oldp1 = p1;\n      oldp2 = p2;\n      p1 = pop();\n      simplify_rational_expressions();\n      push(p1);\n      p1 = oldp1;\n      p2 = oldp2;\n      p2 = cdr(p2);\n    }\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rational_expressions = function() {\n    var denom, num, polyVar, sasa, theGCD;\n    push(p1);\n    denominator();\n    denom = pop();\n    if (isone(denom)) {\n      return;\n    }\n    push(p1);\n    numerator();\n    num = pop();\n    if (isone(num)) {\n      return;\n    }\n    if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {\n      return;\n    }\n    push(num);\n    push(denom);\n    gcd();\n    push(polyVar);\n    factor();\n    theGCD = pop();\n    // if there are no common factors then\n    // bail\n    if (isone(theGCD)) {\n      return;\n    }\n    push(num);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    push(denom);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    divide();\n    //simplify()\n    Condense();\n    sasa = stack[tos - 1].toString();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // things like 6*(cos(2/9*pi)+i*sin(2/9*pi))\n  // where we have sin and cos, those might start to\n  // look better in clock form i.e.  6*(-1)^(2/9) \n  simplify_rectToClock = function() {\n    //debugger\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    push(p1);\n    Eval();\n    clockform();\n    p2 = pop();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"before simplification clockform: \" + p1 + \" after: \" + p2);\n    }\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_polarRect = function() {\n    push(p1);\n    polarRectAMinusOneBase();\n    Eval();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  polarRectAMinusOneBase = function() {\n    var h;\n    save();\n    p1 = pop();\n    if (isimaginaryunit(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {\n      // base we just said is minus 1\n      push(one);\n      negate();\n      // exponent\n      push(caddr(p1));\n      polarRectAMinusOneBase();\n      power();\n      // try to simplify it using polar and rect\n      polar();\n      rect();\n    } else if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        polarRectAMinusOneBase();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n  };\n\n  nterms = function(p) {\n    if (car(p) !== symbol(ADD)) {\n      return 1;\n    } else {\n      return length(p) - 1;\n    }\n  };\n\n  simplify_nested_radicals = function() {\n    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    push(p1);\n    somethingSimplified = take_care_of_nested_radicals();\n    // in this paragraph we check whether we can collect\n    // common factors without complicating the expression\n    // in particular we want to avoid \n    // collecting radicals like in this case where\n    // we collect sqrt(2):\n    //   2-2^(1/2) into 2^(1/2)*(-1+2^(1/2))\n    // but we do like to collect other non-radicals e.g.\n    //   17/2+3/2*5^(1/2) into 1/2*(17+3*5^(1/2))\n    // so what we do is we count the powers and we check\n    // which version has the least number of them.\n    simplificationWithoutCondense = stack[tos - 1];\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    simplificationWithCondense = pop();\n    //console.log(\"occurrences of powers in \" + simplificationWithoutCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithoutCondense))\n    //console.log(\"occurrences of powers in \" + simplificationWithCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithCondense))\n    if (countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {\n      push(simplificationWithoutCondense);\n    } else {\n      push(simplificationWithCondense);\n    }\n    // we got out result, wrap up\n    p1 = pop();\n    return somethingSimplified;\n  };\n\n  take_care_of_nested_radicals = function() {\n    var A, B, C, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    save();\n    p1 = pop();\n    //console.log(\"take_care_of_nested_radicals p1: \" + p1.toString())\n    if (equal(car(p1), symbol(POWER))) {\n      //console.log(\"ok it's a power \")\n      base = cadr(p1);\n      exponent = caddr(p1);\n      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {\n        //console.log(\"ok there is a radix with a term inside\")\n        firstTerm = cadr(base);\n        push(firstTerm);\n        take_care_of_nested_radicals();\n        pop();\n        secondTerm = caddr(base);\n        push(secondTerm);\n        take_care_of_nested_radicals();\n        pop();\n        //console.log(\"possible double radical term1: \" + firstTerm)\n        //console.log(\"possible double radical term2: \" + secondTerm)\n        numberOfTerms = 0;\n        countingTerms = base;\n        while (cdr(countingTerms) !== symbol(NIL)) {\n          numberOfTerms++;\n          countingTerms = cdr(countingTerms);\n        }\n        //console.log(\"number of terms: \" + numberOfTerms)\n        if (numberOfTerms > 2) {\n          //console.log(\"too many terms under outer radix \")\n          push(p1);\n          restore();\n          return false;\n        }\n        // list here all the factors\n        commonInnerExponent = null;\n        commonBases = [];\n        termsThatAreNotPowers = [];\n        if (car(secondTerm) === symbol(MULTIPLY)) {\n          // product of factors\n          secondTermFactor = cdr(secondTerm);\n          if (iscons(secondTermFactor)) {\n            while (iscons(secondTermFactor)) {\n              //console.log(\"second term factor BIS: \" + car(secondTermFactor).toString())\n              potentialPower = car(secondTermFactor);\n              if (car(potentialPower) === symbol(POWER)) {\n                innerbase = cadr(potentialPower);\n                innerexponent = caddr(potentialPower);\n                if (equalq(innerexponent, 1, 2)) {\n                  if (commonInnerExponent == null) {\n                    commonInnerExponent = innerexponent;\n                    commonBases.push(innerbase);\n                  } else {\n                    if (equal(innerexponent, commonInnerExponent)) {\n                      //console.log(\"common base: \" + innerbase.toString())\n                      commonBases.push(innerbase);\n                    } else {\n\n                    }\n                  }\n                }\n              } else {\n                //console.log(\"no common bases here \")\n                //console.log(\"this one is a power base: \" + innerbase + \" , exponent: \" + innerexponent)\n                termsThatAreNotPowers.push(potentialPower);\n              }\n              secondTermFactor = cdr(secondTermFactor);\n            }\n          }\n        } else if (car(secondTerm) === symbol(POWER)) {\n          innerbase = cadr(secondTerm);\n          innerexponent = caddr(secondTerm);\n          if ((commonInnerExponent == null) && equalq(innerexponent, 1, 2)) {\n            //console.log(\"tackling double radical 2: \" + p1.toString())\n            commonInnerExponent = innerexponent;\n            commonBases.push(innerbase);\n          }\n        }\n        if (commonBases.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        A = firstTerm;\n        //console.log(\"A: \" + A.toString())\n        push_integer(1);\n        for (l1 = 0, len = commonBases.length; l1 < len; l1++) {\n          i = commonBases[l1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"basis with common exponent: \" + i.toString())\n        C = pop();\n        //console.log(\"C: \" + C.toString())\n        push_integer(1);\n        for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {\n          i = termsThatAreNotPowers[m1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"terms that are not powers: \" + i.toString())\n        B = pop();\n        //console.log(\"B: \" + B.toString())\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          negate();\n          push(C);\n          multiply();\n          push(B);\n          divide(); // 4th coeff\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push_integer(3);\n          push(C);\n          multiply(); // 3rd coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(-3);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          multiply();\n          add();\n          add();\n          add();\n        } else if (equalq(exponent, 1, 2)) {\n          push(C); // 3th coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          push_integer(-2);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n        }\n        //console.log(\"whole polynomial: \" + stack[tos-1].toString())\n        push(symbol(SECRETX));\n        recursionLevelNestedRadicalsRemoval++;\n        //console.log(\"invoking roots at recursion level: \" + recursionLevelNestedRadicalsRemoval)\n        roots();\n        recursionLevelNestedRadicalsRemoval--;\n        if (equal(stack[tos - 1], symbol(NIL))) {\n          if (DEBUG_SIMPLIFY) {\n            console.log(\"roots bailed out because of too much recursion\");\n          }\n          pop();\n          push(p1);\n          restore();\n          return false;\n        }\n        //console.log(\"all solutions: \" + stack[tos-1].toString())\n\n        // exclude the solutions with radicals\n        possibleSolutions = [];\n        ref2 = stack[tos - 1].tensor.elem;\n        for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {\n          eachSolution = ref2[n1];\n          if (!Find(eachSolution, symbol(POWER))) {\n            possibleSolutions.push(eachSolution);\n          }\n        }\n        pop(); // popping the tensor with the solutions\n        \n        //console.log(\"possible solutions: \" + possibleSolutions.toString())\n        if (possibleSolutions.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        possibleRationalSolutions = [];\n        realOfpossibleRationalSolutions = [];\n//console.log(\"checking the one with maximum real part \")\n        for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {\n          i = possibleSolutions[o1];\n          push(i);\n          real();\n          yyfloat();\n          possibleRationalSolutions.push(i);\n          realOfpossibleRationalSolutions.push(pop().d);\n        }\n        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));\n        SOLUTION = possibleRationalSolutions[whichRationalSolution];\n        //console.log(\"picked solution: \" + SOLUTION)\n        /*\n        #possibleNewExpressions = []\n        #realOfPossibleNewExpressions = []\n         * pick the solution which cubic root has no radicals\n        lowercase_b = null\n        for SOLUTION in possibleSolutions\n          console.log(\"testing solution: \" + SOLUTION.toString())\n\n          debugger\n          if equalq(exponent,1,3)\n            push(A)\n            push(SOLUTION)\n            push_integer(3)\n            power()\n            push_integer(3)\n            push(C)\n            multiply()\n            push(SOLUTION)\n            multiply()\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,3)\n            power()\n          else if equalq(exponent,1,2)\n            push(A)\n            push(SOLUTION)\n            push_integer(2)\n            power()\n            push(C)\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,2)\n            power()\n          console.log(\"b is: \" + stack[tos-1].toString())\n\n          lowercase_b = pop()\n\n          if !Find(lowercase_b, symbol(POWER))\n            break\n         */\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(3);\n          power();\n          push_integer(3);\n          push(C);\n          multiply();\n          push(SOLUTION);\n          multiply();\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 3);\n          power();\n        } else if (equalq(exponent, 1, 2)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(2);\n          power();\n          push(C);\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 2);\n          power();\n        }\n        //console.log(\"b is: \" + stack[tos-1].toString())\n        lowercase_b = pop();\n        if (lowercase_b == null) {\n          push(p1);\n          restore();\n          return false;\n        }\n        push(lowercase_b);\n        push(SOLUTION);\n        multiply();\n        if (equalq(exponent, 1, 3)) {\n          //console.log(\"a is: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n        } else if (equalq(exponent, 1, 2)) {\n          //console.log(\"a could be: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n          possibleNewExpression = pop();\n          //console.log(\"verifying if  \" + possibleNewExpression + \" is positive\")\n          push(possibleNewExpression);\n          real();\n          yyfloat();\n          possibleNewExpressionValue = pop();\n          if (!isnegativenumber(possibleNewExpressionValue)) {\n            //console.log(\"... it is positive\")\n            push(possibleNewExpression);\n          } else {\n            //console.log(\"... it is NOT positive\")\n            push(lowercase_b);\n            negate();\n            lowercase_b = pop();\n            push(lowercase_a);\n            negate();\n            lowercase_a = pop();\n            push(lowercase_b);\n            push(C);\n            push_rational(1, 2);\n            power();\n            multiply();\n            push(lowercase_a);\n            add();\n            simplify();\n          }\n        }\n        // possibleNewExpression is now at top of stack\n\n        //console.log(\"potential new expression: \" + stack[tos-1].toString())\n        p1 = pop();\n        //newExpression = pop()\n        //debugger\n        //push(newExpression)\n        //real()\n        //yyfloat()\n        //possibleNewExpressions.push(newExpression)\n        //realOfPossibleNewExpressions.push(pop().d)\n\n        //whichExpression = realOfPossibleNewExpressions.indexOf(Math.max.apply(Math, realOfPossibleNewExpressions))\n        //p1 = possibleNewExpressions[whichExpression]\n        //console.log(\"final new expression: \" + p1.toString())\n        push(p1);\n        restore();\n        return true;\n      } else {\n        push(p1);\n        restore();\n        return false;\n      }\n    } else if (iscons(p1)) {\n      h = tos;\n      anyRadicalSimplificationWorked = false;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || take_care_of_nested_radicals();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return anyRadicalSimplificationWorked;\n    } else {\n      push(p1);\n      restore();\n      return false;\n    }\n    throw new Error(\"control flow should never reach here\");\n  };\n\n  // Sine function of numerical and symbolic arguments\n  Eval_sin = function() {\n    //console.log \"sin ---- \"\n    push(cadr(p1));\n    Eval();\n    return sine();\n  };\n\n  //console.log \"sin end ---- \"\n  sine = function() {\n    //console.log \"sine ---- \"\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      // sin of a sum can be further decomposed into\n      //sin(alpha+beta) = sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n      sine_of_angle_sum();\n    } else {\n      sine_of_angle();\n    }\n    return restore();\n  };\n\n  //console.log \"sine end ---- \"\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n\n  // decompose sum sin(alpha+beta) into\n  // sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n  sine_of_angle_sum = function() {\n    //console.log \"sin of angle sum ---- \"\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        sine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        cosine();\n        push(p4);\n        sine();\n        multiply();\n        add();\n        return;\n      }\n      //console.log \"sin of angle sum end ---- \"\n      p2 = cdr(p2);\n    }\n    return sine_of_angle();\n  };\n\n  //console.log \"sin of angle sum end ---- \"\n  sine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCSIN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sin(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // sine function is antisymmetric, sin(-x) = -sin(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      sine();\n      negate();\n      return;\n    }\n    // sin(arctan(x)) = x / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      multiply();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(SIN));\n      push(p1);\n      list(2);\n      return;\n    }\n    // values of some famous angles. Many more here:\n    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 150:\n        return push_rational(1, 2);\n      case 210:\n      case 330:\n        return push_rational(-1, 2);\n      case 45:\n      case 135:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 225:\n      case 315:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 60:\n      case 120:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 240:\n      case 300:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 90:\n        return push_integer(1);\n      case 270:\n        return push_integer(-1);\n      default:\n        push(symbol(SIN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //            exp(x) - exp(-x)\n  //  sinh(x) = ----------------\n  //                   2\n  Eval_sinh = function() {\n    push(cadr(p1));\n    Eval();\n    return ysinh();\n  };\n\n  ysinh = function() {\n    save();\n    yysinh();\n    return restore();\n  };\n\n  yysinh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCSINH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sinh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(SINH);\n    push(p1);\n    return list(2);\n  };\n\n  subst = function() {\n    var expr, i, l1, m1, newExpr, newTensor, oldExpr, ref2, ref3;\n    save();\n    newExpr = pop();\n    oldExpr = pop();\n    if (oldExpr === symbol(NIL) || newExpr === symbol(NIL)) {\n      restore();\n      return;\n    }\n    expr = pop();\n    if (istensor(expr)) {\n      newTensor = alloc_tensor(expr.tensor.nelem);\n      newTensor.tensor.ndim = expr.tensor.ndim;\n      for (i = l1 = 0, ref2 = expr.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        newTensor.tensor.dim[i] = expr.tensor.dim[i];\n      }\n      for (i = m1 = 0, ref3 = expr.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n        push(expr.tensor.elem[i]);\n        push(oldExpr);\n        push(newExpr);\n        subst();\n        newTensor.tensor.elem[i] = pop();\n        check_tensor_dimensions(newTensor);\n      }\n      push(newTensor);\n    } else if (equal(expr, oldExpr)) {\n      push(newExpr);\n    } else if (iscons(expr)) {\n      push(car(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      push(cdr(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      cons();\n    } else {\n      push(expr);\n    }\n    return restore();\n  };\n\n  // 'sum' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the sum at the top of the stack\n  Eval_sum = function() {\n    var body, i, indexVariable, j, k, l1, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(indexVariable);\n    push_integer(0);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      add();\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, p4);\n  };\n\n  // Tangent function of numerical and symbolic arguments\n  Eval_tan = function() {\n    push(cadr(p1));\n    Eval();\n    return tangent();\n  };\n\n  tangent = function() {\n    save();\n    yytangent();\n    return restore();\n  };\n\n  yytangent = function() {\n    var d, n;\n    n = 0;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tan(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // tan function is antisymmetric, tan(-x) = -tan(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      tangent();\n      negate();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(TAN));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 210:\n        push_rational(1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 330:\n        push_rational(-1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 45:\n      case 225:\n        return push_integer(1);\n      case 135:\n      case 315:\n        return push_integer(-1);\n      case 60:\n      case 240:\n        push_integer(3);\n        push_rational(1, 2);\n        return power();\n      case 120:\n      case 300:\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return negate();\n      default:\n        push(symbol(TAN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //             exp(2 x) - 1\n  //  tanh(x) = --------------\n  //             exp(2 x) + 1\n  Eval_tanh = function() {\n    var d;\n    d = 0.0;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (car(p1) === symbol(ARCTANH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tanh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(TANH);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_taylor = function() {\n    // 1st arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // 2nd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    // 3rd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(24); // default number of terms\n    } else {\n      push(p2);\n    }\n    // 4th arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0); // default expansion point\n    } else {\n      push(p2);\n    }\n    return taylor();\n  };\n\n  //define F p1\n  //define X p2\n  //define N p3\n  //define A p4\n  //define C p5\n  taylor = function() {\n    var i, k, l1, ref2;\n    i = 0;\n    k = 0;\n    save();\n    p4 = pop();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p3);\n    k = pop_integer();\n    if (isNaN(k)) {\n      push_symbol(TAYLOR);\n      push(p1);\n      push(p2);\n      push(p3);\n      push(p4);\n      list(5);\n      restore();\n      return;\n    }\n    push(p1);\n    push(p2);\n    push(p4);\n    subst();\n    Eval();\n    push_integer(1);\n    p5 = pop();\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(p2);\n      derivative();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        break;\n      }\n      push(p5);\n      push(p2);\n      push(p4);\n      subtract();\n      multiply();\n      p5 = pop();\n      push(p1);\n      push(p2);\n      push(p4);\n      subst();\n      Eval();\n      push(p5);\n      multiply();\n      push_integer(i);\n      factorial();\n      divide();\n      add();\n    }\n    return restore();\n  };\n\n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* tensor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n  Tensors are a strange in-between of matrices and \"computer\"\n  rectangular data structures.\n\n  Tensors, unlike matrices, and like rectangular data structures,\n  can have an arbitrary number of dimensions (rank), although a tensor with\n  rank zero is just a scalar.\n\n  Tensors, like matrices and unlike many computer rectangular data structures,\n  must be \"contiguous\" i.e. have no empty spaces within its size, and \"uniform\",\n  i.e. each element must have the same shape and hence the same rank.\n\n  Also tensors have necessarily to make a distinction between row vectors,\n  column vectors (which have a rank of 2) and uni-dimensional vectors (rank 1).\n  They look very similar but they are fundamentally different.\n\n  Tensors are 1-indexed, as per general math notation, and like Fortran,\n  Lua, Mathematica, SASL, MATLAB, Julia, Erlang and APL.\n\n  Tensors with elements that are also tensors get promoted to a higher rank\n  , this is so we can represent and get the rank of a matrix correctly.\n  Example:\n  Start with a tensor of rank 1 with 2 elements (i.e. shape: 2)\n  if you put in both its elements another 2 tensors\n  of rank 1 with 2 elements (i.e. shape: 2)\n  then the result is a tensor of rank 2 with shape 2,2\n  i.e. the dimension of a tensor at all times must be\n  the number of nested tensors in it.\n  Also, all tensors must be \"uniform\" i.e. they must be accessed\n  uniformly, which means that all existing elements of a tensor\n  must be contiguous and have the same shape.\n  Implication of it all is that you can't put arbitrary\n  tensors inside tensors (like you would do to represent block matrices)\n  Rather, all tensors inside tensors must have same shape (and hence, rank)\n\n  Limitations\n  -----------\n  n.a.\n\n  Implementation info\n  -------------------\n  Tensors are implemented...\n\n  */\n  // Called from the \"eval\" module to evaluate tensor elements.\n  // p1 points to the tensor operand.\n  Eval_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n\n    //---------------------------------------------------------------------\n\n    //  create a new tensor for the result\n\n    //---------------------------------------------------------------------\n    check_tensor_dimensions(p1);\n    nelem = p1.tensor.nelem;\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    //---------------------------------------------------------------------\n\n    //  b = Eval(a)\n\n    //---------------------------------------------------------------------\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    check_tensor_dimensions(p2);\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      //console.log \"push/pop: pushing element a of \" + i\n      push(a[i]);\n      Eval();\n      //console.log \"push/pop: popping into element b of \" + i\n      b[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    //---------------------------------------------------------------------\n\n    //  push the result\n\n    //---------------------------------------------------------------------\n    push(p2);\n    return promote_tensor();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Add tensors\n\n  //  Input:    Operands on stack\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  tensor_plus_tensor = function() {\n    var a, b, c, i, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    save();\n    p2 = pop();\n    p1 = pop();\n    // are the dimension lists equal?\n    ndim = p1.tensor.ndim;\n    if (ndim !== p2.tensor.ndim) {\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {\n        push(symbol(NIL));\n        restore();\n        return;\n      }\n    }\n    // create a new tensor for the result\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    // c = a + b\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = n1 = 0, ref4 = nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      push(a[i]);\n      push(b[i]);\n      add();\n      c[i] = pop();\n    }\n    // push the result\n    push(p3);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  careful not to reorder factors\n\n  //-----------------------------------------------------------------------------\n  tensor_times_scalar = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  scalar_times_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p2.tensor.ndim;\n    nelem = p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p2.tensor.dim[i];\n    }\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      push(a[i]);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  check_tensor_dimensions = function(p) {\n    if (p.tensor.nelem !== p.tensor.elem.length) {\n      console.log(\"something wrong in tensor dimensions\");\n      debugger;\n    }\n  };\n\n  is_square_matrix = function(p) {\n    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_tensor = function() {\n    var a, b, c, i, j, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    if (ndim + 1 >= MAXDIM) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    p3 = alloc_tensor(nelem * p2.tensor.nelem);\n    p3.tensor.ndim = ndim + 1;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p3.tensor.dim[ndim] = p2.tensor.dim[0];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      for (j = n1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n        push(a[i]);\n        push(b[j]);\n        derivative();\n        c[i * p2.tensor.nelem + j] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of scalar\n\n  //-----------------------------------------------------------------------------\n  d_scalar_tensor = function() {\n    var a, b, i, l1, ref2;\n    //U **a, **b\n    p3 = alloc_tensor(p2.tensor.nelem);\n    p3.tensor.ndim = 1;\n    p3.tensor.dim[0] = p2.tensor.dim[0];\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = l1 = 0, ref2 = p2.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(a[i]);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Derivative of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_scalar = function() {\n    var a, b, i, l1, m1, ref2, ref3;\n    i = 0;\n    //U **a, **b\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  compare_tensors = function(p1, p2) {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    if (p1.tensor.ndim < p2.tensor.ndim) {\n      return -1;\n    }\n    if (p1.tensor.ndim > p2.tensor.ndim) {\n      return 1;\n    }\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n        return -1;\n      }\n      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n        return 1;\n      }\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        continue;\n      }\n      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Raise a tensor to a power\n\n  //  Input:    p1  tensor\n\n  //      p2  exponent\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  power_tensor = function() {\n    var i, k, l1, m1, n, ref2, ref3, results;\n    i = 0;\n    k = 0;\n    n = 0;\n    // first and last dims must be equal\n    k = p1.tensor.ndim - 1;\n    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p2);\n    n = pop_integer();\n    if (isNaN(n)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (n === 0) {\n      if (p1.tensor.ndim !== 2) {\n        stop(\"power(tensor,0) with tensor rank not equal to 2\");\n      }\n      n = p1.tensor.dim[0];\n      p1 = alloc_tensor(n * n);\n      p1.tensor.ndim = 2;\n      p1.tensor.dim[0] = n;\n      p1.tensor.dim[1] = n;\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        p1.tensor.elem[n * i + i] = one;\n      }\n      check_tensor_dimensions(p1);\n      push(p1);\n      return;\n    }\n    if (n < 0) {\n      n = -n;\n      push(p1);\n      inv();\n      p1 = pop();\n    }\n    push(p1);\n    results = [];\n    for (i = m1 = 1, ref3 = n; (1 <= ref3 ? m1 < ref3 : m1 > ref3); i = 1 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      inner();\n      if (isZeroAtomOrTensor(stack[tos - 1])) {\n        break;\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  copy_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p1 = pop();\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return restore();\n  };\n\n  // Tensors with elements that are also tensors get promoted to a higher rank.\n  promote_tensor = function() {\n    var i, j, k, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    j = 0;\n    k = 0;\n    nelem = 0;\n    ndim = 0;\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = p1.tensor.elem[0];\n    for (i = l1 = 1, ref2 = p1.tensor.nelem; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      if (!compatible(p2, p1.tensor.elem[i])) {\n        stop(\"Cannot promote tensor due to inconsistent tensor components.\");\n      }\n    }\n    if (!istensor(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"tensor rank > \" + MAXDIM);\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (j = n1 = 0, ref4 = p2.tensor.ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n      p3.tensor.dim[i + j] = p2.tensor.dim[j];\n    }\n    k = 0;\n    for (i = o1 = 0, ref5 = p1.tensor.nelem; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      p2 = p1.tensor.elem[i];\n      for (j = q1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); j = 0 <= ref6 ? ++q1 : --q1) {\n        p3.tensor.elem[k++] = p2.tensor.elem[j];\n      }\n    }\n    check_tensor_dimensions(p2);\n    check_tensor_dimensions(p3);\n    push(p3);\n    return restore();\n  };\n\n  compatible = function(p, q) {\n    var i, l1, ref2;\n    if (!istensor(p) && !istensor(q)) {\n      return 1;\n    }\n    if (!istensor(p) || !istensor(q)) {\n      return 0;\n    }\n    if (p.tensor.ndim !== q.tensor.ndim) {\n      return 0;\n    }\n    for (i = l1 = 0, ref2 = p.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p.tensor.dim[i] !== q.tensor.dim[i]) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // If the number of args is odd then the last arg is the default result.\n  // Works like a switch statement. Could also be used for piecewise\n  // functions? TODO should probably be called \"switch\"?\n  Eval_test = function() {\n    var checkResult, orig;\n    orig = p1;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p1) === symbol(NIL)) {\n        push(car(p1));\n        Eval();\n        return;\n      }\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));\n      if (checkResult == null) {\n        // we couldn't determine the result\n        // of a test. This means we can't conclude\n        // anything about the result of the\n        // overall test, so we must bail\n        // with the unevalled test\n        push(orig);\n        return;\n      } else if (checkResult) {\n        // test succesful, we found out output\n        push(cadr(p1));\n        Eval();\n        return;\n      } else {\n        // test unsuccessful, continue to the\n        // next pair of test,value\n        p1 = cddr(p1);\n      }\n    }\n    // no test matched and there was no\n    // catch-all case, so we return zero.\n    return push_integer(0);\n  };\n\n  // we test A==B by first subtracting and checking if we symbolically\n  // get zero. If not, we evaluate to float and check if we get a zero.\n  // If we get another NUMBER then we know they are different.\n  // If we get something else, then we don't know and we return the\n  // unaveluated test, which is the same as saying \"maybe\".\n  Eval_testeq = function() {\n    var checkResult, orig, subtractionResult;\n    // first try without simplifyng both sides\n    orig = p1;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    subtract();\n    subtractionResult = pop();\n    // OK so we are doing something tricky here\n    // we are using isZeroLikeOrNonZeroLikeOrUndetermined to check if the result\n    // is zero or not zero or unknown.\n    // isZeroLikeOrNonZeroLikeOrUndetermined has some routines\n    // to determine the zero-ness/non-zero-ness or\n    // undeterminate-ness of things so we use\n    // that here and down below.\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // we didn't get a simple numeric result but\n    // let's try again after doing\n    // a simplification on both sides\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // if we didn't get to a number then we\n    // don't know whether the quantities are\n    // different so do nothing\n    return push(orig);\n  };\n\n  // Relational operators expect a numeric result for operand difference.\n  Eval_testge = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison >= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testgt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison > 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testle = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison <= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testlt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison < 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // not definition\n  Eval_not = function() {\n    var checkResult, wholeAndExpression;\n    wholeAndExpression = p1;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // inconclusive test on predicate\n      return push(wholeAndExpression);\n    } else if (checkResult) {\n      // true -> false\n      return push_integer(0);\n    } else {\n      // false -> true\n      return push_integer(1);\n    }\n  };\n\n  /* and =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Logical-and of predicate expressions.\n\n  */\n  // and definition\n  Eval_and = function() {\n    var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;\n    wholeAndExpression = p1;\n    andPredicates = cdr(wholeAndExpression);\n    somePredicateUnknown = false;\n    while (iscons(andPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        andPredicates = cdr(andPredicates);\n      } else if (checkResult) {\n        // found a true, move on to the next predicate\n        andPredicates = cdr(andPredicates);\n      } else if (!checkResult) {\n        // found a false, enough to falsify everything and return\n        push_integer(0);\n        return;\n      }\n    }\n    // We checked all the predicates and none of them\n    // was false. So they were all either true or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns true.\n    if (somePredicateUnknown) {\n      return push(wholeAndExpression);\n    } else {\n      return push_integer(1);\n    }\n  };\n\n  // or definition\n  Eval_or = function() {\n    var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;\n    wholeOrExpression = p1;\n    orPredicates = cdr(wholeOrExpression);\n    somePredicateUnknown = false;\n    while (iscons(orPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        orPredicates = cdr(orPredicates);\n      } else if (checkResult) {\n        // found a true, enough to return true\n        push_integer(1);\n        return;\n      } else if (!checkResult) {\n        // found a false, move on to the next predicate\n        orPredicates = cdr(orPredicates);\n      }\n    }\n    // We checked all the predicates and none of them\n    // was true. So they were all either false or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns false.\n    if (somePredicateUnknown) {\n      return push(wholeOrExpression);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // use subtract for cases like A < A + 1\n\n  // TODO you could be smarter here and\n  // simplify both sides only in the case\n  // of \"relational operator: cannot determine...\"\n  // a bit like we do in Eval_testeq\n  cmp_args = function() {\n    var t;\n    t = 0;\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    p1 = pop();\n    // try floating point if necessary\n    if (p1.k !== NUM && p1.k !== DOUBLE) {\n      push(p1);\n      yyfloat();\n      Eval();\n      p1 = pop();\n    }\n    //console.log \"comparison: \" + p1.toString()\n    if (isZeroAtomOrTensor(p1)) {\n      //console.log \"comparison isZero \"\n      return 0;\n    }\n    switch (p1.k) {\n      case NUM:\n        if (MSIGN(p1.q.a) === -1) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      case DOUBLE:\n        //console.log \"comparison p1.d: \" + p1.d\n        if (p1.d < 0.0) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      default:\n        //console.log \"comparison is null\"\n        t = null;\n    }\n    return t;\n  };\n\n  /*\n  Transform an expression using a pattern. The\n  pattern can come from the integrals table or\n  the user-defined patterns.\n\n  The expression and free variable are on the stack.\n\n  The argument s is a null terminated list of transform rules.\n\n  For example, see the itab (integrals table)\n\n  Internally, the following symbols are used:\n\n    F  input expression\n\n    X  free variable, i.e. F of X\n\n    A  template expression\n\n    B  result expression\n\n    C  list of conditional expressions\n\n  Puts the final expression on top of stack\n  (whether it's transformed or not) and returns\n  true is successful, false if not.\n\n  */\n  // p1 and p2 are tmps\n\n  //define F p3\n  //define X p4\n  //define A p5\n  //define B p6\n  //define C p7\n  transform = function(s, generalTransform) {\n    var bookmarkTosToPrintDecomps, eachTransformEntry, i, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;\n    transform_h = 0;\n    save();\n    p1 = null;\n    p4 = pop(); // X i.e. free variable\n    p3 = pop(); // F i.e. input expression\n    if (DEBUG) {\n      console.log(\"         !!!!!!!!!   transform on: \" + p3);\n    }\n    saveMetaBindings();\n    set_binding(symbol(METAX), p4);\n    // put constants in F(X) on the stack\n    transform_h = tos;\n    push_integer(1);\n    push(p3);\n    push(p4);\n    polyform();\n    push(p4);\n    bookmarkTosToPrintDecomps = tos - 2;\n    decomp(generalTransform);\n    numberOfDecomps = tos - bookmarkTosToPrintDecomps;\n    if (DEBUG) {\n      console.log(\"  \" + numberOfDecomps + \" decomposed elements ====== \");\n      for (i = l1 = 0, ref2 = numberOfDecomps; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        console.log(\"  decomposition element \" + i + \": \" + stack[tos - 1 - i]);\n      }\n    }\n    transformationSuccessful = false;\n    if (generalTransform) {\n      if (!isNumericAtom(p3)) {\n        theTransform = s;\n        if (DEBUG) {\n          console.log(\"applying transform: \" + theTransform);\n        }\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + theTransform);\n        }\n        push(theTransform);\n        // replacements of meta variables. Note that we don't\n        // use scan_meta because the pattern is not a string\n        // that we have to parse, it's a tree already.\n        // replace a_ with METAA in the passed transformation\n        push(symbol(SYMBOL_A_UNDERSCORE));\n        push(symbol(METAA));\n        subst();\n        // replace b_ with METAB in the passed transformation\n        push(symbol(SYMBOL_B_UNDERSCORE));\n        push(symbol(METAB));\n        subst();\n        // replace x_ with METAX in the passed transformation\n        push(symbol(SYMBOL_X_UNDERSCORE));\n        push(symbol(METAX));\n        subst();\n        p1 = pop();\n        p5 = car(p1);\n        if (DEBUG) {\n          console.log(\"template expression: \" + p5);\n        }\n        p6 = cadr(p1);\n        p7 = cddr(p1);\n        /*\n        p5 = p1.tensor.elem[0]\n        p6 = p1.tensor.elem[1]\n        for i in [2..(p1.tensor.elem.length-1)]\n          push p1.tensor.elem[i]\n        list(p1.tensor.elem.length - 2)\n        p7 = pop()\n        */\n        if (f_equals_a(transform_h, generalTransform)) {\n          // successful transformation,\n          // transformed result is in p6\n          transformationSuccessful = true;\n        } else {\n          // the match failed but perhaps we can match\n          // something lower down in the tree, so\n          // let's recurse the tree\n          if (DEBUG) {\n            console.log(\"p3 at this point: \" + p3);\n          }\n          transformedTerms = [];\n          if (DEBUG) {\n            console.log(\"car(p3): \" + car(p3));\n          }\n          restTerm = p3;\n          if (iscons(restTerm)) {\n            transformedTerms.push(car(p3));\n            restTerm = cdr(p3);\n          }\n          while (iscons(restTerm)) {\n            secondTerm = car(restTerm);\n            restTerm = cdr(restTerm);\n            if (DEBUG) {\n              console.log(\"tos before recursive transform: \" + tos);\n            }\n            push(secondTerm);\n            push_symbol(NIL);\n            if (DEBUG) {\n              console.log(\"testing: \" + secondTerm);\n            }\n            //if (secondTerm+\"\") == \"eig(A x,transpose(A x))()\"\n            //  debugger\n            if (DEBUG) {\n              console.log(\"about to try to simplify other term: \" + secondTerm);\n            }\n            success = transform(s, generalTransform);\n            transformationSuccessful = transformationSuccessful || success;\n            transformedTerms.push(pop());\n            if (DEBUG) {\n              console.log(\"tried to simplify other term: \" + secondTerm + \" ...successful?: \" + success + \" ...transformed: \" + transformedTerms[transformedTerms.length - 1]);\n            }\n          }\n          // recreate the tree we were passed,\n          // but with all the terms being transformed\n          if (transformedTerms.length !== 0) {\n            for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {\n              i = transformedTerms[m1];\n              push(i);\n            }\n            list(transformedTerms.length);\n            p6 = pop(); // \"integrals\" mode\n          }\n        }\n      }\n    } else {\n      for (n1 = 0, len1 = s.length; n1 < len1; n1++) {\n        eachTransformEntry = s[n1];\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + eachTransformEntry);\n          if ((eachTransformEntry + \"\").indexOf(\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\") !== -1) {\n            debugger;\n          }\n        }\n        if (eachTransformEntry) {\n          scan_meta(eachTransformEntry);\n          p1 = pop();\n          p5 = cadr(p1);\n          p6 = caddr(p1);\n          p7 = cdddr(p1);\n          /*\n          p5 = p1.tensor.elem[0]\n          p6 = p1.tensor.elem[1]\n          for i in [2..(p1.tensor.elem.length-1)]\n            push p1.tensor.elem[i]\n          list(p1.tensor.elem.length - 2)\n          p7 = pop()\n          */\n          if (f_equals_a(transform_h, generalTransform)) {\n            // there is a successful transformation,\n            // transformed result is in p6\n            transformationSuccessful = true;\n            break;\n          }\n        }\n      }\n    }\n    moveTos(transform_h);\n    if (transformationSuccessful) {\n      //console.log \"transformation successful\"\n      // a transformation was successful\n      push(p6);\n      Eval();\n      p1 = pop();\n      //console.log \"...into: \" + p1\n      transformationSuccessful = true;\n    } else {\n      // transformations failed\n      if (generalTransform) {\n        // result = original expression\n        p1 = p3;\n      } else {\n        p1 = symbol(NIL);\n      }\n    }\n    restoreMetaBindings();\n    push(p1);\n    restore();\n    return transformationSuccessful;\n  };\n\n  saveMetaBindings = function() {\n    push(get_binding(symbol(METAA)));\n    push(get_binding(symbol(METAB)));\n    return push(get_binding(symbol(METAX)));\n  };\n\n  restoreMetaBindings = function() {\n    set_binding(symbol(METAX), pop());\n    set_binding(symbol(METAB), pop());\n    return set_binding(symbol(METAA), pop());\n  };\n\n  // search for a METAA and METAB such that F = A\n  f_equals_a = function(h, generalTransform) {\n    var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;\n    fea_i = 0;\n    fea_j = 0;\n    for (fea_i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); fea_i = ref2 <= ref3 ? ++l1 : --l1) {\n      set_binding(symbol(METAA), stack[fea_i]);\n      if (DEBUG) {\n        console.log(\"  binding METAA to \" + get_binding(symbol(METAA)));\n      }\n      for (fea_j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); fea_j = ref4 <= ref5 ? ++m1 : --m1) {\n        set_binding(symbol(METAB), stack[fea_j]);\n        if (DEBUG) {\n          console.log(\"  binding METAB to \" + get_binding(symbol(METAB)));\n        }\n        // now test all the conditions (it's an and between them)\n        p1 = p7;\n        while (iscons(p1)) {\n          push(car(p1));\n          Eval();\n          p2 = pop();\n          if (isZeroAtomOrTensor(p2)) {\n            break;\n          }\n          p1 = cdr(p1);\n        }\n        if (iscons(p1)) {\n          // conditions are not met,\n          // skip to the next binding of metas\n          continue;\n        }\n        push(p3);\n        if (DEBUG) {\n          console.log(\"about to evaluate template expression: \" + p5 + \" binding METAA to \" + get_binding(symbol(METAA)) + \" and binding METAB to \" + get_binding(symbol(METAB)) + \" and binding METAX to \" + get_binding(symbol(METAX)));\n        }\n        push(p5);\n        if (generalTransform) {\n          originalexpanding = expanding;\n          expanding = false;\n        }\n        Eval();\n        if (generalTransform) {\n          expanding = originalexpanding;\n        }\n        if (DEBUG) {\n          console.log(\"  comparing \" + stack[tos - 1] + \" to: \" + stack[tos - 2]);\n        }\n        subtract();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          if (DEBUG) {\n            console.log(\"binding METAA to \" + get_binding(symbol(METAA)));\n            console.log(\"binding METAB to \" + get_binding(symbol(METAB)));\n            console.log(\"binding METAX to \" + get_binding(symbol(METAX)));\n            console.log(\"comparing \" + p3 + \" to: \" + p5);\n          }\n          return 1; // yes\n        }\n      }\n    }\n    return 0; // no\n  };\n\n  // Transpose tensor indices\n  Eval_transpose = function() {\n    push(cadr(p1));\n    Eval();\n    // add default params if they\n    // have not been passed\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return transpose();\n  };\n\n  transpose = function() {\n    var a, accumulator, ai, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, l1, m, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    // by default p3 is 2 and p2 is 1\n    p3 = pop(); // index to be transposed\n    p2 = pop(); // other index to be transposed\n    p1 = pop(); // what needs to be transposed\n    \n    // a transposition just goes away when\n    // applied to a scalar\n    if (isNumericAtom(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // transposition goes away for identity matrix\n    if ((isplusone(p2) && isplustwo(p3)) || (isplusone(p3) && isplustwo(p2))) {\n      if (isidentitymatrix(p1)) {\n        push(p1);\n        restore();\n        return;\n      }\n    }\n    // a transposition just goes away when\n    // applied to another transposition with\n    // the same columns to be switched\n    if (istranspose(p1)) {\n      innerTranspSwitch1 = car(cdr(cdr(p1)));\n      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));\n      if ((equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2)) || (equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2)) || ((equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL))) && ((isplusone(p3) && isplustwo(p2)) || (isplusone(p2) && isplustwo(p3))))) {\n        push(car(cdr(p1)));\n        restore();\n        return;\n      }\n    }\n    // if operand is a sum then distribute\n    // (if we are in expanding mode)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      push(zero);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // if operand is a multiplication then distribute\n    // (if we are in expanding mode)\n    if (expanding && ismultiply(p1)) {\n      p1 = cdr(p1);\n      push(one);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        multiply();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // distribute the transpose of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse as per tranpose rules.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push([car(p1), p2, p3]);\n        p1 = cdr(p1);\n      }\n      for (eachEntry = m1 = ref3 = accumulator.length - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); eachEntry = ref3 <= 0 ? ++m1 : --m1) {\n        push(accumulator[eachEntry][0]);\n        push(accumulator[eachEntry][1]);\n        push(accumulator[eachEntry][2]);\n        transpose();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        //stop(\"transpose: tensor expected, 1st arg is not a tensor\")\n        push_symbol(TRANSPOSE);\n        push(p1);\n        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {\n          push(p2);\n          push(p3);\n          list(4);\n        } else {\n          list(2);\n        }\n        restore();\n        return;\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    // is it a vector?\n    // so here it's something curious - note how vectors are\n    // not really special two-dimensional matrices, but rather\n    // 1-dimension objects (like tensors can be). So since\n    // they have one dimension, transposition has no effect.\n    // (as opposed as if they were special two-dimensional\n    // matrices)\n    // see also Ran Pan, Tensor Transpose and Its Properties. CoRR abs/1411.1503 (2014)\n    if (ndim === 1) {\n      push(p1);\n      restore();\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (l < 1 || l > ndim || m < 1 || m > ndim) {\n      stop(\"transpose: index out of range\");\n    }\n    l--;\n    m--;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = n1 = 0, ref4 = ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p2.tensor.dim[l] = p1.tensor.dim[m];\n    p2.tensor.dim[m] = p1.tensor.dim[l];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n// init tensor index\n    for (i = o1 = 0, ref5 = ndim; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n// copy components from a to b\n    for (i = q1 = 0, ref6 = nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); i = 0 <= ref6 ? ++q1 : --q1) {\n      // swap indices l and m\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      k = 0;\n      for (j = r1 = 0, ref7 = ndim; (0 <= ref7 ? r1 < ref7 : r1 > ref7); j = 0 <= ref7 ? ++r1 : --r1) {\n        k = (k * an[j]) + ai[j];\n      }\n      // swap indices back\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      b[k] = a[i];\n// increment tensor index\n\n      // Suppose the tensor dimensions are 2 and 3.\n// Then the tensor index ai increments as follows:\n// 00 -> 01\n// 01 -> 02\n// 02 -> 10\n// 10 -> 11\n// 11 -> 12\n// 12 -> 00\n      for (j = s1 = ref8 = ndim - 1; (ref8 <= 0 ? s1 <= 0 : s1 >= 0); j = ref8 <= 0 ? ++s1 : --s1) {\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  // Evaluate a user defined function\n\n  //define F p3 # F is the function body\n  //define A p4 # A is the formal argument list\n  //define B p5 # B is the calling argument list\n  //define S p6 # S is the argument substitution list\n\n  // we got here because there was a function invocation and\n  // it's not been parsed (and consequently tagged) as any\n  // system function.\n  // So we are dealing with another function.\n  // The function could be actually defined, or not yet,\n  // so we'll deal with both cases.\n  /* d =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x\n\n  General description\n  -------------------\n  Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].\n\n  */\n  Eval_user_function = function() {\n    var bodyAndFormalArguments, h;\n    // Use \"derivative\" instead of \"d\" if there is no user function \"d\"\n    if (DEBUG) {\n      console.log(\"Eval_user_function evaluating: \" + car(p1));\n    }\n    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {\n      Eval_derivative();\n      return;\n    }\n    // normally car(p1) is a symbol with the function name\n    // but it could be something that has to be\n    // evaluated to get to the function definition instead\n    // (e.g. the function is an element of an array)\n    // so we do an eval to sort it all out. \n    push(car(p1));\n    Eval();\n    // we expect to find either the body and\n    // formula arguments, OR, if the function\n    // has not been defined yet, then the\n    // function will just contain its own name, as\n    // all undefined variables do.\n    bodyAndFormalArguments = pop();\n    if (isNumericAtom(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.\");\n    } else if (istensor(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.\");\n    } else if (isstr(bodyAndFormalArguments)) {\n      stop(\"expected function, found string instead.\");\n    }\n    p3 = car(cdr(bodyAndFormalArguments)); // p3 is function body F\n    // p4 is the formal argument list\n    // that is also contained here in the FUNCTION node \n    p4 = car(cdr(cdr(bodyAndFormalArguments)));\n    p5 = cdr(p1);\n    // next check is whether evaluation did nothing, so the function is undefined\n    if ((car(bodyAndFormalArguments) !== symbol(FUNCTION)) || (bodyAndFormalArguments === car(p1))) { // p3 is F\n      // leave everything as it was and return\n      h = tos;\n      push(bodyAndFormalArguments);\n      p1 = p5;\n      while (iscons(p1)) {\n        push(car(p1));\n        Eval();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      return;\n    }\n    // Create the argument substitution list p6(S)\n    p1 = p4;\n    p2 = p5;\n    h = tos;\n    while (iscons(p1) && iscons(p2)) {\n      push(car(p1));\n      push(car(p2));\n      // why explicitly Eval the parameters when\n      // the body of the function is\n      // evalled anyways? Commenting it out. All tests pass...\n      //Eval()\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    list(tos - h);\n    p6 = pop();\n    push(p3);\n    if (iscons(p6)) { // p6 is S\n      push(p6);\n      rewrite_args();\n    }\n    //console.log \"rewritten body: \" + stack[tos-1]\n    return Eval();\n  };\n\n  // Rewrite by expanding symbols that contain args\n  rewrite_args = function() {\n    var h, n;\n    n = 0;\n    save();\n    // subst. list which is a list\n    // where each consecutive pair\n    // is what needs to be substituted and with what\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1)) {\n      n = rewrite_args_tensor();\n      restore();\n      return n;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      if (car(p1) === car(p2)) {\n        // rewrite a function in\n        // the body with the one\n        // passed from the paramaters\n        push_symbol(EVAL);\n        push(car(cdr(p2)));\n        list(2);\n      } else {\n        // if there is no match\n        // then no substitution necessary\n        push(car(p1));\n      }\n      // continue recursively to\n      // rewrite the rest of the body\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        n += rewrite_args();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return n;\n    }\n    if (!issymbol(p1)) {\n      push(p1);\n      restore();\n      return 0;\n    }\n    // Here we are in a symbol case\n    // so we need to substitute\n\n    // Check if there is a direct match\n    // of symbols right away\n    p3 = p2;\n    while (iscons(p3)) {\n      if (p1 === car(p3)) {\n        push(cadr(p3));\n        restore();\n        return 1;\n      }\n      p3 = cddr(p3);\n    }\n    // Get the symbol's content, if _that_\n    // matches then do the substitution\n    p3 = get_binding(p1);\n    push(p3);\n    if (p1 !== p3) {\n      push(p2);\n      n = rewrite_args();\n      if (n === 0) {\n        pop();\n        push(p1); // restore if not rewritten with arg\n      }\n    }\n    restore();\n    return n;\n  };\n\n  rewrite_args_tensor = function() {\n    var i, l1, n, ref2;\n    n = 0;\n    i = 0;\n    push(p1);\n    copy_tensor();\n    p1 = pop();\n    for (i = l1 = 0, ref2 = p1.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      n += rewrite_args();\n      p1.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    push(p1);\n    return n;\n  };\n\n  Eval_zero = function() {\n    var i, k, l1, m, m1, n, ref2, ref3;\n    i = 0;\n    k = [];\n    m = 0;\n    n = 0;\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      k[i] = 0;\n    }\n    m = 1;\n    n = 0;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      i = pop_integer();\n      if (i < 1 || isNaN(i)) {\n        // if the input is nonsensical\n        // just return 0\n        push(zero);\n        return;\n      }\n      m *= i;\n      k[n++] = i;\n      p2 = cdr(p2);\n    }\n    if (n === 0) {\n      push(zero);\n      return;\n    }\n    p1 = alloc_tensor(m);\n    p1.tensor.ndim = n;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p1.tensor.dim[i] = k[i];\n    }\n    return push(p1);\n  };\n\n  allocatedId = 0;\n\n  alloc_tensor = function(nelem) {\n    var i, l1, p, ref2;\n    i = 0;\n    p = new U();\n    p.k = TENSOR;\n    p.tensor = new tensor();\n    p.tensor.nelem = nelem;\n    for (i = l1 = 0, ref2 = nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p.tensor.elem[i] = zero;\n    }\n    p.tensor.allocatedId = allocatedId;\n    //if allocatedId == 9\n    //  debugger\n    allocatedId++;\n    check_tensor_dimensions(p);\n    return p;\n  };\n\n  /*\n  // garbage collector\n\n  void\n  gc(void)\n  {\n    int i, j\n    U *p\n\n    // tag everything\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++)\n        p[j].tag = 1\n    }\n\n    // untag what's used\n\n    untag(p0)\n    untag(p1)\n    untag(p2)\n    untag(p3)\n    untag(p4)\n    untag(p5)\n    untag(p6)\n    untag(p7)\n    untag(p8)\n    untag(p9)\n\n    untag(one)\n    untag(zero)\n    untag(imaginaryunit)\n\n    for (i = 0; i < NSYM; i++) {\n      untag(binding[i])\n      untag(arglist[i])\n    }\n\n    for (i = 0; i < tos; i++)\n      untag(stack[i])\n\n    for (i = (int) (frame - stack); i < TOS; i++)\n      untag(stack[i])\n\n    // collect everything that's still tagged\n\n    free_count = 0\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++) {\n        if (p[j].tag == 0)\n          continue\n        // still tagged so it's unused, put on free list\n        switch (p[j].k) {\n        case TENSOR:\n          free(p[j].u.tensor)\n          break\n        case STR:\n          free(p[j].u.str)\n          break\n        case NUM:\n          mfree(p[j].u.q.a)\n          mfree(p[j].u.q.b)\n          break\n        }\n        p[j].k = CONS; // so no double free occurs above\n        p[j].u.cons.cdr = free_list\n        free_list = p + j\n        free_count++\n      }\n    }\n  }\n\n  void\n  untag(U *p)\n  {\n    int i\n\n    if (iscons(p)) {\n      do {\n        if (p->tag == 0)\n          return\n        p->tag = 0\n        untag(p->u.cons.car)\n        p = p->u.cons.cdr\n      } while (iscons(p))\n      untag(p)\n      return\n    }\n\n    if (p->tag) {\n      p->tag = 0\n       if (istensor(p)) {\n        for (i = 0; i < p->u.tensor->nelem; i++)\n          untag(p->u.tensor->elem[i])\n      }\n    }\n  }\n\n  // get memory for 100,000 atoms\n\n  void\n  alloc_mem(void)\n  {\n    int i\n    U *p\n    if (mcount == M)\n      return\n    p = (U *) malloc(N * sizeof (struct U))\n    if (p == NULL)\n      return\n    mem[mcount++] = p\n    for (i = 0; i < N; i++) {\n      p[i].k = CONS; // so no free in gc\n      p[i].u.cons.cdr = p + i + 1\n    }\n    p[N - 1].u.cons.cdr = free_list\n    free_list = p\n    free_count += N\n  }\n\n  void\n  print_mem_info(void)\n  {\n    char buf[100]\n\n    sprintf(buf, \"%d blocks (%d bytes/block)\\n\", N * mcount, (int) sizeof (U))\n    printstr(buf)\n\n    sprintf(buf, \"%d free\\n\", free_count)\n    printstr(buf)\n\n    sprintf(buf, \"%d used\\n\", N * mcount - free_count)\n    printstr(buf)\n  }\n  */\n  // returns 1 if expr p contains expr q, otherweise returns 0\n  Find = function(p, q) {\n    var i, l1, ref2;\n    i = 0;\n    if (equal(p, q)) {\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (Find(p.tensor.elem[i], q)) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (Find(car(p), q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (-1)^(something (but disregard\n  // imaginary units which are in the form (-1)^(1/2))\n  findPossibleClockForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (isimaginaryunit(p)) {\n      return 0;\n    }\n    if (car(p) === symbol(POWER) && !isinteger(caddr(p1))) {\n      if (Find(cadr(p), imaginaryunit)) {\n        //console.log \"found i^fraction \" + p\n        return 1;\n      }\n    }\n    if (car(p) === symbol(POWER) && equaln(cadr(p), -1) && !isinteger(caddr(p1))) {\n      //console.log \"found -1^fraction in \" + p\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleClockForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleClockForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (e)^(i something)\n  findPossibleExponentialForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (car(p) === symbol(POWER) && cadr(p) === symbol(E)) {\n      return Find(caddr(p), imaginaryunit);\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleExponentialForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleExponentialForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  $.Find = Find;\n\n  init = function() {\n    var i, l1, ref2;\n    //debugger\n    //console.log \"DOING AN INIT ========================================================================\"\n    i = 0;\n    flag = 0;\n    reset_after_error();\n    chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n    if (flag) { // already initted\n      return;\n    }\n    flag = 1;\n// total clearout of symbol table\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      isSymbolReclaimable[i] = false;\n    }\n    return defn();\n  };\n\n  defn_str = [\n    \"version=\\\"\" + version + \"\\\"\",\n    \"e=exp(1)\",\n    \"i=sqrt(-1)\",\n    \"autoexpand=1\",\n    \"assumeRealVariables=1\",\n    \"trange=[-pi,pi]\",\n    \"xrange=[-10,10]\",\n    \"yrange=[-10,10]\",\n    \"last=0\",\n    \"trace=0\",\n    \"forceFixedPrintout=1\",\n    \"maxFixedPrintoutDigits=6\",\n    \"printLeaveEAlone=1\",\n    \"printLeaveXAlone=0\",\n    // cross definition\n    \"cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]\",\n    // curl definition\n    \"curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]\",\n    // div definition\n    \"div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)\",\n    // Note that we use the mathematics / Javascript / Mathematica\n    // convention that \"log\" is indeed the natural logarithm.\n\n    // In engineering, biology, astronomy, \"log\" can stand instead\n    // for the \"common\" logarithm i.e. base 10. Also note that Google\n    // calculations use log for the common logarithm.\n    \"ln(x)=log(x)\"\n  ];\n\n  defn = function() {\n    var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;\n    p0 = symbol(NIL);\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    p3 = symbol(NIL);\n    p4 = symbol(NIL);\n    p5 = symbol(NIL);\n    p6 = symbol(NIL);\n    p7 = symbol(NIL);\n    p8 = symbol(NIL);\n    p9 = symbol(NIL);\n    std_symbol(\"abs\", ABS);\n    std_symbol(\"add\", ADD);\n    std_symbol(\"adj\", ADJ);\n    std_symbol(\"and\", AND);\n    std_symbol(\"approxratio\", APPROXRATIO);\n    std_symbol(\"arccos\", ARCCOS);\n    std_symbol(\"arccosh\", ARCCOSH);\n    std_symbol(\"arcsin\", ARCSIN);\n    std_symbol(\"arcsinh\", ARCSINH);\n    std_symbol(\"arctan\", ARCTAN);\n    std_symbol(\"arctanh\", ARCTANH);\n    std_symbol(\"arg\", ARG);\n    std_symbol(\"atomize\", ATOMIZE);\n    std_symbol(\"besselj\", BESSELJ);\n    std_symbol(\"bessely\", BESSELY);\n    std_symbol(\"binding\", BINDING);\n    std_symbol(\"binomial\", BINOMIAL);\n    std_symbol(\"ceiling\", CEILING);\n    std_symbol(\"check\", CHECK);\n    std_symbol(\"choose\", CHOOSE);\n    std_symbol(\"circexp\", CIRCEXP);\n    std_symbol(\"clear\", CLEAR);\n    std_symbol(\"clearall\", CLEARALL);\n    std_symbol(\"clearpatterns\", CLEARPATTERNS);\n    std_symbol(\"clock\", CLOCK);\n    std_symbol(\"coeff\", COEFF);\n    std_symbol(\"cofactor\", COFACTOR);\n    std_symbol(\"condense\", CONDENSE);\n    std_symbol(\"conj\", CONJ);\n    std_symbol(\"contract\", CONTRACT);\n    std_symbol(\"cos\", COS);\n    std_symbol(\"cosh\", COSH);\n    std_symbol(\"decomp\", DECOMP);\n    std_symbol(\"defint\", DEFINT);\n    std_symbol(\"deg\", DEGREE);\n    std_symbol(\"denominator\", DENOMINATOR);\n    std_symbol(\"det\", DET);\n    std_symbol(\"derivative\", DERIVATIVE);\n    std_symbol(\"dim\", DIM);\n    std_symbol(\"dirac\", DIRAC);\n    std_symbol(\"divisors\", DIVISORS);\n    std_symbol(\"do\", DO);\n    std_symbol(\"dot\", DOT);\n    std_symbol(\"draw\", DRAW);\n    std_symbol(\"dsolve\", DSOLVE);\n    std_symbol(\"erf\", ERF);\n    std_symbol(\"erfc\", ERFC);\n    std_symbol(\"eigen\", EIGEN);\n    std_symbol(\"eigenval\", EIGENVAL);\n    std_symbol(\"eigenvec\", EIGENVEC);\n    std_symbol(\"eval\", EVAL);\n    std_symbol(\"exp\", EXP);\n    std_symbol(\"expand\", EXPAND);\n    std_symbol(\"expcos\", EXPCOS);\n    std_symbol(\"expsin\", EXPSIN);\n    std_symbol(\"factor\", FACTOR);\n    std_symbol(\"factorial\", FACTORIAL);\n    std_symbol(\"factorpoly\", FACTORPOLY);\n    std_symbol(\"filter\", FILTER);\n    std_symbol(\"float\", FLOATF);\n    std_symbol(\"floor\", FLOOR);\n    std_symbol(\"for\", FOR);\n    std_symbol(\"function\", FUNCTION);\n    std_symbol(\"Gamma\", GAMMA);\n    std_symbol(\"gcd\", GCD);\n    std_symbol(\"hermite\", HERMITE);\n    std_symbol(\"hilbert\", HILBERT);\n    std_symbol(\"imag\", IMAG);\n    std_symbol(\"component\", INDEX);\n    std_symbol(\"inner\", INNER);\n    std_symbol(\"integral\", INTEGRAL);\n    std_symbol(\"inv\", INV);\n    std_symbol(\"invg\", INVG);\n    std_symbol(\"isinteger\", ISINTEGER);\n    std_symbol(\"isprime\", ISPRIME);\n    std_symbol(\"laguerre\", LAGUERRE);\n    //  std_symbol(\"laplace\", LAPLACE)\n    std_symbol(\"lcm\", LCM);\n    std_symbol(\"leading\", LEADING);\n    std_symbol(\"legendre\", LEGENDRE);\n    std_symbol(\"log\", LOG);\n    std_symbol(\"lookup\", LOOKUP);\n    std_symbol(\"mod\", MOD);\n    std_symbol(\"multiply\", MULTIPLY);\n    std_symbol(\"not\", NOT);\n    std_symbol(\"nroots\", NROOTS);\n    std_symbol(\"number\", NUMBER);\n    std_symbol(\"numerator\", NUMERATOR);\n    std_symbol(\"operator\", OPERATOR);\n    std_symbol(\"or\", OR);\n    std_symbol(\"outer\", OUTER);\n    std_symbol(\"pattern\", PATTERN);\n    std_symbol(\"patternsinfo\", PATTERNSINFO);\n    std_symbol(\"polar\", POLAR);\n    std_symbol(\"power\", POWER);\n    std_symbol(\"prime\", PRIME);\n    std_symbol(\"print\", PRINT);\n    std_symbol(\"print2dascii\", PRINT2DASCII);\n    std_symbol(\"printcomputer\", PRINTFULL);\n    std_symbol(\"printlatex\", PRINTLATEX);\n    std_symbol(\"printlist\", PRINTLIST);\n    std_symbol(\"printhuman\", PRINTPLAIN);\n    std_symbol(\"printLeaveEAlone\", PRINT_LEAVE_E_ALONE);\n    std_symbol(\"printLeaveXAlone\", PRINT_LEAVE_X_ALONE);\n    std_symbol(\"product\", PRODUCT);\n    std_symbol(\"quote\", QUOTE);\n    std_symbol(\"quotient\", QUOTIENT);\n    std_symbol(\"rank\", RANK);\n    std_symbol(\"rationalize\", RATIONALIZE);\n    std_symbol(\"real\", REAL);\n    std_symbol(\"rect\", YYRECT);\n    std_symbol(\"roots\", ROOTS);\n    std_symbol(\"round\", ROUND);\n    std_symbol(\"equals\", SETQ);\n    std_symbol(\"sgn\", SGN);\n    std_symbol(\"silentpattern\", SILENTPATTERN);\n    std_symbol(\"simplify\", SIMPLIFY);\n    std_symbol(\"sin\", SIN);\n    std_symbol(\"sinh\", SINH);\n    std_symbol(\"shape\", SHAPE);\n    std_symbol(\"sqrt\", SQRT);\n    std_symbol(\"stop\", STOP);\n    std_symbol(\"subst\", SUBST);\n    std_symbol(\"sum\", SUM);\n    std_symbol(\"symbolsinfo\", SYMBOLSINFO);\n    std_symbol(\"tan\", TAN);\n    std_symbol(\"tanh\", TANH);\n    std_symbol(\"taylor\", TAYLOR);\n    std_symbol(\"test\", TEST);\n    std_symbol(\"testeq\", TESTEQ);\n    std_symbol(\"testge\", TESTGE);\n    std_symbol(\"testgt\", TESTGT);\n    std_symbol(\"testle\", TESTLE);\n    std_symbol(\"testlt\", TESTLT);\n    std_symbol(\"transpose\", TRANSPOSE);\n    std_symbol(\"unit\", UNIT);\n    std_symbol(\"zero\", ZERO);\n    std_symbol(\"nil\", NIL);\n    std_symbol(\"autoexpand\", AUTOEXPAND);\n    std_symbol(\"bake\", BAKE);\n    std_symbol(\"assumeRealVariables\", ASSUME_REAL_VARIABLES);\n    std_symbol(\"last\", LAST);\n    std_symbol(\"lastprint\", LAST_PRINT);\n    std_symbol(\"last2dasciiprint\", LAST_2DASCII_PRINT);\n    std_symbol(\"lastfullprint\", LAST_FULL_PRINT);\n    std_symbol(\"lastlatexprint\", LAST_LATEX_PRINT);\n    std_symbol(\"lastlistprint\", LAST_LIST_PRINT);\n    std_symbol(\"lastplainprint\", LAST_PLAIN_PRINT);\n    std_symbol(\"trace\", TRACE);\n    std_symbol(\"forceFixedPrintout\", FORCE_FIXED_PRINTOUT);\n    std_symbol(\"maxFixedPrintoutDigits\", MAX_FIXED_PRINTOUT_DIGITS);\n    std_symbol(\"~\", YYE); // tilde so sort puts it after other symbols\n    std_symbol(\"$DRAWX\", DRAWX); // special purpose internal symbols\n    std_symbol(\"$METAA\", METAA);\n    std_symbol(\"$METAB\", METAB);\n    std_symbol(\"$METAX\", METAX);\n    std_symbol(\"$SECRETX\", SECRETX);\n    std_symbol(\"version\", VERSION);\n    std_symbol(\"pi\", PI);\n    std_symbol(\"a\", SYMBOL_A);\n    std_symbol(\"b\", SYMBOL_B);\n    std_symbol(\"c\", SYMBOL_C);\n    std_symbol(\"d\", SYMBOL_D);\n    std_symbol(\"i\", SYMBOL_I);\n    std_symbol(\"j\", SYMBOL_J);\n    std_symbol(\"n\", SYMBOL_N);\n    std_symbol(\"r\", SYMBOL_R);\n    std_symbol(\"s\", SYMBOL_S);\n    std_symbol(\"t\", SYMBOL_T);\n    std_symbol(\"x\", SYMBOL_X);\n    std_symbol(\"y\", SYMBOL_Y);\n    std_symbol(\"z\", SYMBOL_Z);\n    std_symbol(\"I\", SYMBOL_IDENTITY_MATRIX);\n    std_symbol(\"a_\", SYMBOL_A_UNDERSCORE);\n    std_symbol(\"b_\", SYMBOL_B_UNDERSCORE);\n    std_symbol(\"x_\", SYMBOL_X_UNDERSCORE);\n    std_symbol(\"$C1\", C1);\n    std_symbol(\"$C2\", C2);\n    std_symbol(\"$C3\", C3);\n    std_symbol(\"$C4\", C4);\n    std_symbol(\"$C5\", C5);\n    std_symbol(\"$C6\", C6);\n    defineSomeHandyConstants();\n    // don't add all these functions to the\n    // symbolsDependencies, clone the original\n    originalCodeGen = codeGen;\n    codeGen = false;\n    for (defn_i = l1 = 0, ref2 = defn_str.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); defn_i = 0 <= ref2 ? ++l1 : --l1) {\n      definitionOfInterest = defn_str[defn_i];\n      scan(definitionOfInterest);\n      if (DEBUG) {\n        console.log(\"... evaling \" + definitionOfInterest);\n        console.log(\"top of stack:\");\n        console.log(print_list(stack[tos - 1]));\n      }\n      Eval();\n      pop();\n    }\n    // restore the symbol dependencies as they were before.\n    return codeGen = originalCodeGen;\n  };\n\n  defineSomeHandyConstants = function() {\n    zero = new_integer(0);\n    one = new_integer(1);\n    push_double(1.0);\n    one_as_double = pop();\n    // i is the square root of -1 i.e. -1 ^ 1/2\n    push_symbol(POWER);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_integer(-1);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_rational(1, 2);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    list(3);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    return imaginaryunit = pop(); // must be untagged in gc\n  };\n\n  // Bignum compare\n\n  //  returns\n\n  //  -1    a < b\n\n  //  0    a = b\n\n  //  1    a > b\n  mcmp = function(a, b) {\n    return a.compare(b);\n  };\n\n  // a is a bigint, n is a normal int\n  mcmpint = function(a, n) {\n    var b, t;\n    b = bigInt(n);\n    t = mcmp(a, b);\n    return t;\n  };\n\n  strcmp = function(str1, str2) {\n    if (str1 === str2) {\n      return 0;\n    } else if (str1 > str2) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  doubleToReasonableString = function(d) {\n    var maxFixedPrintoutDigits, stringRepresentation;\n    // when generating code, print out\n    // the standard JS Number printout\n    if (codeGen) {\n      return \"\" + d;\n    }\n    if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {\n      stringRepresentation = \"\" + d;\n      // manipulate the string so that it can be parsed by\n      // Algebrite (something like 1.23e-123 wouldn't cut it because\n      // that would be parsed as 1.23*e - 123)\n      if (printMode === PRINTMODE_LATEX) {\n        // 1.0\\mathrm{e}{-10} looks much better than the plain 1.0e-10\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"\\\\mathrm{e}{$1}\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0\\mathrm{e}{-10}\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0\\\\mathrm{e}{$2}\");\n        }\n      } else {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"*10^($1)\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0e-10\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0*10^($2)\");\n        }\n      }\n    } else {\n      push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));\n      maxFixedPrintoutDigits = pop_integer();\n      //console.log \"maxFixedPrintoutDigits: \" + maxFixedPrintoutDigits\n      //console.log \"type: \" + typeof(maxFixedPrintoutDigits)\n      //console.log \"toFixed: \" + d.toFixed(maxFixedPrintoutDigits)\n      stringRepresentation = \"\" + d.toFixed(maxFixedPrintoutDigits);\n      // remove any trailing zeroes after the dot\n      // see https://stackoverflow.com/questions/26299160/using-regex-how-do-i-remove-the-trailing-zeros-from-a-decimal-number\n      stringRepresentation = stringRepresentation.replace(/(\\.\\d*?[1-9])0+$/gm, \"$1\");\n      // in case there are only zeroes after the dot, removes the dot too\n      stringRepresentation = stringRepresentation.replace(/\\.0+$/gm, \"\");\n      // we actually want to give a hint to user that\n      // it's a double, so add a trailing \".0\" if there\n      // is no decimal point\n      if (stringRepresentation.indexOf(\".\") === -1) {\n        stringRepresentation += \".0\";\n      }\n      if (parseFloat(stringRepresentation) !== d) {\n        stringRepresentation = d.toFixed(maxFixedPrintoutDigits) + \"...\";\n      }\n    }\n    return stringRepresentation;\n  };\n\n  // does nothing\n  clear_term = function() {};\n\n  // s is a string here anyways\n  isspace = function(s) {\n    if (s == null) {\n      return false;\n    }\n    return s === ' ' || s === '\\t' || s === '\\n' || s === '\\v' || s === '\\f' || s === '\\r';\n  };\n\n  isdigit = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return /^\\d+$/.test(str);\n  };\n\n  isalpha = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z]/) === -1;\n  };\n\n  isalphaOrUnderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z_]/) === -1;\n  };\n\n  isunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return str.search(/_/) === -1;\n  };\n\n  isalnumorunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return isalphaOrUnderscore(str) || isdigit(str);\n  };\n\n  count = function(p) {\n    var n;\n    if (iscons(p)) {\n      n = 0;\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  // this probably works out to be\n  // more general than just counting symbols, it can\n  // probably count instances of anything you pass as\n  // first argument but didn't try it.\n  countOccurrencesOfSymbol = function(needle, p) {\n    var n;\n    n = 0;\n    if (iscons(p)) {\n      while (iscons(p)) {\n        n += countOccurrencesOfSymbol(needle, car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (equal(needle, p)) {\n        n = 1;\n      }\n    }\n    return n;\n  };\n\n  // returns the total number of elements\n  // in an expression\n  countsize = function(p) {\n    var i, l1, n, ref2;\n    n = 0;\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        n += p.tensor.elem[i];\n      }\n    } else if (iscons(p)) {\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  //jmp_buf stop_return, draw_stop_return\n\n  // s is a string here\n  stop = function(s) {\n    var message;\n    //if (draw_flag == 2)\n    //  longjmp(draw_stop_return, 1)\n    //else\n    errorMessage += \"Stop: \";\n    errorMessage += s;\n    //debugger\n    message = errorMessage;\n    errorMessage = '';\n    moveTos(0);\n    throw new Error(message);\n  };\n\n  \n  //longjmp(stop_return, 1)\n\n  // Figuring out dependencies is key to automatically\n  // generating a method signature when generating JS code\n  // from algebrite scripts.\n  // This is important because the user can keep using normal Algebrite\n  // scripting without special notations.\n  // Basically the process consists of figuring out\n  // the \"ground variables\" that are needed to compute each variable.\n  // Now there are two ways of doing this:\n  //   * at parse time\n  //   * after running the scripts\n  // Doing it at parse time means that we can't track simplifications\n  // canceling-out some variables for example. But on the other side\n  // it's very quick and the user can somehow see what the signature is\n  // going to look like (assuming tha code is rather simple), or anyways\n  // is going to easily make sense of the generated signature.\n  // Doing it after execution on the other hand would allow us to see\n  // if some variable cancel-out. But if variables cancel out then\n  // they might do so according to some run-time behaviour that the user\n  // might struggle to keep track of.\n  // So the effort for the user to make sense of the signature in the first case\n  // is similar to the effort of keeping tab of types in a typed language.\n  // While in the second case the effort is similar to running the\n  // code and simplifications in her head.\n\n  // If we just want to compute the dependencies, we don't need to do\n  // anything costly, we don't \"run\" the code and we don't simplify\n  // the code. Just finding the plain dependencies\n  // TODO change the name of this function, as it doesn't just find the\n  // dependencies. It also runs it and generates the JS code.\n  findDependenciesInScript = function(stringToBeParsed, dontGenerateCode) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t1, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;\n    if (DEBUG) {\n      console.log(\"stringToBeParsed: \" + stringToBeParsed);\n    }\n    timeStartFromAlgebra = new Date().getTime();\n    inited = true;\n    codeGen = true;\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    symbolsInExpressionsWithoutAssignments = [];\n    patternHasBeenFound = false;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    n = 0;\n    // we are going to store the dependencies _of the block as a whole_\n    // so all affected variables in the whole block are lumped\n    // together, and same for the variable that affect those, we\n    // lump them all together.\n    dependencyInfo = {\n      affectsVariables: [],\n      affectedBy: []\n    };\n    stringToBeRun = stringToBeParsed;\n    // parse the input. This collects the\n    // dependency information\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n        if (DEBUG) {\n          console.log(\"findDependenciesInScript: scanning\");\n        }\n        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));\n        if (DEBUG) {\n          console.log(\"scanned\");\n        }\n        pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      indexOfPartRemainingToBeParsed += n;\n    }\n    testableString = \"\";\n    // print out all local dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"all local dependencies ----------------\");\n    }\n    testableString += \"All local dependencies: \";\n    for (key in symbolsDependencies) {\n      value = symbolsDependencies[key];\n      if (DEBUG) {\n        console.log(\"variable \" + key + \" depends on: \");\n      }\n      dependencyInfo.affectsVariables.push(key);\n      testableString += \" variable \" + key + \" depends on: \";\n      for (l1 = 0, len = value.length; l1 < len; l1++) {\n        i = value[l1];\n        if (DEBUG) {\n          console.log(\"    \" + i);\n        }\n        if (i[0] !== \"'\") {\n          dependencyInfo.affectedBy.push(i);\n        }\n        testableString += i + \", \";\n      }\n      testableString += \"; \";\n    }\n    testableString += \". \";\n    // print out the symbols with re-assignments:\n    if (DEBUG) {\n      console.log(\"Symbols with reassignments ----------------\");\n    }\n    testableString += \"Symbols with reassignments: \";\n    for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {\n      key = symbolsHavingReassignments[m1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // print out the symbols that appear in expressions without assignments\n    if (DEBUG) {\n      console.log(\"Symbols in expressions without assignments ----------------\");\n    }\n    testableString += \"Symbols in expressions without assignments: \";\n    for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {\n      key = symbolsInExpressionsWithoutAssignments[n1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // ALL Algebrite code is affected by any pattern changing\n    dependencyInfo.affectedBy.push(\"PATTERN_DEPENDENCY\");\n    if (patternHasBeenFound) {\n      dependencyInfo.affectsVariables.push(\"PATTERN_DEPENDENCY\");\n      testableString += \" - PATTERN_DEPENDENCY inserted - \";\n    }\n    // print out all global dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"All dependencies recursively ----------------\");\n    }\n    testableString += \"All dependencies recursively: \";\n    scriptEvaluation = [\"\", \"\"];\n    generatedCode = \"\";\n    readableSummaryOfGeneratedCode = \"\";\n    if (errorMessage === \"\" && !dontGenerateCode) {\n      try {\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n        scriptEvaluation = run(stringToBeParsed, true);\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        init();\n      }\n      if (errorMessage === \"\") {\n        for (key in symbolsDependencies) {\n          codeGen = true;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          codeGen = false;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" depends on: \");\n          }\n          testableString += \" variable \" + key + \" depends on: \";\n          recursedDependencies = [];\n          variablesWithCycles = [];\n          cyclesDescriptions = [];\n          recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);\n          for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {\n            i = variablesWithCycles[o1];\n            if (DEBUG) {\n              console.log(\"    --> cycle through \" + i);\n            }\n          }\n          for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {\n            i = recursedDependencies[q1];\n            if (DEBUG) {\n              console.log(\"    \" + i);\n            }\n            testableString += i + \", \";\n          }\n          testableString += \"; \";\n          for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {\n            i = cyclesDescriptions[r1];\n            testableString += \" \" + i + \", \";\n          }\n          if (DEBUG) {\n            console.log(\"  code generation:\" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          // we really want to make an extra effort\n          // to generate simplified code, so\n          // run a \"simplify\" on the content of each\n          // variable that we are generating code for.\n          // Note that the variable\n          // will still point to un-simplified structures,\n          // we only simplify the generated code.\n          push(get_binding(usr_symbol(key)));\n          // Since we go and simplify all variables we meet,\n          // we have to replace each variable passed as a parameter\n          // with something entirely new, so that there is no chance\n          // that it might evoke previous values in the external scope\n          // as in this case:\n          //  a = 2\n          //  f(a) = a+1+b\n          // we don't want 'a' in the body of f to be simplified to 2\n          // There are two cases: 1) the variable actually was already in\n          // the symbol table, in which case there is going to be this new\n          // one prepended with AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE, and\n          // we'll have to remove up this variable later.\n          // OR 2) the variable wasn't already in the symbol table, in which\n          // case we directly create this one, which means that we'll have\n          // to rename it later to the correct name without the prepended\n          // part.\n          replacementsFrom = [];\n          replacementsTo = [];\n          for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {\n            eachDependency = recursedDependencies[s1];\n            if (eachDependency[0] === \"'\") {\n              deQuotedDep = eachDependency.substring(1);\n              originalUserSymbol = usr_symbol(deQuotedDep);\n              newUserSymbol = usr_symbol(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\" + deQuotedDep);\n              replacementsFrom.push(originalUserSymbol);\n              replacementsTo.push(newUserSymbol);\n              push(originalUserSymbol);\n              push(newUserSymbol);\n              subst();\n              if (DEBUG) {\n                console.log(\"after substitution: \" + stack[tos - 1]);\n              }\n            }\n          }\n          try {\n            simplifyForCodeGeneration();\n          } catch (error1) {\n            error = error1;\n            if (PRINTOUTRESULT) {\n              console.log(error);\n            }\n            errorMessage = error + \"\";\n            //debugger\n            init();\n          }\n          for (indexOfEachReplacement = t1 = 0, ref2 = replacementsFrom.length; (0 <= ref2 ? t1 < ref2 : t1 > ref2); indexOfEachReplacement = 0 <= ref2 ? ++t1 : --t1) {\n            //console.log \"replacing back \" + replacementsTo[indexOfEachReplacement] + \" into: \" + replacementsFrom[indexOfEachReplacement]\n            push(replacementsTo[indexOfEachReplacement]);\n            push(replacementsFrom[indexOfEachReplacement]);\n            subst();\n          }\n          clearRenamedVariablesToAvoidBindingToExternalScope();\n          if (errorMessage === \"\") {\n            toBePrinted = pop();\n            // we have to get all the variables used on the right side\n            // here. I.e. to print the arguments it's better to look at the\n            // actual method body after simplification.\n            userVariablesMentioned = [];\n            collectUserSymbols(toBePrinted, userVariablesMentioned);\n            allReturnedPlainStrings = \"\";\n            allReturnedLatexStrings = \"\";\n            codeGen = true;\n            generatedBody = toBePrinted.toString();\n            codeGen = false;\n            origPrintMode = printMode;\n            printMode = PRINTMODE_LATEX;\n            bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();\n            printMode = origPrintMode;\n            if (variablesWithCycles.indexOf(key) !== -1) {\n              generatedCode += \"// \" + key + \" is part of a cyclic dependency, no code generated.\";\n              readableSummaryOfGeneratedCode += \"#\" + key + \" is part of a cyclic dependency, no code generated.\";\n            } else {\n              /*\n               * using this paragraph instead of the following one\n               * creates methods signatures that\n               * are slightly less efficient\n               * i.e. variables compare even if they are\n               * simplified away.\n               * In theory these signatures are more stable, but\n               * in practice signatures vary quite a bit anyways\n               * depending on previous assignments for example,\n               * so it's unclear whether going for stability\n               * is sensible at all..\n              if recursedDependencies.length != 0\n                parameters = \"(\"\n                for i in recursedDependencies\n                  if i.indexOf(\"'\") != 0\n                    parameters += i + \", \"\n                  else\n                    if recursedDependencies.indexOf(i.substring(1)) == -1\n                      parameters += i.substring(1) + \", \"\n               */\n              // remove all native functions from the\n              // parameters as well.\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x + \"\") === -1;\n              });\n              // remove the variable that are not in the dependency list\n              // i.e. only allow the variables that are in the dependency list\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return recursedDependencies.indexOf(x + \"\") !== -1 || recursedDependencies.indexOf(\"\\'\" + x + \"\") !== -1;\n              });\n              if (userVariablesMentioned.length !== 0) {\n                parameters = \"(\";\n                for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {\n                  i = userVariablesMentioned[u1];\n                  if (i.printname !== key) {\n                    parameters += i.printname + \", \";\n                  }\n                }\n                // eliminate the last \", \" for printout clarity\n                parameters = parameters.replace(/, $/gm, \"\");\n                parameters += \")\";\n                generatedCode += key + \" = function \" + parameters + \" { return ( \" + generatedBody + \" ); }\";\n                readableSummaryOfGeneratedCode += key + parameters + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              } else {\n                generatedCode += key + \" = \" + generatedBody + \";\";\n                readableSummaryOfGeneratedCode += key + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              }\n            }\n            generatedCode += \"\\n\";\n            readableSummaryOfGeneratedCode += \"\\n\";\n            if (DEBUG) {\n              console.log(\"    \" + generatedCode);\n            }\n          }\n        }\n      }\n    }\n    // eliminate the last new line\n    generatedCode = generatedCode.replace(/\\n$/gm, \"\");\n    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\\n$/gm, \"\");\n    // cleanup\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    patternHasBeenFound = false;\n    symbolsInExpressionsWithoutAssignments = [];\n    if (DEBUG) {\n      console.log(\"testable string: \" + testableString);\n    }\n    if (TIMING_DEBUGS) {\n      console.log(\"findDependenciesInScript time for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];\n  };\n\n  recursiveDependencies = function(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {\n    var cyclesDescription, i, k, l1, len, len1, m1, ref2;\n    variablesAlreadyFleshedOut.push(variableToBeChecked);\n    // recursive dependencies can only be descended if the variable is not bound to a parameter\n    if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {\n      if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf(\"'\" + variableToBeChecked) !== -1) {\n        if (DEBUG) {\n          console.log(\"can't keep following the chain of \" + variableToBeChecked + \" because it's actually a variable bound to a parameter\");\n        }\n        if (arrayWhereDependenciesWillBeAdded.indexOf(\"'\" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n          arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n        }\n        return arrayWhereDependenciesWillBeAdded;\n      }\n    }\n    chainBeingChecked.push(variableToBeChecked);\n    if (symbolsDependencies[variableToBeChecked] == null) {\n      // end case: the passed variable has no dependencies\n      // so there is nothing else to do\n      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n      }\n      return arrayWhereDependenciesWillBeAdded;\n    } else {\n      ref2 = symbolsDependencies[variableToBeChecked];\n      // recursion case: we have to dig deeper\n      for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n        i = ref2[l1];\n        // check that there is no recursion in dependencies\n        // we do that by keeping a list of variables that\n        // have already been \"fleshed-out\". If we encounter\n        // any of those \"fleshed-out\" variables while\n        // fleshing out, then there is a cycle \n        if (chainBeingChecked.indexOf(i) !== -1) {\n          if (DEBUG) {\n            console.log(\"  found cycle:\");\n          }\n          cyclesDescription = \"\";\n          for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {\n            k = chainBeingChecked[m1];\n            if (variablesWithCycles.indexOf(k) === -1) {\n              variablesWithCycles.push(k);\n            }\n            if (DEBUG) {\n              console.log(k + \" --> \");\n            }\n            cyclesDescription += k + \" --> \";\n          }\n          if (DEBUG) {\n            console.log(\" ... then \" + i + \" again\");\n          }\n          cyclesDescription += \" ... then \" + i + \" again\";\n          cyclesDescriptions.push(cyclesDescription);\n          //if DEBUG then console.log \"    --> cycle through \" + i\n          // we want to flesh-out i but it's already been\n          // fleshed-out, just add it to the variables\n          // with cycles and move on\n          // todo refactor this, there are two copies of these two lines\n          if (variablesWithCycles.indexOf(i) === -1) {\n            variablesWithCycles.push(i);\n          }\n        } else {\n          // flesh-out i recursively\n          recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);\n          chainBeingChecked.pop();\n        }\n      }\n      //variablesAlreadyFleshedOut.pop()\n      return arrayWhereDependenciesWillBeAdded;\n    }\n  };\n\n  // parses and runs one statement/expression at a time\n  inited = false;\n\n  latexErrorSign = \"\\\\rlap{\\\\large\\\\color{red}\\\\bigtriangleup}{\\\\ \\\\ \\\\tiny\\\\color{red}!}\";\n\n  turnErrorMessageToLatex = function(theErrorMessage) {\n    theErrorMessage = theErrorMessage.replace(/\\n/g, \"\");\n    theErrorMessage = theErrorMessage.replace(/_/g, \"} \\\\_ \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), 'g'), \"}{}^{T}\\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), 'g'), \"}\\\\cdot \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"Stop:\", \"}  \\\\quad \\\\text{Stop:\");\n    theErrorMessage = theErrorMessage.replace(\"->\", \"}  \\\\rightarrow \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"?\", \"}\\\\enspace \" + latexErrorSign + \" \\\\enspace  \\\\text{\");\n    theErrorMessage = \"$$\\\\text{\" + theErrorMessage.replace(/\\n/g, \"\") + \"}$$\";\n    //console.log \"theErrorMessage: \" + theErrorMessage\n    return theErrorMessage;\n  };\n\n  // there are around a dozen different unicodes that\n  // represent some sort of middle dot, let's catch the most\n  // common and turn them into what we can process\n  normaliseDots = function(stringToNormalise) {\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), 'g'), String.fromCharCode(dotprod_unicode));\n    return stringToNormalise;\n  };\n\n  TIMING_DEBUGS = false;\n\n  run = function(stringToBeRun, generateLatex = false) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i, indexOfPartRemainingToBeParsed, n, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;\n    timeStart = new Date().getTime();\n    //stringToBeRun = stringToBeRun + \"\\n\"\n    stringToBeRun = normaliseDots(stringToBeRun);\n    //console.log \"run running: \" + stringToBeRun\n    if (stringToBeRun === \"selftest\") {\n      selftest();\n      return;\n    }\n    if (!inited) {\n      inited = true;\n      init();\n    }\n    i = 0;\n    n = 0;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    while (1) {\n      try {\n        // while we can keep scanning commands out of the\n        // passed input AND we can execute them...\n        errorMessage = \"\";\n        check_stack();\n        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));\n        p1 = pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        //debugger\n        allReturnedPlainStrings += error.message;\n        if (generateLatex) {\n          //debugger\n          theErrorMessage = turnErrorMessageToLatex(error.message);\n          allReturnedLatexStrings += theErrorMessage;\n        }\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      // if debug mode then print the source text\n\n      //if (equaln(get_binding(symbol(TRACE)), 1)) {\n      //  for (i = 0 i < n i++)\n      //    if (s[i] != '\\r')\n      //      printchar(s[i])\n      //  if (s[n - 1] != '\\n') # n is not zero, see above\n      //    printchar('\\n')\n      //}\n      indexOfPartRemainingToBeParsed += n;\n      push(p1);\n      //debugger\n      errorWhileExecution = false;\n      try {\n        stringsEmittedByUserPrintouts = \"\";\n        top_level_eval();\n        //console.log \"emitted string after top_level_eval(): >\" + stringsEmittedByUserPrintouts + \"<\"\n        //console.log \"allReturnedPlainStrings string after top_level_eval(): >\" + allReturnedPlainStrings + \"<\"\n        p2 = pop();\n        check_stack();\n        if (isstr(p2)) {\n          if (DEBUG) {\n            console.log(p2.str);\n          }\n          if (DEBUG) {\n            console.log(\"\\n\");\n          }\n        }\n        // if the return value is nil there isn't much point\n        // in adding \"nil\" to the printout\n        if (p2 === symbol(NIL)) {\n          //collectedPlainResult = stringsEmittedByUserPrintouts\n          collectedPlainResult = stringsEmittedByUserPrintouts;\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + stringsEmittedByUserPrintouts + \"$$\";\n          }\n        } else {\n          //console.log \"emitted string before collectPlainStringFromReturnValue: >\" + stringsEmittedByUserPrintouts + \"<\"\n          //console.log \"allReturnedPlainStrings string before collectPlainStringFromReturnValue: >\" + allReturnedPlainStrings + \"<\"\n          collectedPlainResult = print_expr(p2);\n          collectedPlainResult += \"\\n\";\n          //console.log \"collectedPlainResult: >\" + collectedPlainResult + \"<\"\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + collectLatexStringFromReturnValue(p2) + \"$$\";\n            if (DEBUG) {\n              console.log(\"collectedLatexResult: \" + collectedLatexResult);\n            }\n          }\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n        }\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"printline\");\n          }\n          if (DEBUG) {\n            console.log(collectedPlainResult);\n          }\n        }\n        //alert collectedPlainResult\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"display:\");\n          }\n          print2dascii(p2);\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += \"\\n\";\n        }\n      } catch (error1) {\n        error = error1;\n        errorWhileExecution = true;\n        collectedPlainResult = error.message;\n        if (generateLatex) {\n          collectedLatexResult = turnErrorMessageToLatex(error.message);\n        }\n        if (PRINTOUTRESULT) {\n          console.log(collectedPlainResult);\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (collectedPlainResult !== \"\") {\n          allReturnedPlainStrings += \"\\n\";\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n          allReturnedLatexStrings += \"\\n\";\n        }\n        init();\n      }\n    }\n    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === \"\\n\") {\n      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);\n    }\n    if (generateLatex) {\n      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === \"\\n\") {\n        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);\n      }\n    }\n    if (generateLatex) {\n      if (DEBUG) {\n        console.log(\"allReturnedLatexStrings: \" + allReturnedLatexStrings);\n      }\n      stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];\n    } else {\n      stringToBeReturned = allReturnedPlainStrings;\n    }\n    if (TIMING_DEBUGS) {\n      timingDebugWrite = \"run time on: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStart) + \"ms\";\n      console.log(timingDebugWrite);\n    }\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    return stringToBeReturned;\n  };\n\n  check_stack = function() {\n    if (tos !== 0) {\n      debugger;\n      stop(\"stack error\");\n    }\n    if (frame !== TOS) {\n      debugger;\n      stop(\"frame error\");\n    }\n    if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {\n      debugger;\n      stop(\"symbols evaluation still ongoing?\");\n    }\n    if (evaluatingAsFloats !== 0) {\n      debugger;\n      stop(\"numeric evaluation still ongoing?\");\n    }\n    if (evaluatingPolar !== 0) {\n      debugger;\n      return stop(\"evaluation of polar still ongoing?\");\n    }\n  };\n\n  // cannot reference symbols yet\n\n  // returns nil on stack if no result to print\n  top_level_eval = function() {\n    var evalledArgument, originalArgument, shouldAutoexpand;\n    if (DEBUG) {\n      console.log(\"#### top level eval\");\n    }\n    trigmode = 0;\n    shouldAutoexpand = symbol(AUTOEXPAND);\n    if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {\n      expanding = 0;\n    } else {\n      expanding = 1;\n    }\n    originalArgument = top();\n    Eval();\n    evalledArgument = top();\n    // \"draw\", \"for\" and \"setq\" return \"nil\", there is no result to print\n    if (evalledArgument === symbol(NIL)) {\n      return;\n    }\n    // update \"last\" to contain the last result\n    set_binding(symbol(LAST), evalledArgument);\n    if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {\n      bake();\n      evalledArgument = top();\n    }\n    // If user asked explicitly asked to evaluate \"i\" or \"j\" and\n    // they represent the imaginary unit (-1)^(1/2), then \n    // show (-1)^(1/2).\n    if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {\n\n    // In all other cases, replace all instances of (-1)^(1/2) in the result\n    // with the symbol \"i\" or \"j\" depending on which one\n    // represents the imaginary unit\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_J);\n      return subst();\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_I);\n      return subst();\n    }\n  };\n\n  check_esc_flag = function() {\n    if (esc_flag) {\n      return stop(\"esc key\");\n    }\n  };\n\n  // this is called when the whole notebook is re-run\n  // so we get the chance of clearing the whole state from\n  // scratch.\n  // In practice, the state we need to clear that persists\n  // across blocks are only the patterns, so\n  // just eject those.\n  clearAlgebraEnvironment = function() {\n    //console.log \"CLEARING clearAlgebraEnvironment =============================================================\"\n    return do_clearall();\n  };\n\n  computeDependenciesFromAlgebra = function(codeFromAlgebraBlock) {\n    var i, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra!!!\");\n    }\n    // return findDependenciesInScript(codeFromAlgebraBlock, true)[6]\n\n    // TODO this part below is duplicated from computeResultsAndJavaScriptFromAlgebra\n    //      ...should refactor.\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra: patterns in the list --------------- \");\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    called_from_Algebra_block = false;\n    return findDependenciesInScript(codeFromAlgebraBlock, true)[6];\n  };\n\n  computeResultsAndJavaScriptFromAlgebra = function(codeFromAlgebraBlock) {\n    var code, dependencyInfo, i, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    timeStartFromAlgebra = new Date().getTime();\n    if (TIMING_DEBUGS) {\n      console.log(\" --------- computeResultsAndJavaScriptFromAlgebra input: \" + codeFromAlgebraBlock + \" at: \" + (new Date()));\n    }\n    // we start \"clean\" each time:\n    // clear all the symbols and then re-define\n    // the \"starting\" symbols.\n\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    stringToBeRun = codeFromAlgebraBlock;\n    if (DEBUG) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- \");\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    //debugger\n    [testableStringIsIgnoredHere, result, code, readableSummaryOfCode, latexResult, errorMessage, dependencyInfo] = findDependenciesInScript(codeFromAlgebraBlock);\n    called_from_Algebra_block = false;\n    if (readableSummaryOfCode !== \"\" || errorMessage !== \"\") {\n      result += \"\\n\" + readableSummaryOfCode;\n      if (errorMessage !== \"\") {\n        result += \"\\n\" + errorMessage;\n      }\n      result = result.replace(/\\n/g, \"\\n\\n\");\n      latexResult += \"\\n\" + \"$$\" + readableSummaryOfCode + \"$$\";\n      if (errorMessage !== \"\") {\n        latexResult += turnErrorMessageToLatex(errorMessage);\n      }\n      latexResult = latexResult.replace(/\\n/g, \"\\n\\n\");\n    }\n    // remove empty results altogether from latex output, which happens\n    // for example for assignments to variables or\n    // functions definitions\n    latexResult = latexResult.replace(/\\n*/, \"\");\n    latexResult = latexResult.replace(/\\$\\$\\$\\$\\n*/g, \"\");\n    code = code.replace(/Math\\./g, \"\");\n    code = code.replace(/\\n/g, \"\\n\\n\");\n    //console.log \"code: \" + code\n    //console.log \"result: \" + result\n    //console.log \"latexResult: \" + latexResult\n    if (TIMING_DEBUGS) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return {\n      //code: \"// no code generated yet\\n//try again later\"\n      //code: \"console.log('some passed code is run'); window.something = 1;\"\n      code: code,\n      // TODO temporarily pass latex in place of standard result too\n      result: latexResult,\n      latexResult: latexResult,\n      dependencyInfo: dependencyInfo\n    };\n  };\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).run = run;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;\n\n  //   _______\n  //  |  | <- stack\n  //  |  |\n  //  |_______|\n  //  |  | <- stack + tos\n  //  |  |\n  //  |  |\n  //  |_______|\n  //  |  | <- frame\n  //  |_______|\n  //      <- stack + TOS\n\n  //  The stack grows from low memory towards high memory. This is so that\n  //  multiple expressions can be pushed on the stack and then accessed as an\n  //  array.\n\n  //  The frame area holds local variables and grows from high memory towards\n  //  low memory. The frame area makes local variables visible to the garbage\n  //  collector.\n  tos = 0;\n\n  // p is a U\n  nil_symbols = 0;\n\n  push = function(p) {\n    if (p == null) {\n      debugger;\n    }\n    if (p.isZero != null) {\n      debugger;\n    }\n    //console.log \"pushing \"\n    //console.log print_list(p)\n    if (p === symbol(NIL)) {\n      nil_symbols++;\n      if (DEBUG) {\n        console.log(\"pushing symbol(NIL) #\" + nil_symbols);\n      }\n    }\n    //if nil_symbols == 111\n    //  debugger\n    if (tos >= frame) {\n      stop(\"stack overflow\");\n    }\n    return stack[tos++] = p;\n  };\n\n  // returns a U\n  moveTos = function(stackPos) {\n    if (tos <= stackPos) {\n      // we are moving the stack pointer\n      // \"up\" the stack (as if we were doing a push)\n      tos = stackPos;\n      return;\n    }\n    // we are moving the stack pointer\n    // \"down\" the stack i.e. as if we were\n    // doing a pop, we can zero-\n    // out all the elements that we pass\n    // so we can reclaim the memory\n    while (tos > stackPos) {\n      stack[tos] = null;\n      tos--;\n    }\n  };\n\n  top = function() {\n    return stack[tos - 1];\n  };\n\n  pop = function() {\n    var elementToBeReturned;\n    //popsNum++\n    //console.log \"pop #\" + popsNum\n    if (tos === 0) {\n      debugger;\n      stop(\"stack underflow\");\n    }\n    if (stack[tos - 1] == null) {\n      debugger;\n    }\n    elementToBeReturned = stack[--tos];\n    \n    // give a chance to the garbage\n    // collection to reclaim space\n    // This is JS-specific, it would\n    // actually make the C garbage\n    // collector useless.\n    stack[tos] = null;\n    return elementToBeReturned;\n  };\n\n  // n is an integer\n  push_frame = function(n) {\n    var i, l1, ref2, results;\n    i = 0;\n    frame -= n;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    results = [];\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      results.push(stack[frame + i] = symbol(NIL));\n    }\n    return results;\n  };\n\n  // n is an integer\n  pop_frame = function(n) {\n    frame += n;\n    if (frame > TOS) {\n      return stop(\"frame underflow\");\n    }\n  };\n\n  save = function() {\n    frame -= 10;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    stack[frame + 0] = p0;\n    stack[frame + 1] = p1;\n    stack[frame + 2] = p2;\n    stack[frame + 3] = p3;\n    stack[frame + 4] = p4;\n    stack[frame + 5] = p5;\n    stack[frame + 6] = p6;\n    stack[frame + 7] = p7;\n    stack[frame + 8] = p8;\n    return stack[frame + 9] = p9;\n  };\n\n  restore = function() {\n    if (frame > TOS - 10) {\n      stop(\"frame underflow\");\n    }\n    p0 = stack[frame + 0];\n    p1 = stack[frame + 1];\n    p2 = stack[frame + 2];\n    p3 = stack[frame + 3];\n    p4 = stack[frame + 4];\n    p5 = stack[frame + 5];\n    p6 = stack[frame + 6];\n    p7 = stack[frame + 7];\n    p8 = stack[frame + 8];\n    p9 = stack[frame + 9];\n    return frame += 10;\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  swap = function() {\n    var p, q;\n    //U *p, *q\n    // p and q are both Us\n    p = pop();\n    q = pop();\n    push(p);\n    return push(q);\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  dupl = function() {\n    var p;\n    //U *p\n    p = pop();\n    push(p);\n    return push(p);\n  };\n\n  $.dupl = dupl;\n\n  $.swap = swap;\n\n  $.restore = restore;\n\n  $.save = save;\n\n  $.push = push;\n\n  $.pop = pop;\n\n  // The symbol table is a simple array of struct U.\n\n  // put symbol at index n\n  Eval_symbolsinfo = function() {\n    var symbolsinfoToBePrinted;\n    symbolsinfoToBePrinted = symbolsinfo();\n    if (symbolsinfoToBePrinted !== \"\") {\n      return push(new_string(symbolsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  symbolsinfo = function() {\n    var bindingi, i, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;\n    symbolsinfoToBePrinted = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = symtab[i] + \"\";\n      bindingi = (binding[i] + \"\").substring(0, 4);\n      symbolsinfoToBePrinted += \"symbol: \" + symtabi + \" size: \" + countsize(binding[i]) + \" value: \" + bindingi + \"...\\n\";\n    }\n    return symbolsinfoToBePrinted;\n  };\n\n  // s is a string, n is an int\n  // TODO: elsewhere when we create a symbol we\n  // rather prefer to create a new entry. Here we just\n  // reuse the existing one. If that can never be a problem\n  // then explain why, otherwise do create a new entry.\n  std_symbol = function(s, n, latexPrint) {\n    var p;\n    p = symtab[n];\n    if (p == null) {\n      debugger;\n    }\n    p.printname = s;\n    if (latexPrint != null) {\n      return p.latexPrint = latexPrint;\n    } else {\n      return p.latexPrint = s;\n    }\n  };\n\n  // symbol lookup, or symbol creation if symbol doesn't exist yet\n  // this happens often from the scanner. When the scanner sees something\n  // like myVar = 2, it create a tree (SETQ (\"myVar\" symbol as created/looked up here (2)))\n  // user-defined functions also have a usr symbol.\n\n  // Note that some symbols like, say, \"abs\",\n  // are picked up by the scanner directly as keywords,\n  // so they are not looked up via this.\n  // So in fact you could redefine abs to be abs(x) = x\n  // but still abs would be picked up by the scanner as a particular\n  // node type and calls to abs() will be always to the \"native\" abs\n\n  // Also note that some symbols such as \"zero\" are (strangely) not picked up by\n  // the scanner as special nodes, rather they are identified as keywords\n  // (e.g. not redefinable) at time of symbol lookup (in Eval_sym) and\n  // evalled, where eval has a case for ZERO.\n\n  // Also note that there are a number of symbols, such as a,b,c,x,y,z,...\n  // that are actually created by std_symbols.\n  // They are not special node types (like abs), they are normal symbols\n  // that are looked up, but the advantage is that since they are often\n  // used internally by algebrite, we create the symbol in advance and\n  // we can reference the symbol entry in a clean way\n  // (e.g. symbol(SYMBOL_X)) rather than\n  // by looking up a string.\n\n  // s is a string\n  usr_symbol = function(s) {\n    var i, l1, ref2;\n    //console.log \"usr_symbol of \" + s\n    //if s == \"aaa\"\n    //  debugger\n\n    // find either the existing symbol, or if we\n    // reach an empty symbol (printname == \"\") then\n    // re-use that location.\n    i = 0;\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (s === symtab[i].printname) {\n        // found the symbol\n        return symtab[i];\n      }\n      if (symtab[i].printname === \"\") {\n        // found an entry in the symbol table\n        // with no printname, exit the loop\n        // and re-use this location\n        break;\n      }\n    }\n    if (i === NSYM) {\n      stop(\"symbol table overflow\");\n    }\n    symtab[i] = new U();\n    symtab[i].k = SYM;\n    symtab[i].printname = s;\n    // say that we just created the symbol\n    // then, binding[the new symbol entry]\n    // by default points to the symbol.\n    // So the value of an unassigned symbol will\n    // be just its name.\n    binding[i] = symtab[i];\n    isSymbolReclaimable[i] = false;\n    return symtab[i];\n  };\n\n  // get the symbol's printname\n\n  // p is a U\n  get_printname = function(p) {\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    return p.printname;\n  };\n\n  // p and q are both U\n  // there are two Us at play here. One belongs to the\n  // symtab array and is the variable name.\n  // The other one is the U with the content, and that\n  // one will go in the corresponding \"binding\" array entry.\n  set_binding = function(p, q) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"setting binding of \" + p.toString() + \" to: \" + q.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> set_binding lookup \" + indexFound);\n    }\n    isSymbolReclaimable[indexFound] = false;\n    return binding[indexFound] = q;\n  };\n\n  // p is a U\n  get_binding = function(p) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"getting binding of \" + p.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> get_binding lookup \" + indexFound);\n    }\n    //if indexFound == 139\n    //  debugger\n    //if indexFound == 137\n    //  debugger\n    return binding[indexFound];\n  };\n\n  // the concept of user symbol is a little fuzzy\n  // beucase mathematics is full of symbols that actually\n  // have a special meaning, e.g. e,i,I in some cases j...\n  is_usr_symbol = function(p) {\n    var theSymnum;\n    if (p.k !== SYM) {\n      return false;\n    }\n    theSymnum = symnum(p);\n    // see \"defs\" file for the naming of the symbols\n    if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {\n      return true;\n    }\n    return false;\n  };\n\n  // get symbol's number from ptr\n  // p is U\n  lookupsTotal = 0;\n\n  symnum = function(p) {\n    var indexFound;\n    lookupsTotal++;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    indexFound = symtab.indexOf(p);\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> symnum lookup \" + indexFound + \" lookup # \" + lookupsTotal);\n    }\n    //if lookupsTotal == 21\n    //  debugger\n    //if indexFound == 79\n    //  debugger\n    return indexFound;\n  };\n\n  // push indexed symbol\n\n  // k is an int\n  push_symbol = function(k) {\n    return push(symtab[k]);\n  };\n\n  clear_symbols = function() {\n    var i, l1, ref2, ref3, results;\n// we can clear just what's assignable.\n// everything before NIL is not assignable,\n// so there is no need to clear it.\n    results = [];\n    for (i = l1 = ref2 = NIL + 1, ref3 = NSYM; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      // stop at the first empty\n      // entry that is not reclaimable\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      results.push(isSymbolReclaimable[i] = false);\n    }\n    return results;\n  };\n\n  //symtab[i].printname = \"\"\n  //binding[i] = symtab[i]\n\n  // collect all the variables in a tree\n  collectUserSymbols = function(p, accumulator = []) {\n    var i, l1, ref2;\n    if (is_usr_symbol(p)) {\n      if (accumulator.indexOf(p) === -1) {\n        accumulator.push(p);\n        return;\n      }\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        collectUserSymbols(p.tensor.elem[i], accumulator);\n      }\n      return;\n    }\n    while (iscons(p)) {\n      collectUserSymbols(car(p), accumulator);\n      p = cdr(p);\n    }\n  };\n\n  $.get_binding = get_binding;\n\n  $.set_binding = set_binding;\n\n  $.usr_symbol = usr_symbol;\n\n  $.symbolsinfo = symbolsinfo;\n\n  $.collectUserSymbols = collectUserSymbols;\n\n  if (!inited) {\n    inited = true;\n    init();\n  }\n\n  $.init = init;\n\n  parse_internal = function(argu) {\n    if (typeof argu === 'string') {\n      return scan(argu);\n    // now its in the stack\n    } else if (typeof argu === 'number') {\n      if (argu % 1 === 0) {\n        return push_integer(argu);\n      } else {\n        return push_double(argu);\n      }\n    } else if (argu instanceof U) {\n      // hey look its a U\n      return push(argu);\n    } else {\n      console.warn('unknown argument type', argu);\n      return push(symbol(NIL));\n    }\n  };\n\n  parse = function(argu) {\n    var data, error;\n    try {\n      parse_internal(argu);\n      data = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return data;\n  };\n\n  // exec handles the running ia JS of all the algebrite\n  // functions. The function name is passed in \"name\" and\n  // the corresponding function is pushed at the top of the stack\n  exec = function(name, ...argus) {\n    var argu, error, fn, l1, len, result;\n    fn = get_binding(usr_symbol(name));\n    check_stack();\n    push(fn);\n    for (l1 = 0, len = argus.length; l1 < len; l1++) {\n      argu = argus[l1];\n      parse_internal(argu);\n    }\n    list(1 + argus.length);\n    p1 = pop();\n    push(p1);\n    try {\n      top_level_eval();\n      result = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return result;\n  };\n\n  $.exec = exec;\n\n  $.parse = parse;\n\n  (function() {\n    var builtin_fns, fn, l1, len, results;\n    builtin_fns = [\"abs\", \"add\", \"adj\", \"and\", \"approxratio\", \"arccos\", \"arccosh\", \"arcsin\", \"arcsinh\", \"arctan\", \"arctanh\", \"arg\", \"atomize\", \"besselj\", \"bessely\", \"binding\", \"binomial\", \"ceiling\", \"check\", \"choose\", \"circexp\", \"clear\", \"clearall\", \"clearpatterns\", \"clock\", \"coeff\", \"cofactor\", \"condense\", \"conj\", \"contract\", \"cos\", \"cosh\", \"decomp\", \"defint\", \"deg\", \"denominator\", \"det\", \"derivative\", \"dim\", \"dirac\", \"divisors\", \"do\", \"dot\", \"draw\", \"dsolve\", \"eigen\", \"eigenval\", \"eigenvec\", \"erf\", \"erfc\", \"eval\", \"exp\", \"expand\", \"expcos\", \"expsin\", \"factor\", \"factorial\", \"factorpoly\", \"filter\", \"float\", \"floor\", \"for\", \"Gamma\", \"gcd\", \"hermite\", \"hilbert\", \"imag\", \"component\", \"inner\", \"integral\", \"inv\", \"invg\", \"isinteger\", \"isprime\", \"laguerre\", \"lcm\", \"leading\", \"legendre\", \"log\", \"mod\", \"multiply\", \"not\", \"nroots\", \"number\", \"numerator\", \"operator\", \"or\", \"outer\", \"pattern\", \"patternsinfo\", \"polar\", \"power\", \"prime\", \"print\", \"print2dascii\", \"printcomputer\", \"printlatex\", \"printlist\", \"printhuman\", \"product\", \"quote\", \"quotient\", \"rank\", \"rationalize\", \"real\", \"rect\", \"roots\", \"round\", \"equals\", \"shape\", \"sgn\", \"silentpattern\", \"simplify\", \"sin\", \"sinh\", \"sqrt\", \"stop\", \"subst\", \"sum\", \"symbolsinfo\", \"tan\", \"tanh\", \"taylor\", \"test\", \"testeq\", \"testge\", \"testgt\", \"testle\", \"testlt\", \"transpose\", \"unit\", \"zero\"];\n    results = [];\n    for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {\n      fn = builtin_fns[l1];\n      results.push($[fn] = exec.bind(this, fn));\n    }\n    return results;\n  })();\n\n  freeze = function() {\n    var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = [];\n    frozenContents = [];\n    frozenPatterns = [];\n    frozenHash = \"\";\n    for (i = l1 = 0, ref2 = symtab.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      //if symtab[i].printname == \"\"\n      //  if isSymbolReclaimable[i] == false\n      //    break\n      //  else\n      //    continue\n      if (isSymbolReclaimable[i] === false) {\n        frozenSymbols.push(symtab[i]);\n        frozenContents.push(binding[i]);\n      }\n    }\n    // just clone them\n    frozenPatterns = userSimplificationsInListForm.slice(0);\n    return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];\n  };\n\n  unfreeze = function(frozen) {\n    var frozenContents, frozenPatterns, frozenSymbols, i, l1, ref2;\n    [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit] = frozen;\n//clear_symbols()\n    for (i = l1 = 0, ref2 = frozenSymbols.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = frozenSymbols[i];\n      binding[i] = frozenContents[i];\n    }\n    return userSimplificationsInListForm = frozenPatterns.slice(0);\n  };\n\n  compareState = function(previousHash) {\n    var frozenHash;\n    frozenHash = getStateHash();\n    if (frozenHash === previousHash) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getStateHash = function() {\n    var bindingi, frozenHash, i, l1, len, m1, ref2, ref3, symtabi;\n    frozenHash = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = print_list(symtab[i]);\n      bindingi = print_list(binding[i]);\n      frozenHash += \" //\" + symtabi + \" : \" + bindingi;\n    }\n    for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {\n      i = userSimplificationsInListForm[m1];\n      frozenHash += \" pattern: \" + i;\n    }\n    if (DEBUG) {\n      console.log(\"frozenHash: \" + frozenHash);\n    }\n    return frozenHash;\n  };\n\n}).call(this);\n"],
  "mappings": "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,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA;AAAA,QAGA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA;AAAA,QAEA;AAAA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA;AAAA;AAAA;AAAA,QAKA;AAAA;AAAA,QAEA;AAAA;AAAA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",
  "names": ["exports", "module", "bigInt", "sign", "length", "i", "add", "subtract", "abs", "square", "guess", "mod", "gcd", "lcm", "top", "max", "min", "rational", "U", "tensor", "o", "ref", "display", "text_metric", "theArgument", "i1", "j1", "ref1", "p1", "p2", "ref2", "o2", "flag", "count", "power", "numericRootOfPolynomial", "fbody", "glyph", "oneElement", "tos", "inited"]
}
